#!/bin/bash
#/----------------------------------------------------------------------\
#|                                                                      |
#|                      __   __    ____ _____ ____                      |
#|                      \ \ / /_ _/ ___|_   _|___ \                     |
#|                       \ V / _` \___ \ | |   __) |                    |
#|                        | | (_| |___) || |  / __/                     |
#|                        |_|\__,_|____/ |_| |_____|                    |
#|                                                                      |
#|                                installer                             |
#|                                                        (C) SuSE GmbH |
#\----------------------------------------------------------------------/
#
#   File:       yast2
#
#   Author:     Steffen Winterfeldt <snwint@suse.de>
#   Maintainer: Steffen Winterfeldt <snwint@suse.de>
#
#
#   This script is called to start YaST2 during the installation.
#   There are three types of user interfaces:
#
#    - Qt/X11 based
#    - console/ncurses based
#    - serial line ttyS0/115200 baud, 8N1, RTS/CTS
#
#   These are available via
#
#    - remote X Server ($DISPLAY is set, e.g. via ssh -X)
#    - local X Server  ($DISPLAY is unset)
#    - text console (local, telnet/ssh, serial console)
#/-*/


# load common script functions
. /usr/lib/YaST2/bin/yast2-funcs


function log {
    echo "$@" >> $logdir/y2start.log 2>/dev/null
}


function logmeminfo {
    echo -n "meminfo $1 = " >> $logdir/y2start.log
    free | grep "Mem:" | sed -e 's/ \+/ /g' >> $logdir/y2start.log
}


function y2cc_qt()
{
    # set lang from sysconfig
    set_lang_from_sysconfig

    if echo $moduleargs | grep -q continue ; then
	log "Continue mode"
        if [ -e /var/lib/YaST2/start_y2cc ]; then
            # Check for semaphore file (created in inst_proposal.ycp)
            log "y2cc requested"

            width=`/usr/X11R6/bin/xwininfo -root | sed -n -e '/Width:/s/^.*Width:[ \t]//p'`
            height=`/usr/X11R6/bin/xwininfo -root | sed -n -e '/Height:/s/^.*Height:[ \t]//p'`
	    wm_pid=0

            # Start a window manager - y2cc needs a window manager for reasonable keyboard operation.

            if [ -x /usr/X11R6/bin/mwm ]; then
        	# MWM (the Motif window manager) is easy to use, but not necessarily available.
        	log "Starting mwm"
        	/usr/X11R6/bin/mwm -xrm '*clientDecoration: none' -xrm '*showFeedback: none' &

		# MWM doesn't let windows grow any larger than the desktop, so
		# leave width and height alone.
            elif [ -x /usr/X11R6/bin/twm ]; then
        	# TWM's quirks may confuse newbies, but it's part of XFree86,
        	# so it should always be available.
        	log "Starting twm"
        	/usr/X11R6/bin/twm &
        	# Compensate for window manager decorations
        	height=$(($height-24))
        	width=$(($width-4))
            else
        	log "No window manager available"
            fi

            # Export geometry for modules started via the y2cc
            export Y2_GEOMETRY="${width}x${height}+0+0"

            # Delete semaphore file (created in inst_proposal.ycp)
            rm -f /var/lib/YaST2/start_y2cc

            # Start the control center
            log "Starting YaST2 control center in Qt mode with -geometry $Y2_GEOMETRY"
            y2controlcenter qt -style=platinum -fn $Y2_XFONT -geometry $Y2_GEOMETRY -Q

	    # The window manager will go down along with the X server.
	    # MWM has been told to shut up with the '*showFeedback' resource,
	    # so it shouldn't ask questions before going down.
        fi
    fi
}


function y2cc_ncurses()
{
    # set lang from sysconfig
    set_lang_from_sysconfig

    if echo $moduleargs | grep -q continue ; then
	if [ -e /var/lib/YaST2/start_y2cc ]; then
	    # Check for semaphore file (created in inst_proposal.ycp)
	    log "Starting YaST2 control center in NCurses mode"
	    rm -f /var/lib/YaST2/start_y2cc
	    y2base menu ncurses
	fi
    fi
}

# This environment variable will tell child processes they are started from
# within a YaST2 environment
export YAST2_RUNNING=$$

# Qt create .qt and .xftcache and we don't want those things in /
export HOME=/root

echo -n > $logdir/y2start.log
log env
log echo "Y2DEBUG ($Y2DEBUG)"
logmeminfo "1"

#
#	if we a running on a s390 or s390x
#
HOSTTYPE=$(uname -m)
log "HOSTTYPE=$HOSTTYPE"
# its 0 for iSeries and != 0 otherwise
NOTISERIES=$(grep -qi iseries /proc/cpuinfo ; echo $?)
log "iSeries=$NOTISERIES"
# p690 hvc console, no kbd
NOTHVCCONSOLE=$(grep -q console=hvc < /proc/cmdline ; echo $?)
log "hvc_console=$NOTHVCCONSOLE"

# reread install.inf to get the variables
# install.inf might be missing during update
if [ -f /etc/install.inf ] ; then
  eval $(grep ': ' /etc/install.inf | sed -e 's/"/"\\""/g' -e 's/:  */="/' -e 's/$/"/')
fi
log "X11i=$X11i"

# get total memory
eval $(grep 'MemTotal' /proc/meminfo | sed -e 's/: */=/' -e 's/ *kB//')
log "MemTotal=$MemTotal"
#
# 1 TB of memory is enough and bash cannot use nums >2^31 (singed int)
[ ${#MemTotal} -gt 9 ] && MemTotal=1000000000

# check for a frame buffer device
fbdev_ok=
if (: < /dev/fb0) 2>/dev/null ; then
  fbdev_ok=1
fi
log "fbdev_ok=$fbdev_ok"

# TODO: on s390, no X server may be installed, so an update has to be
# recognized differently.
update=
[ -e /var/X11R6/bin/X -o -L /var/X11R6/bin/X ] && update=1
log "update=$update"

# use XF4 frame buffer, if possible
# note: $X11i is set if the user has *explicitly* requested a server
# don't use "fbdev" or "vga"  on Alphas (we do need the correct server here)!

if [ "`uname -m`" != alpha  ]; then
  if [ ! "$X11i" ] ; then
    if [  "$XServer" != firegl1 -a "$XServer" != vmware ] ; then
#     if [ ! \( "$XVersion" = 4 -a -e "/usr/X11R6/lib/modules/drivers/${XServer}_drv.o" \) ] ; then
        if [ "$fbdev_ok" = 1 ] ; then
          if [ -e /usr/X11R6/lib/modules/drivers/fbdev_drv.o ] ; then
            XVersion=4
            XServer=fbdev
          fi
          else
          if [ -e /usr/X11R6/lib/modules/drivers/vga_drv.o ] ; then
            XVersion=4
            XServer=vga
	    if [ "`uname -m`" = ppc ] ; then
		# no /dev/fb == no X
                XServer=
                Textmode=1
            fi
          fi
        fi
#     fi
    fi
  fi
fi
xsrv=
xsrvarg=
xpseudo=
if [ "$update" ] ; then
  xsrv=/var/X11R6/bin/X
  [ -x $xsrv ] || xsrv=
else
  if [ "$XVersion" = 4 ] ; then
    xsrv=XFree86
    xsrvarg=fbdev
    [ -f "/usr/X11R6/lib/modules/drivers/${XServer}_drv.o" ] && xsrvarg='0'
    [ "$XServer" = vga ] && xsrvarg='vga'
    [ "$XServer" = fbdev ] && xsrvarg='fbdev'
    [ "$XServer" = fbdev -a ! "$fbdev_ok" ] && xsrvarg='vga'

    # use visual PseudoColor on VGA
    [ "$xsrvarg" = vga ] && xpseudo='-cc 3'

    if [ -f /etc/X11/XF86Config ] ; then
      xcfg=/etc/X11/XF86Config
      cp $xcfg /tmp
      sed -e "s#Screen.*Screen\[.*\]#Screen	"\""Screen[$xsrvarg]#" /tmp/XF86Config >$xcfg
      rm /tmp/XF86Config
    fi
  else
    [ -x /usr/X11R6/bin/XF86_VGA16 ] && xsrv=XF86_VGA16
    [ "$fbdev_ok" -a -x /usr/X11R6/bin/XF86_FBDev ] && xsrv=XF86_FBDev
    [ -x /usr/X11R6/bin/XF86_$XServer ] && xsrv=XF86_$XServer
    [ "$xsrv" = XF86_FBDev -a ! "$fbdev_ok" ] && xsrv=XF86_VGA16
    [ "$XServer" = "MACH64" -a -x /usr/X11R6/bin/XF86_Mach64 ] && xsrv=XF86_Mach64
    [ "$XServer" = "3DLABS" -a -x /usr/X11R6/bin/XF86_3DLabs ] && xsrv=XF86_3DLabs
    [ "$XServer" = "SUN24" -a -x /usr/X11R6/bin/Xsun24 ] && xsrv=Xsun24
    [ "$XServer" = "SUN" -a -x /usr/X11R6/bin/Xsun ] && xsrv=Xsun
    [ "$XServer" = "SUNMONO" -a -x /usr/X11R6/bin/XsunMono ] && xsrv=XsunMono

    [ "$xsrv" = XF86_VGA16 ] && xpseudo='-cc 3'
  fi
fi

# only if we have a config file
[ -f /etc/X11/XF86Config -o -f /etc/XF86Config ] || xsrv=

log "XVersion=$XVersion"
log "XServer=$XServer"
log "xsrv=$xsrv"
log "screen=$xsrvarg"

# YaST2 module to start
modulename=${1:-installation}
shift
moduleargs=\(\"$*\"\)

qt_bg=""
if echo $moduleargs | egrep -q '\(initial|continue\)' ; then
    qt_bg="-bg #dedede"
fi

PATH=/var/X11R6/bin:$ybindir:$PATH

#
# if $DISPLAY is set, try to start yast2 there
#

if [ "$VNC" = "1" ] ; then
    if [ -x /usr/X11R6/bin/Xvnc ] ; then
	. /usr/lib/YaST2/bin/inst_setup_vnc
	export DISPLAY=:1
	y2base "$modulename" $moduleargs qt -style=platinum -fn $Y2_XFONT -geometry 800x600+1+1 -no-wm $qt_bg
	y2exitcode=$?
	[ $y2exitcode -eq 0 ] && y2cc_qt
	exit $y2exitcode
    else
	unset DISPLAY
    fi
fi

if [ "$DISPLAY" != "" ] ; then
    y2base "$modulename" $moduleargs qt -style=platinum -fn $Y2_XFONT -geometry 800x600 $qt_bg
    y2exitcode=$?
    [ $y2exitcode -eq 0 ] && y2cc_qt
    exit $y2exitcode
fi

#
# Use serial line, if either no keyboard is detected or
# the user pressed the right alt key. If the serial
# selection is done via the missing keyboard, a timeout
# of 15 seconds is introduced. If the detection goes wrong,
# the installation resumes after 15 seconds with ncurses
# or Qt interface
#

if [ ! "$update" -a "$YaST2serial" = "1" ] ; then
    log "using serial interface"
    echo "Trying to connect via serial interface /dev/ttyS0."
    echo "On your terminal computer start the user interface with"
    echo "y2base \"serial(115200):/dev/ttyS0\" qt -geometry 800x600 -style=platinum"
    echo "or"
    echo "y2base \"serial(115200):/dev/ttyS1\" qt -geometry 800x600 -style=platinum"
    echo "or start the YaST2 menu by typing \"yast2\" and select YaST2/Remote Install"
    y2base "$modulename" $moduleargs "serial(115200):/dev/ttyS0"
    y2exitcode=$?
    [ $y2exitcode -eq 0 ] && y2cc_ncurses
    exit $y2exitcode
fi

if [ \( ! "$update" \) -a "$Braille" ] ; then
   log "found a braille display"
   sed -e "s#brlname=.*#brlname=$Braille#" -e "s#brlport=.*#brlport=$Brailledevice#" /etc/suse-blinux.conf >/tmp/suse-blinux.conf
   mv -f /tmp/suse-blinux.conf /etc
   /etc/init.d/suse-blinux start
   xsrv=
fi

# iSeries and p690 dont have a keyboard but a special console, no need to
# run via serial console.

if [ ! "$update" -a "$Keyboard" = "0" -a ! "$Braille" -a "$NOTISERIES" != 0 -a "$NOTHVCCONSOLE" != 0 -a "$HOSTTYPE" != "s390" -a "$HOSTTYPE" != "s390x" ] ; then
    log "no keyboard?"
    echo "No keyboard detected. Trying to connect via serial interface /dev/ttyS0."
    echo "On your terminal computer start the user interface with"
    echo "y2base \"serial(115200):/dev/ttyS0\" qt -geometry 800x600 -style=platinum"
    echo "or"
    echo "y2base \"serial(115200):/dev/ttyS1\" qt -geometry 800x600 -style=platinum"
    echo "or start the YaST2 menu by typing \"yast2\" and select YaST2/Remote Install"
    y2base "$modulename" $moduleargs "serial(115200):/dev/ttyS0" --timeout 15
    y2exitcode=$?
    [ $y2exitcode -eq 0 ] && y2cc_ncurses
    if [ "$y2exitcode" = 13 ] ; then
	echo "Connection timeout. Continuing with normal setup."
    else
	exit $y2exitcode
    fi
fi

if [ "$Textmode" = 1 -o "$UseSSH" = 1 ] ; then
  log "text mode requested"
  (
    y2base "$modulename" $moduleargs ncurses
    y2exitcode=$?
    [ $y2exitcode -eq 0 ] && y2cc_ncurses
    exit $y2exitcode
  )
  y2exitcode=$?
  exit $y2exitcode
fi

# unset xsrv if qt plugin is not found or some libs are missing
if ! check_qt ; then
    log "qt plugin broken"
    xsrv=
fi

# YaST2 with Qt frontend needs a machine with about 60MB, so check for
# 56MB = 57344 kB (since MemTotal is less than the real memory size).
#
# TODO: on s390 the minimal memory requirements may be lower than
# this, since we have no X Server running locally.
if [ ! "$xsrv" -o "$MemTotal" -lt "57344" ] ; then
  log "no X server or not enough memory: using text mode"
  (
    y2base "$modulename" '("text_fallback")' $moduleargs ncurses
    y2exitcode=$?
    [ $y2exitcode -eq 0 ] && y2cc_ncurses
    exit $y2exitcode
  )
  y2exitcode=$?
  exit $y2exitcode
fi

server_running=
TESTX=/usr/X11R6/bin/testX
export DISPLAY=:0

if [ "$update" ] ; then
  X -deferglyphs 16 2>/dev/tty8 1>&2 vt07 &
  xserver_pid=$!
  # wait for the X server to come up
  while kill -0 $xserver_pid 2>/dev/null ; do
    sleep 1
    if test -e /tmp/.X11-unix/X0 && test -x $TESTX && $TESTX "$YaST2color" 2>/dev/null ; then
      server_running=1
      break
    fi
  done
else
  if [ "$xsrv" ] ; then
    # try to work around the mode line problem:
    # 1st, we try the 31.5k mode lines only; if this does not
    # work, we use all mode lines
    if [ "$XVersion" = 4 ]; then
      sed -e '/[3-6]\. *Try/ d' /etc/X11/XF86Config >/etc/X11/XF86Config_31.5k
      ln -snf /usr/X11R6/bin/$xsrv /var/X11R6/bin/X
      X $xpseudo -xf86config /etc/X11/XF86Config_31.5k -deferglyphs 16 2>/dev/tty8 1>&2 vt07 &
      xserver_pid=$!
      # wait for the X server to come up
      while kill -0 $xserver_pid 2>/dev/null ; do
        sleep 1
        if test -e /tmp/.X11-unix/X0 && test -x $TESTX && $TESTX "$YaST2color" 2>/dev/null ; then
          server_running=1
          break
        fi
      done
    fi

    if [ ! "$server_running" ]; then
      ln -snf /usr/X11R6/bin/$xsrv /var/X11R6/bin/X
      X $xpseudo -deferglyphs 16 2>/dev/tty8 1>&2 vt07 &
      xserver_pid=$!
      # wait for the X server to come up
      while kill -0 $xserver_pid 2>/dev/null ; do
        sleep 1
        if test -e /tmp/.X11-unix/X0 && test -x $TESTX && $TESTX "$YaST2color" 2>/dev/null ; then
          server_running=1
          break
        fi
      done
    fi
  fi
fi

logmeminfo "2"

if [ "$server_running" ] ; then
  y2base "$modulename" $moduleargs qt -style=platinum -fn $Y2_XFONT -geometry 800x600 -no-wm $qt_bg
  y2exitcode=$?
  [ $y2exitcode -eq 0 ] && y2cc_qt
  sleep 1
  kill $xserver_pid
  # wait for the X server to shut down
  while kill -0 $xserver_pid 2>/dev/null ; do
    sleep 1
  done
else
  log "X server did not start: using text mode"
  (
    y2base "$modulename" '("no_x11")' $moduleargs ncurses
    y2exitcode=$?
    [ $y2exitcode -eq 0 ] && y2cc_ncurses
    exit $y2exitcode
  )
  y2exitcode=$?
fi

rm -f /etc/X11/XF86Config_31.5k
[ ! -d /proc/iSeries -a "$HOSTTYPE" != "s390" -a "$HOSTTYPE" != "s390x" ] && chvt 1
log "y2exitcode=$y2exitcode"
exit $y2exitcode
