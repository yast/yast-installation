#!/bin/bash
#/----------------------------------------------------------------------\
#|                                                                      |
#|                      __   __    ____ _____ ____                      |
#|                      \ \ / /_ _/ ___|_   _|___ \                     |
#|                       \ V / _` \___ \ | |   __) |                    |
#|                        | | (_| |___) || |  / __/                     |
#|                        |_|\__,_|____/ |_| |_____|                    |
#|                                                                      |
#|                                installer                             |
#|                                                        (C) SuSE GmbH |
#\----------------------------------------------------------------------/
#
#   File:       yast2
#
#   Author:     Steffen Winterfeldt <snwint@suse.de>
#   Maintainer: Steffen Winterfeldt <snwint@suse.de>
#
#
#   This script is called to start YaST2 during the installation.
#   There are three types of user interfaces:
#
#    - Qt/X11 based
#    - console/ncurses based
#    - serial line ttyS0/115200 baud, 8N1, RTS/CTS
#
#   These are available via
#
#    - remote X Server ($DISPLAY is set, e.g. via ssh -X)
#    - local X Server  ($DISPLAY is unset)
#    - text console (local, telnet/ssh, serial console)
#/-*/


# load common script functions
. /usr/lib/YaST2/bin/yast2-funcs


function set_proxy()
{
    if grep -qs '^Proxy:.*' /etc/install.inf ; then

	Proxy=$(awk ' /^Proxy:/ { print $2 }' < /etc/install.inf)
	ProxyPort=$(awk ' /^ProxyPort:/ { print $2 }' < /etc/install.inf)
	ProxyProto=$(awk ' /^ProxyProto:/ { print $2 }' < /etc/install.inf)

	FullProxy="${ProxyProto}://${Proxy}:${ProxyPort}/"

	export http_proxy=$FullProxy
	export ftp_proxy=$FullProxy

    fi
}


function set_syslog()
{
    Loghost=$(awk ' /^Loghost:/ { print $2 }' < /etc/install.inf)

     test ! -z $Loghost && {
        mkdir -p /etc/YaST2
        cat <<EOF > /etc/YaST2/log.conf
[Log]
file = true
syslog = true

EOF
        grep -iwq y2debug < /proc/cmdline && {
            echo "debug=true" >> /etc/YaST2/log.conf
        }
        echo "*.* @$Loghost" >> /etc/syslog.conf
        kill -HUP `cat /var/run/syslogd.pid`
    }
}

function log {
    echo "$@" >> $logdir/y2start.log 2>/dev/null
}


function logmeminfo {
    echo -n "meminfo $1 = " >> $logdir/y2start.log
    free | grep "Mem:" | sed -e 's/ \+/ /g' >> $logdir/y2start.log
}


# check whether the system can use fbiterm
# also handle the CJK language mangle on linux console
function check_run_fbiterm ()
{
    RUN_FBITERM=0
    if test "$MemTotal" -lt "57344" ; then
	return
    fi
    TTY=`/usr/bin/tty`
    if test "$TERM" = "linux" -a \( "$TTY" = /dev/console -o "$TTY" != "${TTY#/dev/tty[0-9]}" \) ; then
	case "$LANG" in
	ja*.UTF-8|ko*.UTF-8|zh*.UTF-8)
	    # check whether fbiterm can run on console
	    if test -x /usr/bin/fbiterm && /usr/bin/fbiterm echo >/dev/null 2>&1; then
		RUN_FBITERM=1
	    else
		# use english
		export LANG=en_US.UTF-8
		export LC_CTYPE=en_US.UTF-8
	    fi
	    ;;
	ja*|ko*|zh*)
	    # use english
	    export LANG=en_US.UTF-8
	    export LC_CTYPE=en_US.UTF-8
	    ;;
	esac
    fi
}

function y2cc_qt()
{
    # set lang from sysconfig
    set_lang_from_sysconfig

    if echo $moduleargs | grep -q continue ; then

        # Check for semaphore file (created in inst_proposal.ycp)
        if [ -e /var/lib/YaST2/start_y2cc ]; then

            # Delete semaphore file (created in inst_proposal.ycp)
            rm -f /var/lib/YaST2/start_y2cc

            # Start the control center
            log "Starting YaST2 control center in Qt mode"
            y2controlcenter qt $y2cc_qt_args -Q
        fi
    fi
}


function y2cc_ncurses()
{
    # set lang from sysconfig
    set_lang_from_sysconfig

    if echo $moduleargs | grep -q continue ; then

	# Check for semaphore file (created in inst_proposal.ycp)
	if [ -e /var/lib/YaST2/start_y2cc ]; then

	    # Delete semaphore file (created in inst_proposal.ycp)
	    rm -f /var/lib/YaST2/start_y2cc

	    # Start the control center
	    log "Starting YaST2 control center in NCurses mode"
	    check_run_fbiterm
	    if test "$RUN_FBITERM" = "1" ; then
		/usr/bin/fbiterm y2base menu ncurses
	    else
		y2base menu ncurses
	    fi
	fi
    fi
}

function wait_for_x11()
{
	while kill -0 $xserver_pid 2>/dev/null ; do
		sleep 1
		if test -e /tmp/.X11-unix/X0 && test -x $TESTX ; then
			$TESTX "$YaST2color" 2>/dev/null
			err=$?
			# exit code 1 -> XOpenDisplay failed...
			if test $err = 1;then
				continue
			fi
			# exit code 2 -> color or dimensions doesn't fit...
			if test $err = 2;then
				kill $xserver_pid
				break;
			fi
			server_running=1
			break
		fi
	done
}

# set splash progress bar to 90%
[ -f /proc/splash ] && echo "show $((90*65534/100))" >/proc/splash

# Qt create .qt and .xftcache and we don't want those things in /
export HOME=/root

echo -n > $logdir/y2start.log
log env
log echo "Y2DEBUG ($Y2DEBUG)"
logmeminfo "1"

# setup proxy
set_proxy

# setup syslog
set_syslog

#
#	if we a running on a s390 or s390x
#
HOSTTYPE=$(uname -m)
log "HOSTTYPE=$HOSTTYPE"
# its 0 for iSeries and != 0 otherwise
NOTISERIES=$(grep -qi iseries /proc/cpuinfo ; echo $?)
log "iSeries=$NOTISERIES"
# p690 hvc console, no kbd
NOTHVCCONSOLE=$(grep -q console=hvc < /proc/cmdline ; echo $?)
log "hvc_console=$NOTHVCCONSOLE"

# reread install.inf to get the variables
# install.inf might be missing during update
if [ -f /etc/install.inf ] ; then
  eval $(grep ': ' /etc/install.inf | sed -e 's/"/"\\""/g' -e 's/:  */="/' -e 's/$/"/')
fi
log "X11i=$X11i"

# get total memory
eval $(grep '^MemTotal' /proc/meminfo | sed -e 's/: */=/' -e 's/ *kB//')
log "MemTotal=$MemTotal"
#
# 1 TB of memory is enough and bash cannot use nums >2^31 (singed int)
[ ${#MemTotal} -gt 9 ] && MemTotal=1000000000

# check for a frame buffer device
fbdev_ok=
if (: < /dev/fb0) 2>/dev/null ; then
  fbdev_ok=1
fi
log "fbdev_ok=$fbdev_ok"

# TODO: on s390, no X server may be installed, so an update has to be
# recognized differently.
update=
[ -e /var/X11R6/bin/X -o -L /var/X11R6/bin/X ] && update=1
log "update=$update"

# use XF4 frame buffer, if possible
# note: $X11i is set if the user has *explicitly* requested a server
# don't use "fbdev" or "vga"  on Alphas (we do need the correct server here)!

x11_driver_dir=/usr/X11R6/lib/modules/drivers
[ -d /usr/X11R6/lib64/modules/drivers ] && x11_driver_dir=/usr/X11R6/lib64/modules/drivers

if [ "`uname -m`" != alpha  ]; then
  if [ ! "$X11i" ] ; then
    if [  "$XServer" != firegl1 -a "$XServer" != vmware ] ; then
#     if [ ! \( "$XVersion" = 4 -a -e "$x11_driver_dir/${XServer}_drv.o" \) ] ; then
        if [ "$fbdev_ok" = 1 ] ; then
          if [ -e $x11_driver_dir/fbdev_drv.o ] ; then
            XVersion=4
            XServer=fbdev
          fi
        else
          if [ -e $x11_driver_dir/vga_drv.o ] ; then
            XVersion=4
            XServer=vga
	    if [ "`uname -m`" = ppc ] ; then
		# no /dev/fb == no X
                XServer=
                Textmode=1
            fi
          fi
          if [ -e $x11_driver_dir/vesa_drv.o ] ; then
            XVersion=4
            XServer=vesa
          fi
        fi
#     fi
    fi
  fi
fi
xsrv=
xsrvarg=
xpseudo=
if [ "$update" ] ; then
  xsrv=/var/X11R6/bin/X
  [ -x $xsrv ] || xsrv=
else
  if [ "$XVersion" = 4 ] ; then
    xsrv=XFree86
    xsrvarg=fbdev
    [ -f "$x11_driver_dir/${XServer}_drv.o" ] && xsrvarg='0'
    [ "$XServer" = vga ] && xsrvarg='vga'
    [ "$XServer" = fbdev ] && xsrvarg='fbdev'
    [ "$XServer" = vesa ] && xsrvarg='vesa'
    [ "$XServer" = fbdev -a ! "$fbdev_ok" ] && xsrvarg='vga'

    # use visual PseudoColor on VGA
    [ "$xsrvarg" = vga ] && xpseudo='-cc 3'

    if [ -f /etc/X11/XF86Config ] ; then
      sed -i -e "s#Screen.*Screen\[.*\]#Screen	"\""Screen[$xsrvarg]#" /etc/X11/XF86Config
    fi
  else
    [ -x /usr/X11R6/bin/XF86_VGA16 ] && xsrv=XF86_VGA16
    [ "$fbdev_ok" -a -x /usr/X11R6/bin/XF86_FBDev ] && xsrv=XF86_FBDev
    [ -x /usr/X11R6/bin/XF86_$XServer ] && xsrv=XF86_$XServer
    [ "$xsrv" = XF86_FBDev -a ! "$fbdev_ok" ] && xsrv=XF86_VGA16
    [ "$XServer" = "MACH64" -a -x /usr/X11R6/bin/XF86_Mach64 ] && xsrv=XF86_Mach64
    [ "$XServer" = "3DLABS" -a -x /usr/X11R6/bin/XF86_3DLabs ] && xsrv=XF86_3DLabs
    [ "$XServer" = "SUN24" -a -x /usr/X11R6/bin/Xsun24 ] && xsrv=Xsun24
    [ "$XServer" = "SUN" -a -x /usr/X11R6/bin/Xsun ] && xsrv=Xsun
    [ "$XServer" = "SUNMONO" -a -x /usr/X11R6/bin/XsunMono ] && xsrv=XsunMono

    [ "$xsrv" = XF86_VGA16 ] && xpseudo='-cc 3'
  fi
fi

# only if we have a config file
[ -f /etc/X11/XF86Config ] || xsrv=

log "XVersion=$XVersion"
log "XServer=$XServer"
log "xsrv=$xsrv"
log "screen=$xsrvarg"

# YaST2 module to start
modulename=${1:-installation}
shift
moduleargs=\(\"$*\"\)

if [ "$UseSSH" != 1 ] && [ -z "${DISPLAY/:*}" -o "${DISPLAY/:*/}" == "localhost"  ]; then
    # Use --fullscreen --noborder only for local displays -
    # if $DISPLAY has either nothing or "localhost" before ":"
    y2qt_args="--fullscreen --noborder"
    y2cc_qt_args="--fullscreen --noborder"
fi

# Don't rely on Qt default fonts during installation - display DPI is unreliable
y2qt_args="${y2qt_args} --auto-fonts"



PATH=/var/X11R6/bin:$ybindir:$PATH

#
# if $DISPLAY is set, try to start yast2 there
#

set_inst_qt_env

# set splash progress bar to 100%
[ -f /proc/splash ] && echo "show $((100*65534/100))" >/proc/splash

if [ "$VNC" = "1" ] ; then
    if [ -x /usr/X11R6/bin/Xvnc ] ; then
	. /usr/lib/YaST2/bin/inst_setup_vnc
	export DISPLAY=:1
	/usr/X11R6/bin/fvwm2 -f /usr/X11R6/share/fvwm/fvwmrc.yast2 > /var/log/YaST2/fvwm2.log 2>&1 &
	log "Starting: y2base \"$modulename\" $moduleargs qt $y2qt_args"
	y2base "$modulename" $moduleargs qt $y2qt_args
	y2exitcode=$?
	[ $y2exitcode -eq 0 ] && y2cc_qt
	exit $y2exitcode
    else
	unset DISPLAY
    fi
fi

if [ "$DISPLAY" != "" ] ; then
    log "Starting: y2base \"$modulename\" $moduleargs qt $y2qt_args"
    y2base "$modulename" $moduleargs qt $y2qt_args
    y2exitcode=$?
    [ $y2exitcode -eq 0 ] && y2cc_qt
    exit $y2exitcode
fi

if [ \( ! "$update" \) -a "$Braille" ] ; then
   log "found a braille display"
   sed -e "s#brlname=.*#brlname=$Braille#" -e "s#brlport=.*#brlport=$Brailledevice#" /etc/suse-blinux.conf >/tmp/suse-blinux.conf
   mv -f /tmp/suse-blinux.conf /etc
   /etc/init.d/suse-blinux start
   xsrv=
fi

if [ "$Textmode" = 1 -o "$UseSSH" = 1 ] ; then
  log "text mode requested"
  check_run_fbiterm
  if test "$RUN_FBITERM" = "1" ; then
    (
      /usr/bin/fbiterm y2base "$modulename" $moduleargs ncurses
      y2exitcode=$?
      [ $y2exitcode -eq 0 ] && y2cc_ncurses
      exit $y2exitcode
    )
  else
    (
      y2base "$modulename" $moduleargs ncurses
      y2exitcode=$?
      [ $y2exitcode -eq 0 ] && y2cc_ncurses
      exit $y2exitcode
    )
  fi
  y2exitcode=$?
  exit $y2exitcode
fi

# unset xsrv if qt plugin is not found or some libs are missing
if ! check_qt ; then
    log "qt plugin broken"
    xsrv=
fi

# YaST2 with Qt frontend needs a machine with about 60MB, so check for
# 56MB = 57344 kB (since MemTotal is less than the real memory size).
#
# TODO: on s390 the minimal memory requirements may be lower than
# this, since we have no X Server running locally.
if [ ! "$xsrv" -o "$MemTotal" -lt "90000" ] ; then
    log "no X server or not enough memory: using text mode"
    log "Starting: y2base \"$modulename\" '(\"text_fallback\")' $moduleargs ncurses"
    check_run_fbiterm
    if test "$RUN_FBITERM" = "1" ; then
	(
	    /usr/bin/fbiterm y2base "$modulename" '("text_fallback")' $moduleargs ncurses
	    y2exitcode=$?
	    [ $y2exitcode -eq 0 ] && y2cc_ncurses
	    exit $y2exitcode
	)
    else
	(
	    y2base "$modulename" '("text_fallback")' $moduleargs ncurses
	    y2exitcode=$?
	    [ $y2exitcode -eq 0 ] && y2cc_ncurses
	    exit $y2exitcode
	)
    fi
    y2exitcode=$?
    exit $y2exitcode
fi


server_running=
TESTX=/usr/X11R6/bin/testX
export DISPLAY=:0

if [ "$update" ] ; then
  X -deferglyphs 16 2>/dev/tty8 1>&2 vt07 &
  xserver_pid=$!
  # wait for the X server to come up
  wait_for_x11
else
  if [ "$xsrv" ] ; then
    # try to work around the mode line problem:
    # 1st, we try the 31.5k mode lines only; if this does not
    # work, we use all mode lines
    if [ "$XVersion" = 4 ]; then
      if ! echo $moduleargs | grep -q continue ; then
      if [ -f "/usr/X11R6/bin/xupdate" ];then
         cat /etc/X11/XF86Config | \
             /usr/X11R6/bin/xupdate > /etc/X11/XF86Config.new
         mv /etc/X11/XF86Config.new /etc/X11/XF86Config
      fi
      fi
      sed -e '/[3-6]\. *Try/ d' /etc/X11/XF86Config >/etc/X11/XF86Config_31.5k
      ln -snf /usr/X11R6/bin/$xsrv /var/X11R6/bin/X
      X $xpseudo -xf86config /etc/X11/XF86Config_31.5k -deferglyphs 16 2>/dev/tty8 1>&2 vt07 &
      xserver_pid=$!
      # wait for the X server to come up
      wait_for_x11
    fi

    if [ ! "$server_running" ]; then
      ln -snf /usr/X11R6/bin/$xsrv /var/X11R6/bin/X
      X $xpseudo -deferglyphs 16 2>/dev/tty8 1>&2 vt07 &
      xserver_pid=$!
      # wait for the X server to come up
      wait_for_x11
    fi
  fi
fi

logmeminfo "2"

if [ "$SPLASH" = yes -a -x /sbin/splash -a -n "$SPLASHCFG" ] ; then
  /sbin/splash -t "YaST running"
fi

if [ "$server_running" ] ; then
  log "Starting: y2base \"$modulename\" $moduleargs qt $y2qt_args"
  y2base "$modulename" $moduleargs qt $y2qt_args
  y2exitcode=$?
  [ $y2exitcode -eq 0 ] && y2cc_qt
  clr_inst_qt_env
  sleep 1
  kill $xserver_pid
  # wait for the X server to shut down
  while kill -0 $xserver_pid 2>/dev/null ; do
    sleep 1
  done
else
  log "X server did not start: using text mode"
  test -f /proc/splash && echo verbose > /proc/splash
  (
    log "Starting: y2base \"$modulename\" '("no_x11")' $moduleargs ncurses"
    y2base "$modulename" '("no_x11")' $moduleargs ncurses
    y2exitcode=$?
    [ $y2exitcode -eq 0 ] && y2cc_ncurses
    exit $y2exitcode
  )
  y2exitcode=$?
fi

rm -f /etc/X11/XF86Config_31.5k
[ ! -d /proc/iSeries -a "$HOSTTYPE" != "s390" -a "$HOSTTYPE" != "s390x" ] && chvt 1
log "y2exitcode=$y2exitcode"
exit $y2exitcode
