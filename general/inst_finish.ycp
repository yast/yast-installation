/**
 * * $Id$
 *
 * Module:	inst_finish.ycp
 *
 * Author:	Klaus Kämpf <kkaempf@suse.de>
 *
 * Purpose:	This module finishes the installation, writes
 *		some files (rc_config fstab ... and so on).
 *
 *
 * Writes:
 * [target] /var/lib/YaST2/runme_at_boot	run yast2 after initial boot
 * SCR::Write (.etc.shadow.root,
 */
{
    import "Arch";
    import "Mode";
    import "Installation";
    import "AutoInstall";
    import "Misc";
    import "Language";
    import "Mouse";
    import "Timezone";
    import "Console";
    import "Display";
    import "Keyboard";
    import "Storage";
    import "Packages";
    import "Kernel";
    import "Hotplug";
    import "Product";
    import "Progress";
    import "Report";
    import "StorageDevices";
    import "StorageControllers";
    import "ModulesConf";
    import "Bootloader";
    import "PackageSelectionIO";
    import "Update";
    import "Vendor";
    import "HwStatus";
    import "Directory";

    include "partitioning/partition_defines.ycp";
    textdomain "installation";

    // Help text for last dialog of base installation
    string help_text = _("<p>
Please wait while the base system is being installed.
</p>");

    list progress_stages =
	[
	 // progress stages
	 _("Update configuration"),
	 // progress stages
	 _("Copy files to installed system"),
	 // progress stages
	 _("Install boot manager"),
	 // progress stages
	 _("Prepare system for initial boot")
	 ];

    list progress_descriptions =
	[];


    integer progress_length = 16;

    Progress::New(
		  // Headline for last dialog of base installation: Install LILO etc.
		  _("Finishing Basic Installation"),
		  "",	// Initial progress bar label - not empty (reserve space!)
		  progress_length,	// progress bar length
		  progress_stages,
		  progress_descriptions,
		  help_text );

    // --------------------------------------------------------------
    // do things needed in inst-sys

    // window manager setting
    // default_wm will be used below !

    string default_wm = "kde";

    if ( !Mode::update )
    {
	if (!Pkg::IsProvided ("kdebase3-kdm")
	    && Pkg::IsProvided ("gdm2"))
	{
	    default_wm = "gnome";
	}
	else if (!Pkg::IsSelected ("kdebase3-kdm")
	    && Pkg::IsSelected ("gdm2"))
	{
	    default_wm = "gnome";
	}
    }

    Progress::NextStep();
    // progress stage title
    Progress::Title (_("Configuring system for initial boot."));

    // collect data for linuxrc, will be written to /etc/yast.inf
    map linuxrc = $[];

    // always do hard reboot to ensure that all stuff is initializes
    // correctly. but no reboot message form linuxrc.
    Mode::hardBoot = true;
    linuxrc["Root"] = "reboot";
    linuxrc["RebootMsg"] = "0";

    // Copy pre-install scripts to /var/adm/scripts and logs
    // to /var/adm/inst-log

    if (Mode::autoinst)
    {
	// progress stage title
        Progress::Title (_("Executing postinstall (chroot) scripts"));
        AutoInstall::Finish();
    }

    // copy hardware status to installed system
    SCR::Execute (.target.bash,"/bin/cp -a /var/lib/hardware " + Installation::destdir + "/var/lib");

    // if VNC, copy setup data
    if (Mode::vnc)
    {
	WFM::Execute (.local.bash, "/bin/cp -a /root/.vnc " + Installation::destdir + "/root");
    }

    // Check if X11 package is installed.
    boolean x11_installed = Pkg::IsProvided("XFree86");
    if (!x11_installed)
	x11_installed = Pkg::IsSelected ("XFree86");

    y2milestone ("x11_installed: <%1>", x11_installed );

    // --------------------------------------------------------------
    // Copy /etc/install.inf into built system so that the
    // second phase of the installation can find it.

    SCR::Execute(.target.bash, "/bin/grep -v Sourcemounted /etc/install.inf >" + Installation::destdir + "/etc/install.inf");

    // just for debug so we can see the original install.inf later
    SCR::Execute(.target.bash, "/bin/cp /etc/install.inf "+Installation::destdir+"/var/lib/YaST2");


    // --------------------------------------------------------------
    //   stop SCR
    //   restart on destination

    y2milestone ("Stopping SCR");

    WFM::SCRClose (Installation::scrHandle);


    // --------------------------------------------------------------


    y2milestone ("Re-starting SCR on %1", Installation::destdir);
    Installation::scrHandle = WFM::SCROpen ("chroot="+Installation::destdir+":scr", false);
    WFM::SCRSetDefault (Installation::scrHandle);

    // re-init tmpdir from new SCR !
    Misc::tmpdir = SCR::Read (.target.tmpdir);
    string tmpdir = Misc::tmpdir;

    define InjectFile (string filename)
    ``{
	y2milestone("InjectFile: <%1>", filename );
	WFM::Execute (.local.bash, "/bin/cp " + filename + " " + Installation::destdir + filename);
	return;

	// this just needs too much memory
	//byteblock copy_buffer = WFM::Read (.local.byte, filename);
	//return SCR::Write (.target.byte, filename, copy_buffer);
    }

    // --------------------------------------------------------------
    // Tell new boot scripts to launch yast2, once the
    // new system has done its virgin boot. The Write call
    // creates any missing directory :-).

    if (!SCR::Write (.target.string, "/var/lib/YaST2/runme_at_boot", ""))
    {
	y2error ("Couldn't create target /var/lib/YaST2/runme_at_boot");
    }

    // --------------------------------------------------------------
    // setup linker cache
    // otherwise "SuSEconfig --module fonts" fails

    Progress::NextStep ();
    // progress stage title
    Progress::Title (_("Setting up linker cache"));

    if (SCR::Execute (.target.bash, "/sbin/ldconfig") != 0)
	y2error ("ldconfig failed\n");

    // --------------------------------------------------------------
    // get targets
    // first build map of module names (remove duplicates)
    // then make list of modules as string
    // FIXME: should only include module needed for root-device

    Progress::NextStep ();
    // progress stage title
    Progress::Title (_("Initializing kernel modules..."));

    // now check if we really need reiserfs/jfs and lvm_mod

    list storage_initrdm = Storage::GetRootInitrdModules();

    foreach(`m, storage_initrdm,
    ``{
	Initrd::AddModule (m, "");
    });

    Progress::NextStage();
    // progress stage title
    Progress::Title (_("Configuring CD-ROM devices"));

    // setup ide-scsi
    // !! must be called _after_ Storage::GetRootInitrdModules
    list ide_recorders = StorageDevices::ProbeIDERecorders ();
    Kernel::IDERecorders (ide_recorders);

    // Override linuxrc settings in autoinst mode
    if ( Mode::autoinst )
    {
	linuxrc = AutoInstall::Linuxrc(linuxrc);
    }

    // --------------------------------------------------------------
    // mount the installation image on the target.

    // create mountpoint on target
    Progress::NextStep ();

    if ( !Mode::update )
    {
	// progress stage title
	Progress::Title (_("Creating mount points"));

	SCR::Execute (.target.mkdir, Installation::sourcedir);
    }


    // --------------------------------------------------------------
    // copy /etc/raidtab to target if it was created

    if ( !Mode::update )
    {
	if (Storage::GetRaidtabCreated())
	{
	    InjectFile ("/etc/raidtab");
	}
    }

    // --------------------------------------------------------------
    // Save the state of the hardware modules.

    Progress::NextStep ();
    // progress stage title
    Progress::Title (_("Saving configuration data on target system."));

    Mouse::Save();
    Timezone::Save();
    Language::Save();
    Keyboard::Save(true);
    Display::Save();

    if (Mode::autoinst)
    {
	AutoInstall::Save();
    }

    ModulesConf::Save (false);

    string update_dir = SCR::Read (.etc.install_inf.UpdateDir);
    if (update_dir != nil)
    {
	SCR::Write (.target.string, "/var/lib/YaST2/vendor_update", update_dir);
    }


    if (false)		// FIXME !!!
    {
	SCR::Write (.sysconfig.suseconfig.CWD_IN_USER_PATH, "no");
	SCR::Write (.sysconfig.suseconfig, nil);
    }

    // --------------------------------------------------------------
    // check for Kde vs. Gnome, see inst_xf86config

    Progress::NextStep ();

    if ( !Mode::update )
    {
	// progress stage title
	Progress::Title (_("Initializing default window manager"));

	SCR::Write (.sysconfig.windowmanager.DEFAULT_WM, default_wm);
	SCR::Write (.sysconfig.windowmanager, nil);
    }

    // --------------------------------------------------------------
    // setup fonts

    if (SCR::Read (.target.size, "/sbin/conf.d/SuSEconfig.fonts") != -1)
    {
	// progress stage title
	Progress::Title (_("Initializing fonts"));

	if (SCR::Execute (.target.bash, "/sbin/SuSEconfig --module fonts") != 0)
	    y2error ("SuSEconfig --module fonts failed");
    }

    // --------------------------------------------------------------
    // console and /etc/initab (if serial console)

    Console::Save();

    // --------------------------------------------------------------
    // Write fstab

    Progress::NextStep ();

    if ( Mode::update )
    {
	// re-do all top-level "media" convenience links
	list mediafiles = SCR::Read (.target.dir, ["/media", []]);

	foreach (`mediafile, mediafiles,
	``{
	    mediafile = "/" + mediafile;
	    if (SCR::Read (.target.size, mediafile) < 0)	// not existing
	    {
		SCR::Execute(.target.symlink, "/media"+mediafile, mediafile);
	    }
	});
    }
    else	// install mode
    {
    }

    // Run depmod to update modules.dep

    Progress::NextStep ();

    // progress stage title

    Progress::Title(_("Updating kernel module dependencies"));

    ModulesConf::Save (true);

    if ( !Mode::update )
    {
	// Set default runlevel to 5 if X11 packages are installed
	if ( !Mode::test && Mode::x11_setup_needed && x11_installed )
	{
	    y2milestone ("setting default runlevel to 5");
	    SCR::Write (.etc.inittab.id, "5:initdefault:");
	    SCR::Write (.etc.inittab, nil);
	}
    }
    else
    {
	// Set default runlevel cause inittab will be overwritten by
	// installing aaa_base

	integer last_runlevel = (Update::last_runlevel != -1) ? Update::last_runlevel : 3;

	y2milestone ("setting default runlevel to %1", last_runlevel);
	SCR::Write (.etc.inittab.id, sformat ("%1:initdefault:", last_runlevel));
	SCR::Write (.etc.inittab, nil);

	if (!Arch::ppc
	    && Mode::update)
	{
	    // lilo might need {vmlinuz,initrd}.suse
	    SCR::Execute (.target.remove, "/boot/vmlinuz.suse");
	    SCR::Execute (.target.symlink, "/boot/vmlinuz.shipped", "/boot/vmlinuz.suse");
	    SCR::Execute (.target.remove, "/boot/initrd.suse");
	    SCR::Execute (.target.symlink, "/boot/initrd.shipped", "/boot/initrd.suse");
	}
    }

    // Write list of modules to load after system gets up
    Kernel::SaveModulesToLoad ();

    Progress::NextStage();

    // progress stage title
    Progress::Title(_("Copying configuration files to installed system"));

    // --------------------------------------------------------------
    // Copy /etc/XF86Config into built system so that the
    // second phase of the installation can find it.

    if ( Mode::update )
    {
	// Update mode
	if ( Mouse::mset == "imps/2" )
	{
	    // Patching xf86config for wheel mouses.
	    if (SCR::Execute (.target.bash, Directory::ybindir + "/update_xf86config") != 0)
	    {
		y2error ( "Patch of XF86Config for wheelmouse");
	    }
	    else
	    {
		y2milestone ( "XF86Config has been patched for wheelmouse" );
	    }
	}
    }
    else
    {
	// Installation mode
	// copy XF86Config only if needed
	if ( x11_installed )
	{
	    InjectFile ("/etc/XF86Config");
	    InjectFile ("/etc/X11/XF86Config");

	    if (Mouse::mset != "")
	    {
		// replace with probed type
		SCR::Execute(.target.bash, "/bin/sed -e \"s#PS/2#"+Mouse::mset+"#\" /etc/XF86Config >"+tmpdir+"/XF86Config");
		SCR::Execute(.target.bash, "/bin/mv -f "+tmpdir+"/XF86Config /etc");
		SCR::Execute(.target.bash, "/bin/sed -e \"s#Microsoft#"+Mouse::mset+"#\" /etc/X11/XF86Config >"+tmpdir+"/XF86Config");
		SCR::Execute(.target.bash, "/bin/mv -f "+tmpdir+"/XF86Config /etc/X11");
	    }
	}
    }

    // --------------------------------------------------------------
    // Save http_proxy and ftp_proxy

    if (Mode::initial)
    {
	string proxy = SCR::Read (.etc.install_inf.Proxy);
	string proxyport = SCR::Read (.etc.install_inf.ProxyPort);
	string proxyproto = SCR::Read (.etc.install_inf.ProxyProto);

	if (proxy != nil && proxyport != nil && proxyproto != nil)
	{
	    string fullproxy = proxyproto + "://" + proxy + ":" + proxyport + "/";

	    y2milestone ("setting proxy to %s", fullproxy);

	    // maybe use Proxy module
	    SCR::Write (.sysconfig.proxy.HTTP_PROXY, fullproxy);
	    SCR::Write (.sysconfig.proxy.FTP_PROXY, fullproxy);
	    SCR::Write (.sysconfig.proxy, nil);
	}
    }

    // --------------------------------------------------------------
    // Copy blinux configuration

    if (Mode::braille)
    {
	InjectFile ("/etc/suse-blinux.conf");
    }

    // --------------------------------------------------------------
    // installation source cache

    Pkg::SourceCacheCopyTo (Installation::destdir);

    // disable all sources
    foreach (`src, Packages::theSources,
    ``{
	Pkg::SourceFinish (src);
    });

    Pkg::TargetFinish();

    // --------------------------------------------------------------
    // boot manager configuration

    Progress::NextStage();

    // progress stage title
    Progress::Title (_("Installing boot manager..."));

    SCR::Execute (.target.bash, "/sbin/SuSEconfig --module bootsplash");
    if (Storage::CheckForLvmRootFs() )
    {
	SCR::Execute (.target.bash, "/sbin/vgscan");
    }
//    Boot::Save ();		// save /etc/sysconfig parameters

    // --------------------------------------------------------------
    // driver update ?!

    Vendor::DriverUpdate();

    // --------------------------------------------------------------
    // message after first round of packet installation
    // now the installed system is run and more packages installed
    // just warn the user that the screen is going back to text mode
    // and yast2 will come up again.
    // dont mention this "going back to text mode" here, maybe this
    // wont be necessary in the final version

    // we should tell the user to remove the cd on an SMP or Laptop system
    // where we do a hard reboot. However, the cdrom is still mounted here
    // and cant be removed.

    if (!Mode::live_eval)
    {
	if (Arch::s390)
	{
	    // for s390:
	    // Message that will be displayed along with information
	    // how the boot loader was installed
	    Misc::boot_msg = _("
Your system will now be shut down.
After shutdown, reload the system
with the load address of your root DASD.
");
	}
	else
	{
	    // Final message after all packages from CD1 are installed
	    // and we're ready to start (boot into) the installed system
	    // Message that will be displayed along with information
	    // how the boot loader was installed
	    Misc::boot_msg = _("Now booting your system...");
	}
    }

    //-------------------------------------------------------------
    // write boot information for linuxrc

    linuxrc["Language"] = Language::language;
    linuxrc["Keytable"] = Keyboard::keymap;

    Misc::WriteYaSTInf (linuxrc);

    //--------------------------------------------------------------
    // Install bootloader (always, see #23018)
    // should also set Misc::boot_msg appropriate
    Bootloader::Write ();

    // --------------------------------------------------------------
    // write network settings to installed system

    if (Arch::s390 || Mode::vnc || Mode::usessh)
    {
	WFM::Execute (.local.bash, "/sbin/create_interface " + Installation::destdir);
	ModulesConf::RunDepmod (false);
    }

    // --------------------------------------------------------------
    // copy the root password for root user from inst-sys to the installed system
    // copy the ssh files to the fresh installed system

    if (!Mode::update && Mode::usessh)
    {
	WFM::Execute (.local.bash, "umask 077 ; awk  -F : ' /^root:/ { print $1\":\"$2 }' < /etc/shadow > "
		+ Installation::destdir + "/tmp/rootpwd.txt");
	SCR::Execute (.target.bash, "/bin/cat /tmp/rootpwd.txt | /usr/sbin/chpasswd -e ; rm -fv /tmp/rootpwd.txt");
    	WFM::Execute (.local.bash, "/bin/cp -a /etc/ssh/*key* " + Installation::destdir + "/etc/ssh/");
    }

    // --------------------------------------------------------------
    // write final hardware status, ** must be last **

    if (Mode::update)
    {
	// ensure "no" status for all pci and isapnp devices
	HwStatus::Update();
    }

    // write "yes" status for known devices (mouse, keyboard, storage, etc.)
    HwStatus::Save();

    // --------------------------------------------------------------
    // Check if there is a message left to display
    // and display it, if necessary

    if (size (Misc::boot_msg) > 0 && !Mode::autoinst)
    {
	Report::DisplayMessages (true, 10);
	Report::Message (Misc::boot_msg);
	Misc::boot_msg = "";
    }

    // --------------------------------------------------------------
    // Copy YaST2 log files into installed system

    Progress::NextStage();
    // progress stage title
    Progress::Title(_("Copying log files to installed system"));

    integer log_num = 4;	// maximum number of rotated logs
    while (log_num >= 0)
    {
	string log_add = (log_num == 0) ? "" : ("-" + log_num);

	log_add = "/var/log/YaST2/y2log" + log_add;

	if (WFM::Read (.local.size, log_add) > 0)
	{
	    WFM::Execute (.local.bash, "/bin/cp " + log_add + " " + Installation::destdir + "/var/log/YaST2/y2log-" + (log_num+1));

	    // this just needs too much memory
	    // string logbuf = WFM::Read (.local.string, log_add);
	    // SCR::Write (.target.string, "/var/log/YaST2/y2log-" + (log_num+1), logbuf);

	    y2milestone ("Copied %1 to target", log_add);
	}
	else
	{
	    y2milestone ("Skipping non-existant log %1", log_add);
	}
	log_num = log_num - 1;
    }

    // copy y2start.log
    SCR::Write (.target.string, "/var/log/YaST2/y2start.log-initial", WFM::Read (.local.string, ["/var/log/YaST2/y2start.log", ""]));


    // --------------------------------------------------------------

    if (WFM::Read (.local.size, "/usr/share/YaST2/clients/product_finish.ycp") > 0)
	WFM::CallFunction (product_finish(Mode::update));

    // --------------------------------------------------------------
    // Unmount all mounted devices (from inst_prepdisk)

    Progress::NextStep();
    // progress stage title
    Progress::Title(_("Unmounting all mounted devices"));

    // loop over all filesystems

    map mountPoints = Storage::GetMountPoints();
    list umountList = [];

    // go through mountPoints collecting paths in umountList
    // *** umountList is lexically ordered !

    foreach (`mountpoint,`mountval,mountPoints,
    ``{
	if (mountpoint != "swap")		// dont umount / on target
	{
	    umountList = add (umountList, mountpoint);
	}
    });

    // now unmount all mountpoints in reverse order !

    // remove [Installation::destdir]/etc/mtab which was faked for %post
    // scripts in inst_rpmcopy
    SCR::Execute(.target.remove, "/etc/mtab");

    // Stop SCR on target
    WFM::SCRClose (Installation::scrHandle);

    if (!Mode::live_eval)
    {
	// first, umount everthing mounted *in* the target.
	// /proc/bus/usb
	// /proc
	// /boot

	if (Hotplug::haveUSB)
	{
	    WFM::Execute(.local.umount, Installation::destdir + "/proc/bus/usb");
	}
	WFM::Execute(.local.umount, Installation::destdir + "/proc");

	// *** umountList is lexically ordered !
	// now umount in reverse order (guarantees "/" as last umount)

	integer umountLength = size (umountList);
	while (umountLength > 0)
	{
	    umountLength = umountLength - 1;
	    WFM::Execute(.local.umount, Installation::destdir + select (umountList, umountLength, ""));
	    y2milestone( "umount target: %1", select (umountList, umountLength, "")) ;
	}

	// disable loop device of crypto fs
	integer max_loop_dev = Storage::NumLoopDevices();
	boolean unload_crypto = false;

	while (max_loop_dev > 0)
	{
	    unload_crypto   = true;
	    string exec_str = sformat( "/sbin/losetup -d /dev/loop%1", max_loop_dev-1 );
	    y2milestone( "loopdev: %1", exec_str);
	    WFM::Execute(.local.bash, exec_str);
	    max_loop_dev = max_loop_dev -1;
	}

	map targetMap = Storage::GetTargetMap();
	if( size(filter(`k,`v, targetMap, ``(lookup (v, "is_lvm_vg", false)))) >0 )
	{
	    y2milestone( "shutting down LVM" );
	    WFM::Execute(.local.bash, "/sbin/vgchange -A n -a n" );
	    WFM::Execute(.local.bash, "/bin/umount /etc/lvmtab.d" );
	}

	// does not work in 7.2
	// boot.crypto fails to load module
	// so we leave it loaded
	// if ( unload_crypto ) WFM::Execute(.local.bash, "/sbin/rmmod loop_fish2");

    }

    Progress::Finish();

    return `next;
}
