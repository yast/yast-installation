/**
 * File:	clients/inst_finish.ycp
 * Package:	installation
 * Summary:	Finish installation
 * Authors:	Klaus KÃ¤mpf <kkaempf@suse.de>
 *		Arvin Schnell <arvin@suse.de>
 *
 * $Id$
 *
 * Writes:
 * [target] /var/lib/YaST2/runme_at_boot	run yast2 after initial boot
 * SCR::Write (.etc.shadow.root,
 */

{
    textdomain "installation";

    import "Arch";
    import "AutoInstall";
    import "AutoinstScripts";
    import "AutoinstConfig";
    import "Bootloader";
    import "Console";
    import "Directory";
    import "Display";
    import "FileSystems";
    import "Hotplug";
    import "HwStatus";
    import "Initrd";
    import "Installation";
    import "Kernel";
    import "Keyboard";
    import "Language";
    import "Misc";
    import "Mode";
    import "ModulesConf";
    import "Mouse";
    import "PackageSelectionIO";
    import "Packages";
    import "Product";
    import "ProductControl";
    import "Progress";
    import "Report";
    import "RunlevelEd";
    import "Storage";
    import "StorageControllers";
    import "StorageDevices";
    import "Timezone";
    import "Update";
    import "Vendor";
    import "X11Version";

    include "partitioning/partition_defines.ycp";


    define void set_runlevel (integer runlevel) ``{
	y2milestone ("setting default runlevel to %1", runlevel);
	SCR::Write (.etc.inittab.id, sformat ("%1:initdefault:", runlevel));
	SCR::Write (.etc.inittab, nil);
    }


    // Help text for last dialog of base installation
    string help_text = _("<p>
Please wait while the base system is being installed.
</p>");

    list<string> progress_stages =
	[
	 // progress stages
	 _("Update configuration"),
	 // progress stages
	 _("Copy files to installed system"),
	 // progress stages
	 _("Install boot manager"),
	 // progress stages
	 _("Prepare system for initial boot")
	 ];

    list progress_descriptions =
	[];

    if ( Mode::live_eval )
    {
	// no boot manager config
	progress_stages = remove(progress_stages, 2);
    }

    integer progress_length = 16;


    Progress::New(
		  // Headline for last dialog of base installation: Install LILO etc.
		  _("Finishing Basic Installation"),
		  "",	// Initial progress bar label - not empty (reserve space!)
		  progress_length,	// progress bar length
		  progress_stages,
		  progress_descriptions,
		  help_text );

    // --------------------------------------------------------------
    // do things needed in inst-sys

    // window manager setting
    // default_wm will be used below !
    // display manager setting
    // default_dm will be used below !

    string default_wm = "kde";
    string default_dm = "kdm";
    string doc_server = "";

    if ( !Mode::update )
    {
	if ((!(Pkg::IsProvided ("kdebase3-kdm")		// if kdm isn't installed yet
	       || Pkg::IsSelected ("kdebase3-kdm")))	//   or earmarked for installation
	   &&						// and
	      (Pkg::IsProvided ("gdm2")			//  gdm2 is installed
		|| Pkg::IsSelected ("gdm2")))		//    or earmarked for installation
	{
	    default_wm = "gnome";			// then we switch to gdm/gnome
	    default_dm = "gdm";
	}

	// check who provides suse_help_viewer
	// if kdebase3-SuSE isn't installed by apache or apache2, set /etc/sysconfig/apache:DOC_SERVER

	if ((!(Pkg::IsProvided ("kdebase3-SuSE") || Pkg::IsSelected ("kdebase3-SuSE")))
	   &&
	      (Pkg::IsProvided ("apache2") || Pkg::IsSelected ("apache2")
	       || Pkg::IsProvided ("apache") || Pkg::IsSelected ("apache")))
	{
	    doc_server = "yes";
	}

    }

    Progress::NextStep();
    // progress stage title
    Progress::Title (_("Configuring system for initial boot."));

    // collect data for linuxrc, will be written to /etc/yast.inf
    map<string,string> linuxrc = $[];

    // always do hard reboot to ensure that all stuff is initializes
    // correctly. but no reboot message form linuxrc.
    linuxrc["Root"] = "reboot";
    linuxrc["RebootMsg"] = "0";

    // Copy pre-install scripts to /var/adm/scripts and logs
    // to /var/adm/inst-log

    if (Mode::autoinst)
    {
	// progress stage title
        Progress::Title (_("Executing auto-install scripts in the installation environment."));
        AutoinstScripts::Write("chroot-scripts", false);
        AutoInstall::Finish(Installation::destdir);
    }

    // copy hardware status to installed system
    SCR::Execute (.target.bash,"/bin/cp -a /var/lib/hardware " + Installation::destdir + "/var/lib");

    // if VNC, copy setup data
    if (Mode::vnc)
    {
	WFM::Execute (.local.bash, "/bin/cp -a /root/.vnc " + Installation::destdir + "/root");
    }

    // Check if X11 package is installed.
    boolean x11_installed = Pkg::IsProvided("XFree86");
    if (!x11_installed)
	x11_installed = Pkg::IsSelected ("XFree86");

    y2milestone ("x11_installed: <%1>", x11_installed );

    // --------------------------------------------------------------
    // Copy /etc/install.inf into built system so that the
    // second phase of the installation can find it.

    if ( !Mode::live_eval )
    {
        SCR::Execute (.target.bash, "/bin/grep -v Sourcemounted /etc/install.inf >" +
		      Installation::destdir + "/etc/install.inf");
    }

    // just for debug so we can see the original install.inf later
    SCR::Execute (.target.bash, "/bin/cp /etc/install.inf " +
		  Installation::destdir + "/var/lib/YaST2/install.inf");
    SCR::Execute (.target.bash, "/bin/chmod 0600 " +
		  Installation::destdir + "/var/lib/YaST2/install.inf");

    // Copy control.xml so it can be read once again during continue mode
    SCR::Execute (.target.bash, "/bin/cp " + ProductControl::current_control_file  + " " +
		  Installation::destdir + "/var/lib/YaST2/control.xml");
    SCR::Execute (.target.bash, "/bin/chmod 0600 " +
		  Installation::destdir + "/var/lib/YaST2/control.xml");

    if ( !Mode::live_eval )
    {
        // --------------------------------------------------------------
        //   stop SCR
        //   restart on destination
        //   _Not_ in live_eval mode!

        y2milestone ("Stopping SCR");

        WFM::SCRClose (Installation::scr_handle);


    // --------------------------------------------------------------


	y2milestone ("Re-starting SCR on %1", Installation::destdir);
	Installation::scr_handle = WFM::SCROpen ("chroot="+Installation::destdir+":scr", false);
	Installation::scr_destdir = "/";
	WFM::SCRSetDefault (Installation::scr_handle);
    }

    // re-init tmpdir from new SCR !
    Directory::ResetTmpDir();
    string tmpdir = Directory::tmpdir;

    define void InjectFile (string filename)
    ``{
	y2milestone("InjectFile: <%1>", filename );
	WFM::Execute (.local.bash, "/bin/cp " + filename + " " + Installation::destdir + filename);
	return;

	// this just needs too much memory
	//byteblock copy_buffer = WFM::Read (.local.byte, filename);
	//return SCR::Write (.target.byte, filename, copy_buffer);
    }

    // --------------------------------------------------------------
    // Tell new boot scripts to launch yast2, once the
    // new system has done its virgin boot. The Write call
    // creates any missing directory :-).

    if (!SCR::Write (.target.string, "/var/lib/YaST2/runme_at_boot", ""))
    {
	y2error ("Couldn't create target /var/lib/YaST2/runme_at_boot");
    }

    // --------------------------------------------------------------
    // setup linker cache
    // otherwise "SuSEconfig --module fonts" fails

    if ( !Mode::live_eval )
    {
	Progress::NextStep ();
	// progress stage title
	Progress::Title (_("Setting up linker cache"));

	if (SCR::Execute (.target.bash, "/sbin/ldconfig") != 0)
	    y2error ("ldconfig failed\n");
    }

    // --------------------------------------------------------------
    // get targets
    // first build map of module names (remove duplicates)
    // then make list of modules as string
    // FIXME: should only include module needed for root-device

    Progress::NextStep ();
    // progress stage title
    Progress::Title (_("Initializing kernel modules..."));

    // now check if we really need reiserfs/jfs and lvm_mod

    list<string> storage_initrdm = (list<string>)Storage::GetRootInitrdModules();

    foreach(string m, storage_initrdm,
    ``{
	Initrd::AddModule (m, "");
    });

    Progress::NextStage();
    // progress stage title
    Progress::Title (_("Configuring CD-ROM devices"));

    // Override linuxrc settings in autoinst mode
    if ( Mode::autoinst )
    {
        if (AutoinstConfig::ForceBoot)
        {
	    linuxrc["Root"] = Bootloader::getRootDevice ();
        }
    }

    // --------------------------------------------------------------
    // mount the installation image on the target.

    // create mountpoint on target
    Progress::NextStep ();

    if ( !Mode::update )
    {
	// progress stage title
	Progress::Title (_("Creating mount points"));

	SCR::Execute (.target.mkdir, Installation::sourcedir);
    }


    // --------------------------------------------------------------
    // copy /etc/raidtab to target if it was created

    if ( !Mode::update )
    {
	if (Storage::GetRaidtabCreated())
	{
	    InjectFile ("/etc/raidtab");
	}
    }

    // --------------------------------------------------------------
    // Save the state of the hardware modules.

    Progress::NextStep ();
    // progress stage title
    Progress::Title (_("Saving configuration data on target system."));

    Mouse::Save();
    Timezone::Save();
    Language::Save();
    Keyboard::Save(true);
    Display::Save();

    if (Mode::autoinst)
    {
	AutoInstall::Save();
    }

    ModulesConf::Save (false);

    string update_dir = (string) SCR::Read (.etc.install_inf.UpdateDir);
    if (update_dir != nil)
    {
	SCR::Write (.target.string, "/var/lib/YaST2/vendor_update", update_dir);
    }


    SCR::Write (.sysconfig.suseconfig.CWD_IN_USER_PATH,
		contains (Product::flags, "usercwd") ? "yes" : "no");
    SCR::Write (.sysconfig.suseconfig, nil);

    // --------------------------------------------------------------
    // check for Kde vs. Gnome, see inst_xf86config

    Progress::NextStep ();

    if ( !Mode::update )
    {
	// progress stage title
	Progress::Title (_("Initializing default window manager"));

	SCR::Write (.sysconfig.windowmanager.DEFAULT_WM, default_wm);
	SCR::Write (.sysconfig.windowmanager, nil);
	SCR::Write (.sysconfig.displaymanager.DISPLAYMANAGER, default_dm);
	SCR::Write (.sysconfig.displaymanager, nil);

	if (doc_server == "yes")
	{
	    SCR::Write (.sysconfig.apache.DOC_SERVER, doc_server);
	    SCR::Write (.sysconfig.apache, nil);
	}
    }

    // --------------------------------------------------------------
    // setup fonts

    if (SCR::Read (.target.size, "/sbin/conf.d/SuSEconfig.fonts") != -1)
    {
	// progress stage title
	Progress::Title (_("Initializing fonts"));

	if (SCR::Execute (.target.bash, "/sbin/SuSEconfig --module fonts") != 0)
	    y2error ("SuSEconfig --module fonts failed");
    }

    // --------------------------------------------------------------
    // console and /etc/initab (if serial console)

    Console::Save();

    // --------------------------------------------------------------
    // Write fstab

    Progress::NextStep ();

    if ( Mode::update )
    {
	// re-do all top-level "media" convenience links
	list<string> mediafiles = (list<string>) SCR::Read (.target.dir, ["/media", []]);

	foreach (string mediafile, mediafiles,
	``{
	    mediafile = "/" + mediafile;
	    if (SCR::Read (.target.size, mediafile) < 0)	// not existing
	    {
		SCR::Execute(.target.symlink, "/media"+mediafile, mediafile);
	    }
	});

	Storage::Update (Update::installedVersion, Update::updateVersion);
    }
    else	// install mode
    {
    }

    // Run depmod to update modules.dep

    Progress::NextStep ();

    // progress stage title

    Progress::Title(_("Updating kernel module dependencies"));

    ModulesConf::Save (true);

    if ( !Mode::update )
    {
	// see bug #32366 why we need this here
	// and 30028
	// now it is set in the initial proposal
	// Fall back to 3 if we accidentally don't set it there
	// otherwise it would be 0 (#35662)
	set_runlevel (RunlevelEd::default == ""?
		      3 : tointeger (RunlevelEd::default));
    }
    else if ( Mode::update )
    {
	// Set default runlevel cause inittab will be overwritten by
	// installing aaa_base

	set_runlevel (Update::last_runlevel != -1 ? Update::last_runlevel : 3);

	if (!Arch::ppc
	    && Mode::update)
	{
	    // lilo might need {vmlinuz,initrd}.suse
	    SCR::Execute (.target.remove, "/boot/vmlinuz.suse");
	    SCR::Execute (.target.symlink, "/boot/vmlinuz.shipped", "/boot/vmlinuz.suse");
	    SCR::Execute (.target.remove, "/boot/initrd.suse");
	    SCR::Execute (.target.symlink, "/boot/initrd.shipped", "/boot/initrd.suse");
	}

	// remove old junk from GNOME, script is in yast2-update
	// will be run in just updated system
	SCR::Execute (.target.bash, Directory::ybindir + "/gnome-postinstall");
    }

    // Write list of modules to load after system gets up
    Kernel::SaveModulesToLoad ();

    Progress::NextStage();

    // progress stage title
    Progress::Title(_("Copying configuration files to installed system"));

    // --------------------------------------------------------------
    // Copy /etc/XF86Config into built system so that the
    // second phase of the installation can find it.
    X11Version::GetX11Link();

    if (x11_installed)
    {
	if ( Mode::update )
	{
	    if (X11Version::versionLink == "3")
	    {
		//========================================
		// Update mode...
		//----------------------------------------
		// - set a flag at the end of the config to indicate later migration
		// - copy the config to the installed system
		y2milestone ("Update: XFree86 version 3 detected");
		string filename = "/etc/XF86Config";
		WFM::Execute (.local.bash,
			  "echo -e '\n#3x' >> " + filename
			  );
		SCR::Execute (.target.bash,"/bin/ln -sf " +
			  Installation::destdir + "/usr/X11R6/bin/XFree86 " +
			  Installation::destdir + "/var/X11R6/bin/X"
			  );
		y2milestone ("Update: Include X11 config [3.x] to installed system");
		y2milestone ("Update: X11 config [3.x] prepared for migration to [4.x]");
		InjectFile ( filename );
	    }
	}
	else
	{
	    //========================================
	    // Installation mode...
	    //----------------------------------------
	    y2milestone ("Include X11 config [instsys] to installed system");
	    string filename = "/etc/X11/XF86Config";
	    InjectFile (filename);
	}

	// ... /
	// make current X11 configuration available in installed or updated system
	// copy /etc/X11/XF86Config from inst-sys to [/mnt]/etc/X11/XF86Config.install
	// ---
	y2milestone ("Include X11 config [instsys] to installed system: XF86Config.install");
	string filename = "/etc/X11/XF86Config";
	WFM::Execute (.local.bash, "/bin/cp " + filename + " " +
		      Installation::destdir + filename + ".install");
    }

    // --------------------------------------------------------------
    // Save http_proxy and ftp_proxy

    if (Mode::initial)
    {
	string proxy = (string) SCR::Read (.etc.install_inf.Proxy);
	string proxyport = (string) SCR::Read (.etc.install_inf.ProxyPort);
	string proxyproto = (string) SCR::Read (.etc.install_inf.ProxyProto);

	if (proxy != nil && proxyport != nil && proxyproto != nil)
	{
	    string fullproxy = proxyproto + "://" + proxy + ":" + proxyport + "/";

	    y2milestone ("setting proxy to %s", fullproxy);

	    // maybe use Proxy module
	    SCR::Write (.sysconfig.proxy.HTTP_PROXY, fullproxy);
	    SCR::Write (.sysconfig.proxy.FTP_PROXY, fullproxy);
	    SCR::Write (.sysconfig.proxy, nil);
	}
    }

    // --------------------------------------------------------------
    // Copy blinux configuration

    if (Mode::braille)
    {
	InjectFile ("/etc/suse-blinux.conf");
    }

    // --------------------------------------------------------------
    // installation source cache

    Pkg::SourceCacheCopyTo (Installation::destdir);

    // disable all sources and finish target
    Pkg::SourceFinishAll ();
    Pkg::TargetFinish();

    // --------------------------------------------------------------
    // boot manager configuration

    if ( !Mode::live_eval )
    {
	Progress::NextStage();

	// progress stage title
	Progress::Title (_("Installing boot manager..."));

	SCR::Execute (.target.bash, "/sbin/SuSEconfig --module bootsplash");
	if (Storage::CheckForLvmRootFs() )
	{
	    SCR::Execute (.target.bash, "/sbin/vgscan");
	}
	//    Boot::Save ();		// save /etc/sysconfig parameters

	// --------------------------------------------------------------
	// driver update ?!

	Vendor::DriverUpdate();
    }

    // --------------------------------------------------------------
    // message after first round of packet installation
    // now the installed system is run and more packages installed
    // just warn the user that the screen is going back to text mode
    // and yast2 will come up again.
    // dont mention this "going back to text mode" here, maybe this
    // wont be necessary in the final version

    // we should tell the user to remove the cd on an SMP or Laptop system
    // where we do a hard reboot. However, the cdrom is still mounted here
    // and cant be removed.

    if (!Mode::live_eval)
    {
	if (Arch::s390)
	{
	    // for s390:
	    // Message that will be displayed along with information
	    // how the boot loader was installed
	    Misc::boot_msg = _("
Your system will now be shut down.
After shutdown, reload the system
with the load address of your root DASD.
");
	}
	else
	{
	    // Final message after all packages from CD1 are installed
	    // and we're ready to start (boot into) the installed system
	    // Message that will be displayed along with information
	    // how the boot loader was installed
	    Misc::boot_msg = _("Now booting your system...");
	}
    }

    //-------------------------------------------------------------
    // write boot information for linuxrc

    linuxrc["Language"] = Language::language;
    linuxrc["Keytable"] = Keyboard::keymap;

    Misc::WriteYaSTInf (linuxrc);

    //--------------------------------------------------------------
    // Install bootloader (always, see #23018)
    // should also set Misc::boot_msg appropriate
    if ( !Mode::live_eval )
    {
	Bootloader::Write ();
    }

    // --------------------------------------------------------------
    // write network settings to installed system

    if (Arch::s390 || Mode::vnc || Mode::usessh)
    {
	y2milestone("Creating network interface");
	WFM::Execute (.local.bash, "/sbin/create_interface " + Installation::destdir);
	ModulesConf::RunDepmod (false);
    }

    // --------------------------------------------------------------
    // copy the root password for root user from inst-sys to the installed system
    // copy the ssh files to the fresh installed system

    if (!Mode::update && Mode::usessh)
    {
	WFM::Execute (.local.bash, "umask 077 ; awk  -F : ' /^root:/ { print $1\":\"$2 }' < /etc/shadow > "
		+ Installation::destdir + "/tmp/rootpwd.txt");
	SCR::Execute (.target.bash, "/bin/cat /tmp/rootpwd.txt | /usr/sbin/chpasswd -e ; rm -fv /tmp/rootpwd.txt");
	WFM::Execute (.local.bash, "/bin/cp -a /etc/ssh/*key* " + Installation::destdir + "/etc/ssh/");
    }

    // --------------------------------------------------------------
    // write final hardware status, ** must be last **

    if (Mode::update)
    {
	// ensure "no" status for all pci and isapnp devices
	HwStatus::Update();
    }

    // write "yes" status for known devices (mouse, keyboard, storage, etc.)
    HwStatus::Save();

    // --------------------------------------------------------------
    // Check if there is a message left to display
    // and display it, if necessary

    if (size (Misc::boot_msg) > 0 && !Mode::autoinst)
    {
	Report::DisplayMessages (true, 10);
	Report::Message (Misc::boot_msg);
	Misc::boot_msg = "";
    }


    if (Mode::autoinst)
    {
        AutoinstScripts::Write("chroot-scripts", true);
    }


    // --------------------------------------------------------------
    // Copy YaST2 log files into installed system

    Progress::NextStage();
    // progress stage title
    Progress::Title(_("Copying log files to installed system"));

    integer log_num = 4;	// maximum number of rotated logs
    while (log_num >= 0)
    {
	string log_add = (log_num == 0) ? "" : ("-" + log_num);

	log_add = "/var/log/YaST2/y2log" + log_add;

	if (WFM::Read (.local.size, log_add) > 0)
	{
	    WFM::Execute (.local.bash, "/bin/cp " + log_add + " " + Installation::destdir + "/var/log/YaST2/y2log-" + (log_num+1));

	    // this just needs too much memory
	    // string logbuf = WFM::Read (.local.string, log_add);
	    // SCR::Write (.target.string, "/var/log/YaST2/y2log-" + (log_num+1), logbuf);

	    y2milestone ("Copied %1 to target", log_add);
	}
	else
	{
	    y2milestone ("Skipping non-existant log %1", log_add);
	}
	log_num = log_num - 1;
    }
    if (size(ProductControl::logfiles)>0)
    {
        y2milestone("Writing hook logs into system: %1",
                ProductControl::logfiles);
        foreach(string logfile, ProductControl::logfiles, ``{
                string fulllogfile = "/var/log/YaST2/" + logfile;
                if (WFM::Read (.local.size, fulllogfile) > 0)
                {
                    WFM::Execute (.local.bash, "/bin/cp " + fulllogfile + " " +
                    Installation::destdir + "/var/log/YaST2/" + logfile);
                }
                });
    }

    // copy y2start.log
    SCR::Write (.target.string, "/var/log/YaST2/y2start.log-initial", WFM::Read (.local.string, ["/var/log/YaST2/y2start.log", ""]));
    // copy badlist
    SCR::Write (.target.string, "/var/log/YaST2/badlist-initial", WFM::Read (.local.string, ["/var/log/YaST2/badlist", ""]));


    // --------------------------------------------------------------

    if (WFM::Read (.local.size, "/usr/share/YaST2/clients/product_finish.ycp") > 0)
	WFM::CallFunction ("product_finish", [Mode::update]);

    // --------------------------------------------------------------
    // Unmount all mounted devices (from inst_prepdisk)

    Progress::NextStep();
    // progress stage title
    Progress::Title(_("Unmounting all mounted devices"));

    // loop over all filesystems

    map<string,list> mountPoints = (map<string,list>)Storage::GetMountPoints();
    list<string> umountList = [];

    // go through mountPoints collecting paths in umountList
    // *** umountList is lexically ordered !

    foreach (string mountpoint, list mountval, mountPoints,
    ``{
	if (mountpoint != "swap")		// dont umount / on target
	{
	    umountList = add (umountList, mountpoint);
	}
    });

    // now unmount all mountpoints in reverse order !

    // remove [Installation::destdir]/etc/mtab which was faked for %post
    // scripts in inst_rpmcopy
    SCR::Execute(.target.remove, "/etc/mtab");

    if (!Mode::live_eval)
    {
	// Stop SCR on target
	WFM::SCRClose (Installation::scr_handle);

	// first, umount everthing mounted *in* the target.
	// /proc/bus/usb
	// /proc

	if (Hotplug::haveUSB)
	{
	    WFM::Execute(.local.umount, Installation::destdir + "/proc/bus/usb");
	}
	WFM::Execute(.local.umount, Installation::destdir + "/proc");

	map<string,map> targetMap = Storage::GetTargetMap();

	// first umount all file based crypto fs since they potentially
	// could mess up umounting of normale filesystems if the crypt
	// file is not on the root fs
	y2milestone( "umount list %1", umountList );
	foreach( map e,  targetMap["/dev/loop","partitions"]:[],
	    ``{
	    if( size(e["mount"]:"")>0 )
		{
		WFM::Execute( .local.umount,
		              Installation::destdir + e["mount"]:"" );
		umountList = filter (string m, umountList, ``(m!=e["mount"]:""));
		y2milestone( "loop umount %1 new list %2", e["mount"]:"",
		             umountList );
		}
	    if( size(e["loop_dev"]:"")>0 )
		{
		string cmd = "/sbin/losetup -d " + e["loop_dev"]:"";
		y2milestone( "cmd %1", cmd );
		WFM::Execute( .local.bash, cmd );
		}
	    });

	// *** umountList is lexically ordered !
	// now umount in reverse order (guarantees "/" as last umount)

	integer umountLength = size (umountList);
	while (umountLength > 0)
	{
	    umountLength = umountLength - 1;
	    string tmp = Installation::destdir + (string) (umountList[umountLength]:"");
	    y2milestone("umount target: %1", tmp);
	    WFM::Execute(.local.umount, tmp);
	}

	// disable loop device of crypto fs
	integer max_loop_dev = Storage::NumLoopDevices();
	boolean unload_crypto = false;

	while (max_loop_dev > 0)
	{
	    unload_crypto   = true;
	    string exec_str = sformat( "/sbin/losetup -d /dev/loop%1", max_loop_dev-1 );
	    y2milestone( "loopdev: %1", exec_str);
	    WFM::Execute(.local.bash, exec_str);
	    max_loop_dev = max_loop_dev -1;
	}

	if( size(filter(string k, map v, targetMap, ``(v["is_lvm_vg"]:false))) >0 )
	{
	    y2milestone( "shutting down LVM" );
	    WFM::Execute(.local.bash, "/sbin/vgchange -A n -a n" );
	    WFM::Execute(.local.bash, "/bin/umount /etc/lvmtab.d" );
	}

	// does not work in 7.2
	// boot.crypto fails to load module
	// so we leave it loaded
	// if ( unload_crypto ) WFM::Execute(.local.bash, "/sbin/rmmod loop_fish2");

    }

    Progress::Finish();

    if (UI::PollInput () == `abort && Popup::ConfirmAbort (`incomplete))
        return `abort;

    return `next;
}
