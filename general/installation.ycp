/**
 * Module:		installation.ycp
 *
 * Authors:		Klaus Kaempf <kkaempf@suse.de>
 *			Mathias Kettner <kettner@suse.de>
 *			Michael Hager <mike@suse.de>
 *			Stefan Hundhammer <sh@suse.de>
 *			Arvin Schnell <arvin@suse.de>
 *
 * Purpose:		Set up the UI and define macros for the
 *			installation dialog, general framework, ...
 *			Describing and calling all submodules, depending on
 *			the installation should be started or continued.
 *
 * $Id$
 */
{
    textdomain "installation";

    // this is installation, so start SCR always locally (as plugin) !

    integer scrHandle = WFM::SCROpen ("scr", false);
    WFM::SCRSetDefault (scrHandle);

    import "Arch";
    import "Mode";
    import "Installation";
    import "Language";
    import "Storage";
    Installation::scrHandle = scrHandle;

    import "AutoInstall";
    import "Mouse";
    import "Console";
    import "StorageDevices";
    import "Misc";
    import "Keyboard";
    import "Packages";

    import "Wizard";
    import "Label";
    import "Popup";
    import "Report";
    import "Hooks";
    import "ProductControl";

    import "FileSystems";

    include "partitioning/partition_defines.ycp";

    // ==================================================================================


    /**
     * Re-translate static part of wizard dialog and other predefined messages
     * after language change
     */
    define void retranslateWizardDialog() ``{

	y2debug( "Retranslating messages" );

	// Make sure the labels for default function keys are retranslated, too.
	// Using Label::DefaultFunctionKeyMap() from Label module.
	UI::SetFunctionKeys( Label::DefaultFunctionKeyMap() );

	// Activate language changes on static part of wizard dialog

	Wizard::RetranslateButtons();
	Wizard::SetFocusToNextButton();

    }

    // ==================================================================================


    // properly set up initial language

    if (Mode::initial)
    {
	Pkg::InstSysMode();

	// --------------------------------------------------------------
	//                   Mouse
	// --------------------------------------------------------------
	if (!Arch::s390 || Arch::board_iseries)
	{
	    y2milestone("Call Mouse probing...");
	    if (!Mouse::Found())
	    {
		// ...
		// Let the USB modules settle for a while.
		// Mouse probing may fail otherwise...
		//
		SCR::Execute(.target.bash, "/bin/sleep 4");
		if ( Mode::x11_setup_needed && !Mode::text ) {
		    SCR::Execute (.target.bash, "/usr/X11R6/bin/xmset --disable");
		}
		Mouse::Set (Mouse::Probe ());
		if ( Mode::x11_setup_needed && !Mode::text ) {
		    SCR::Execute (.target.bash, "/usr/X11R6/bin/xmset --enable");
		}
	    }
	}

	Installation::encoding = Console::SelectFont( Language::language );

	if (lookup (UI::GetDisplayInfo(), "HasFullUtf8Support", true))
	{
	    Installation::encoding = "UTF-8";
	}

	UI::SetLanguage (Language::language, Installation::encoding);
	WFM::SetLanguage (Language::language, "UTF-8");

	if (WFM::Read (.local.size, "/usr/share/YaST2/clients/product_initial.ycp") > 0)
	    WFM::CallFunction ("product_initial", []);
    }

    // Properly setup timezone for continue mode.
    //
    if ( Mode::cont )
    {
	import "Timezone";
	Timezone::Set( Timezone::timezone, true );

	if (WFM::Read (.local.size, "/usr/share/YaST2/clients/product_continue.ycp") > 0)
	    WFM::CallFunction ("product_continue", []);

	Pkg::SetLocale (Language::language);
    }

    ///////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////
    ///////								    ///////
    ///////		 OO   OO      OO      O	  OO	O		    ///////
    ///////		 OO   OO      OO      O	  OO	O		    ///////
    ///////		 O O O O     O	O     O	  O O	O		    ///////
    ///////		 O  O  O    OOOOOO    O	  O  O	O		    ///////
    ///////		 O     O   O	  O   O	  O   O O		    ///////
    ///////		 O     M  O	   O  O	  O    OO		    ///////
    ///////		 O     M  O	   O  O	  O    OO		    ///////
    ///////								    ///////
    ///////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////


    if ( Mode::initial && ! Mode::repair )
    {
	Wizard::OpenAcceptAbortStepsDialog();
    }
    else
    {
	Wizard::OpenNextBackStepsDialog();
    }

    // UI::WizardCommand() can safely be called even if the respective UI
    // doesn't support the wizard widget, but for optimization it makes sense
    // to do expensive operations only when it is available.
    ProductControl::AddWizardSteps(["initial", "continue"] , "installation");

    // classified_user_settings contain secrets, like passwords ...
    // they should not be loged !
    map classified_user_settings = $[ "crypt_nb":0 ];

    if (Arch::alpha)
    {
	// get smp for alpha from /etc/install.inf
	Arch::setSMP (SCR::Read (.etc.install_inf.SMP) == "1");
    }


    if (Mode::autoinst)
    {
	Report::DisplayErrors(true, 0);
	Report::DisplayMessages(true, 10);
	Report::DisplayWarnings(true, 10);
    }

    // Don't log Report messages by default
    Report::LogMessages(false);
    Report::LogErrors(false);
    Report::LogWarnings(false);

    /*
     * The Mode::cont flag decides, if the installation
     * should be _started_ or _continued_.
     */

    ///////////////////////////////////////////////////////////////////
    // Settings for:
    // Installation: CONTINUE INSTALLATION
    ///////////////////////////////////////////////////////////////////

    if (Mode::cont)
    {
	if (SCR::Read(.target.size, Installation::destdir + "/var/lib/YaST2/update_mode") > 0)
	{
	    y2milestone ("setting Mode::update = true");
	    Mode::update = true;
	    Mode::installation = false;
	}

	Installation::encoding = Console::Restore();
	if (lookup (UI::GetDisplayInfo(), "HasFullUtf8Support", true))
	{
	    Installation::encoding = "UTF-8";
	}

	////////////////////////////////////////////////////////////
	// activate language settings and console font

	string language = Language::language;

	UI::SetLanguage (language, Installation::encoding);
	WFM::SetLanguage (language, "UTF-8");

	string ckb_cmd = Keyboard::ckb_cmd;
	string xkb_cmd = Keyboard::xkb_cmd;


	if ( ! Mode::test )
	{
	    if (ckb_cmd != "")
		SCR::Execute (.target.bash, ckb_cmd );
	    if (xkb_cmd != "")
		SCR::Execute (.target.bash, xkb_cmd );

            // ncurses calls 'dumpkeys | loadkeys --unicode' in UTF-8 locale
	    UI::SetKeyboard();
	    y2milestone("lang: %1, encoding %2, ckb_cmd: %3 xkb: %4", language, Installation::encoding, ckb_cmd, xkb_cmd);
	}

	retranslateWizardDialog();
    }

    ///////////////////////////////////////////////////////////////////
    // Settings for:
    // Installation: INITIAL INSTALLATION
    ///////////////////////////////////////////////////////////////////

    else if (!Mode::screen_shot
	     && !Mode::live_eval )
    {
	// --------------------------------------------------------------
	// do we have a floppy drive attached ?

	if (StorageDevices::FloppyReady())
	{
	    /////////////////////////////////////////////////////////////
	    // Try to load settings from disk, if a floppy is present

	    // FIXME !!

	    SCR::Execute(.target.mount, [StorageDevices::FloppyDevice, "/media/floppy"], "-t auto");

	    // Check for autoinst.xml. if available
	    // set mode to autoinst. Later, the file is parsed and installation
	    // is performed automatically.

	    if (SCR::Read(.target.size,"/media/floppy/autoinst.xml")>0)
	    {
		y2milestone("Found control file, switching to autoinst mode");
		Mode::autoinst = true;
		// initialize Report behaviour
		// Default in autoinst mode is showing messages and warnings with timeout of 10 sec.
		// Errors are shown without timeout.

		Report::DisplayErrors(true, 0);
		Report::DisplayMessages(true, 10);
		Report::DisplayWarnings(true, 10);
	    }
	    SCR::Execute(.target.umount, "/media/floppy");
	}
    }

    /////////////////////////////////////////
    // show message if text_fallback
    /////////////////////////////////////////

    if ((Mode::text_fallback || Mode::no_x11)
	&& (Mode::x11_setup_needed && Arch::x11_setup_needed)
	&& !Installation::shown_text_mode_warning)
    {
	string x11_msg = "";
	if (Mode::text_fallback)
	{
	    // somehow the graphical frontend failed and we're running in
	    // text mode. Inform the user about this fact.
	    x11_msg = sformat(_("Your computer does not fulfill all requirements for
a graphical installation. There is less than %1 MB
memory or the X server could not be started.

As a fallback, the text front-end of YaST2 will guide you
through the installation. This front-end offers the
same functionality as the graphical one, but the screens
differ from those in the manual.
"), "64");

	}
	else if (Mode::no_x11)
	{
	    // somehow the graphical frontend failed and we're running in
	    // text mode. Inform the user about this fact.
	    x11_msg = _("The graphical interface could not be started.

The required packages were not installed (minimal installation) or
the graphics card is not properly supported.

As a fallback, the text front-end of YaST2 will guide you
through the installation. This front-end offers the
same functionality as the graphical one, but the screens
differ from those in the manual.
");
	}

	Report::Message(x11_msg);

	// show this warning only once
	Installation::shown_text_mode_warning = true;
    }


    //--------------------------------------------------------------------

    // Some abbreviations to keep the table below less wide
    boolean autoinst	= Mode::autoinst;
    boolean autoconf	= AutoInstall::autoconf;
    boolean live_eval	= Mode::live_eval;
    boolean test_mode	= Mode::test;
    boolean update_mode	= Mode::update;		// FIXME: work's only after reboot
    boolean repair	= Mode::repair;
    boolean screen_shot_mode = Mode::screen_shot;


    //////////////////////////////////////////////////////////////////
    // All settings the user does are saved into a map. The submodules
    // are called as functions and thus have access to this variable.
    // They return `next, `back, `cancel, `again or `auto.
    // A submodule that can't be loaded (syntax error) returns nil.

    any	    former_result = `next;
    integer m = 0;			// current module

    Wizard::SetFocusToNextButton();    

    list<map> modules = ProductControl::getModules(Mode::stage, Mode::mode);
    map defaults = ProductControl::getModeDefaults(Mode::stage, Mode::mode);
    y2debug("Starting Workflow with  \"%1\" \"%2\"",  Mode::stage, Mode::mode);
    while ((m >= 0) && (m < size(modules)))
    {
        map mod = modules[m]:$[];
        term argterm = ProductControl::getTerm( mod, defaults);

        boolean   do_continue           = false;

        if (!ProductControl::checkArch(mod, defaults))
        {
            y2milestone("continue (arch)..");
            do_continue = true;
        }

        if (!mod["update"]:true && Mode::update)
        {
            y2milestone("continue (update)..");
            do_continue = true;
        }

        if ( do_continue )
        {
            if      (former_result == `next) m = m + 1;
            else                             m = m - 1;
        }
        if ( do_continue ) continue;

        y2milestone("Running module: %1 (%2)", argterm, m);
        argterm = add (argterm, former_result == `back);

        symbol module_name = symbolof( argterm );

        if ( module_name != `inst_doit )        // This is only a popup
        {
            Wizard::ClearContents();
        }

       // --------------------------------------
       // Call the wizard dialog

        y2milestone( "Calling %1", argterm );

        Hooks::Checkpoint (sformat("%1", module_name), true);           // entry hook, (""+symbol is a symbol->string conversion)

        list args = [];

        integer i = 0;
        while (i < size(argterm)) {
            args[i] = select(argterm, i, -1);
            i = i + 1;
        }

	// FIXME
	UI::WizardCommand(`SetCurrentStep( mod["id"]:"" ) );

        symbol result = (symbol) WFM::CallFunction (substring(sformat("%1", module_name), 1), args);


        Hooks::Checkpoint (sformat("%1", module_name), false);          // exit hook

        if ( module_name == `inst_language || module_name == `autoinst_init )   // language change very likely
        {
            retranslateWizardDialog();
        }


        // If the module return nil, something basic went wrong.
        // We show a stub dialog instead.
        if (result == nil)
        {
            any r = nil;
            r = Popup::ModuleError(sformat("The module %1 does not work.", symbolof(argterm)));
            if      (r == `next)   m = m + 1;
            else if (r == `back)   m = m - 1;
            else if (r != `again)
            {
                UI::CloseDialog();
                return nil;
            }
            continue;
        }

        if      (result == `next)
        {
            m = m + 1;
        }
        else if (result == `back)
        {
            m = m - 1;
        }
        else if (result == `cancel)
        {
            break;
        }
        else if (result == `abort)
        {
            // Close Sources
            Pkg::SourceFinishAll ();
            Pkg::TargetFinish ();

            // tell linuxrc that we aborted
            Misc::WriteYaSTInf($["Aborted" : "1"]);
            break;
        }
        else if (result == `finish)
        {
            break;
        }
        else if (result == `again)
        {
            continue; // Show same dialog again
        }
        else if (result == `auto)
        {
            if (former_result != nil) {
                if      (former_result == `next) m = m + 1;
                else if (former_result == `back) m = m - 1;
            }
            continue;
        }
        former_result = result;

    }

    // re-enable automatic probing
    WFM::Execute (.local.bash, "/bin/echo \"/sbin/modprobe\" >/proc/sys/kernel/modprobe");

    if (Mode::cont)
    {
	// remove /etc/install.inf, not needed any more
	SCR::Execute (.target.remove, "/etc/install.inf");
	if (Mode::update)
	{
	    SCR::Execute(.target.remove, "/var/lib/YaST2/update_mode");
	    SCR::Execute(.target.bash, "/bin/rm -rf /var/adm/current_package_descr");
	}
	SCR::Execute(.target.remove, "/var/lib/YaST2/runme_at_boot");

	if (WFM::Read (.local.size, "/usr/share/YaST2/clients/product_post.ycp") > 0)
	    WFM::CallFunction ("product_post", [Mode::update]);
    }

    // disable all sources and finish target
    Pkg::SourceFinishAll();
    Pkg::TargetFinish();

    UI::CloseDialog();

    if (m <= -1)	return `back;
    else		return `next;
}
