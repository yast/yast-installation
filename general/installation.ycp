/**
 * Module:		installation.ycp
 *
 * $Id$
 *
 * Authors:		Klaus Kaempf <kkaempf@suse.de>
 *			Mathias Kettner <kettner@suse.de>
 *			Michael Hager <mike@suse.de>
 *			Stefan Hundhammer <sh@suse.de>
 *			Arvin Schnell <arvin@suse.de>
 *
 * Purpose:		Set up the UI and define macros for the
 *			installation dialog, general framework, ...
 *			Describing and calling all submodules, depending on
 *			the installation should be started or continued.
 *
 */
{
    textdomain "installation";

    // this is installation, so start SCR always locally (as plugin) !

    integer scrHandle = WFM::SCROpen ("scr", false);
    WFM::SCRSetDefault (scrHandle);

    import "Arch";
    import "Mode";
    import "Installation";
    import "Language";
    import "Storage";
    Installation::scrHandle = scrHandle;

    import "AutoInstall";
    import "Mouse";
    import "Console";
    import "StorageDevices";
    import "Misc";
    import "Keyboard";
    import "Packages";

    import "Wizard";
    import "Label";
    import "Popup";
    import "Report";
    import "Hooks";

    include "installation_ui.ycp";
    include "partitioning/partition_defines.ycp";

    // ==================================================================================

    /**
     * Returns a list of strings describing the "easy installation"
     * @return list of strings
     **/
    global define list EasyInstallationStepDescriptions() ``{
	return [
		// Descriptions of the installation steps.
		// Translations shouldn't get much wider than the originals,
		// but feel free to include more newlines.
		_("Language\nSelection"),
		// Descriptions of the installation steps.
		// Translations shouldn't get much wider than the originals,
		// but feel free to include more newlines.
		_("Installation\nSettings"),
		// Descriptions of the installation steps.
		// Translations shouldn't get much wider than the originals,
		// but feel free to include more newlines.
		_("Perform\nInstallation")
	];
    };


    /**
     * Re-translate static part of wizard dialog and other predefined messages
     * after language change
     */
    define void retranslateWizardDialog() ``{

	y2debug( "Retranslating messages" );

	// Make sure the labels for default function keys are retranslated, too.
	// Using Label::DefaultFunctionKeyMap() from Label module.
	UI::SetFunctionKeys( Label::DefaultFunctionKeyMap() );

	// Activate language changes on static part of wizard dialog

	if ( Mode::initial )
	{
	    Wizard::SetEasyInstallationStep( EasyInstallationStepDescriptions(), 1 );
	}

	Wizard::ReplaceButtonBox( Wizard::HasAcceptButton() ?
				  Wizard::AbortInstallationAcceptButtonBox() :
				  Wizard::BackAbortInstallationNextButtonBox() );

	if ( UI::WidgetExists(`id(`next) ) )	UI::SetFocus(`id(`next) );
	else					UI::SetFocus(`id(`accept ) );
    }

    // ==================================================================================


    // properly set up initial language

    if (Mode::initial)
    {
	Pkg::InstSysMode();

	// --------------------------------------------------------------
	//                   Mouse
	// --------------------------------------------------------------
	if (!Arch::s390 || Arch::board_iseries)
	{
	    y2milestone("Call Mouse probing...");
	    if (!Mouse::Found())
	    {
		// ...
		// Let the USB modules settle for a while.
		// Mouse probing may fail otherwise...
		//
		SCR::Execute(.target.bash, "/bin/sleep 4");
		if ( Mode::x11_setup_needed && !Mode::text ) {
		    SCR::Execute (.target.bash, "/usr/X11R6/bin/xmset --disable");
		}
		Mouse::Set (Mouse::Probe ());
		if ( Mode::x11_setup_needed && !Mode::text ) {
		    SCR::Execute (.target.bash, "/usr/X11R6/bin/xmset --enable");
		}
	    }
	}

	Installation::encoding = Console::SelectFont( Language::language );

	if (lookup (UI::GetDisplayInfo(), "HasFullUtf8Support", true))
	{
	    Installation::encoding = "UTF-8";
	}

	UI::SetLanguage (Language::language, Installation::encoding);
	WFM::SetLanguage (Language::language, "UTF-8");

	if (WFM::Read (.local.size, "/usr/share/YaST2/clients/product_initial.ycp") > 0)
	    WFM::CallFunction (product_initial());
    }

    // Properly setup timezone for continue mode.
    //
    if ( Mode::cont )
    {
	import "Timezone";
	Timezone::Set( Timezone::timezone, true );

	if (WFM::Read (.local.size, "/usr/share/YaST2/clients/product_continue.ycp") > 0)
	    WFM::CallFunction (product_continue());

	Pkg::SetLocale (Language::language);
    }

    ///////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////
    ///////								    ///////
    ///////		 OO   OO      OO      O	  OO	O		    ///////
    ///////		 OO   OO      OO      O	  OO	O		    ///////
    ///////		 O O O O     O	O     O	  O O	O		    ///////
    ///////		 O  O  O    OOOOOO    O	  O  O	O		    ///////
    ///////		 O     O   O	  O   O	  O   O O		    ///////
    ///////		 O     M  O	   O  O	  O    OO		    ///////
    ///////		 O     M  O	   O  O	  O    OO		    ///////
    ///////								    ///////
    ///////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////


    if ( Mode::initial && ! Mode::repair )
    {
	Wizard::OpenDialog( Wizard::EasyInstallationDialog( Wizard::AbortInstallationAcceptButtonBox(),
							    EasyInstallationStepDescriptions() ) );
    }
    else
    {
	Wizard::OpenNextBackDialog();
    }

    // classified_user_settings contain secrets, like passwords ...
    // they should not be loged !
    map classified_user_settings = $[ "crypt_nb":0 ];

    if (Arch::alpha)
    {
	// get smp for alpha from /etc/install.inf
	Arch::setSMP (SCR::Read (.etc.install_inf.SMP) == "1");
    }


    if (Mode::autoinst)
    {
	Report::DisplayErrors(true, 10);
	Report::DisplayMessages(true, 10);
	Report::DisplayWarnings(true, 10);
    }

    // Don't log Report messages by default
    Report::LogMessages(false);
    Report::LogErrors(false);
    Report::LogWarnings(false);

    /*
     * The Mode::cont flag decides, if the installation
     * should be _started_ or _continued_.
     */

    ///////////////////////////////////////////////////////////////////
    // Settings for:
    // Installation: CONTINUE INSTALLATION
    ///////////////////////////////////////////////////////////////////

    if (Mode::cont)
    {
	if (SCR::Read(.target.size, Installation::destdir + "/var/lib/YaST2/update_mode") > 0)
	{
	    Mode::update = true;
	}

	Installation::encoding = Console::Restore();
	if (lookup (UI::GetDisplayInfo(), "HasFullUtf8Support", true))
	{
	    Installation::encoding = "UTF-8";
	}

	////////////////////////////////////////////////////////////
	// re-init network in continue mode with network installation

	if (!Mode::test && !Arch::s390)
	{
	    SCR::Execute (.target.bash, "/sbin/ifconfig lo 127.0.0.1 up");

	    if ((Mode::boot == "nfs")
		|| (Mode::boot == "http")
		|| (Mode::boot == "smb")
		|| (Mode::boot == "ftp"))
	    {
		// TODO: handle dhcp case correctly

		string netdev = SCR::Read (.etc.install_inf.Netdevice);
		if (netdev == nil) netdev = "eth0";

		string ipaddr = SCR::Read (.etc.install_inf.IP);
		if (ipaddr == nil) ipaddr = "";

		string ifconfig = "/sbin/ifconfig " + netdev + " " + ipaddr;

		string netmask = SCR::Read (.etc.install_inf.Netmask);
		if (netmask != nil && netmask != "")
		{
		    ifconfig = ifconfig + " netmask " + netmask;
		}

		SCR::Execute (.target.bash, ifconfig);

		string gateway = SCR::Read (.etc.install_inf.Gateway);
		if (gateway != nil && gateway != "")
		{
		    ifconfig = "/sbin/route add default gw " + gateway;
		    SCR::Execute (.target.bash, ifconfig);
		}

	    }
	}

	if (Mode::boot == "nfs")
	{
	    SCR::Execute (.target.bash, "/sbin/rcportmap start");
	}

	////////////////////////////////////////////////////////////
	// activate language settings and console font

	string language = Language::language;

	UI::SetLanguage (language, Installation::encoding);
	WFM::SetLanguage (language, "UTF-8");

	string ckb_cmd = Keyboard::ckb_cmd;
	string xkb_cmd = Keyboard::xkb_cmd;


	if ( ! Mode::test )
	{
	    if (ckb_cmd != "")
		SCR::Execute (.target.bash, ckb_cmd );
	    if (xkb_cmd != "")
		SCR::Execute (.target.bash, xkb_cmd );
	    y2milestone("lang: %1, encoding %2, ckb_cmd: %3 xkb: %4", language, Installation::encoding, ckb_cmd, xkb_cmd);
	}

	retranslateWizardDialog();
    }

    ///////////////////////////////////////////////////////////////////
    // Settings for:
    // Installation: INITIAL INSTALLATION
    ///////////////////////////////////////////////////////////////////

    else if (!Mode::screen_shot
	     && !Mode::live_eval )
    {
	// --------------------------------------------------------------
	// do we have a floppy drive attached ?

	if (StorageDevices::FloppyReady())
	{
	    /////////////////////////////////////////////////////////////
	    // Try to load settings from disk, if a floppy is present

	    // FIXME !!

	    SCR::Execute(.target.mount, [StorageDevices::FloppyDevice, "/media/floppy"], "-t auto");

	    // Check for autoinst.xml. if available
	    // set mode to autoinst. Later, the file is parsed and installation
	    // is performed automatically.

	    if (SCR::Read(.target.size,"/media/floppy/autoinst.xml")>0)
	    {
		y2milestone("Found control file, switching to autoinst mode");
		Mode::autoinst = true;
		// initialize Report behaviour
		// Default in autoinst mode is showing messages and warnings with timeout of 10 sec.
		// Errors are shown without timeout.

		Report::DisplayErrors(true, 10);
		Report::DisplayMessages(true, 10);
		Report::DisplayWarnings(true, 10);

	    }
	    SCR::Execute(.target.umount, "/media/floppy");
	}

	//////////////////////////////////////////////////////////////
	// Show info, if existent.

	string infofile = "/info.txt";		// copied there by linuxrc
	string infotext = SCR::Read (.target.string, [infofile, ""]);

	if (infotext != "")
	{
	    map tmp1 = Report::Export ();
	    map tmp2 = tmp1["messages"]:$[];
	    integer timeout_seconds = tmp2["timeout"]:0;

	    UI::OpenDialog(
			   `HBox(
				 `VSpacing(20),
				 `VBox(
				       `HSpacing(60),
				       `VSpacing(0.2),
				       `RichText(`opt(`plainText), infotext ),
				       `ReplacePoint (`id(`rp1), `Empty () ),
				       `HBox(
					     `HStretch(),
					     // Button to accept a license agreement
					     `HWeight(1, `PushButton(`id(`accept), `opt(`default), _("I &Agree") ) ),
					     `HStretch(),
					     // Button to reject a license agreement
					     `HWeight(1, `PushButton(`id(`donotaccept), _("I Do &Not Agree") ) ),
					     `HStretch(),
					     `ReplacePoint(`id(`rp2), `Empty ())
					     )
				       )
				 )
			   );

	    UI::SetFocus (`id(`accept));

	    symbol info_ret = `empty;

	    if (timeout_seconds == 0)
	    {
		info_ret = UI::UserInput ();
	    }
	    else
	    {
		UI::ReplaceWidget (`id(`rp1), `Label (`id(`remaining_time), "" + timeout_seconds));
		UI::ReplaceWidget (`id(`rp2), `PushButton (`id(`stop), Label::StopButton()));

		while (timeout_seconds > 0) {
		    sleep (1000);
		    info_ret = UI::PollInput ();
		    if (info_ret == `accept || info_ret == `donotaccept)
			break;
		    if (info_ret == `stop) {
			while (info_ret == `stop)
			    info_ret = UI::UserInput ();
			break;
		    }
		    info_ret = `accept;
		    timeout_seconds = timeout_seconds - 1;
		    UI::ChangeWidget (`id(`remaining_time), `Value, "" + timeout_seconds);
		}
	    }

	    UI::CloseDialog ();

	    if (info_ret != `accept)
	    {
		y2milestone ("user didn't accept info.txt");

		// disable all sources and finish target
		Pkg::SourceFinishAll ();
		Pkg::TargetFinish ();

		// tell linuxrc that we aborted
		Misc::WriteYaSTInf ($["Aborted" : "1"]);
		return nil;
	    }
	}
    }

    /////////////////////////////////////////
    // show message if text_fallback
    /////////////////////////////////////////

    if ((Mode::text_fallback || Mode::no_x11)
	&& (Mode::x11_setup_needed && Arch::x11_setup_needed)
	&& !Installation::shown_text_mode_warning)
    {
	string x11_msg = "";
	if (Mode::text_fallback)
	{
	    // somehow the graphical frontend failed and we're running in
	    // text mode. Inform the user about this fact.
	    x11_msg = sformat(_("Your computer does not fulfill all requirements for
a graphical installation. Either you have less than %1 MB
memory or the X server could not be started.

As a fallback, the text front-end of YaST2 will guide you
through the installation. This front-end offers the
same functionality as the graphical one, but the screens
appear different than those in the manual.
"), "64");

	}
	else if (Mode::no_x11)
	{
	    // somehow the graphical frontend failed and we're running in
	    // text mode. Inform the user about this fact.
	    x11_msg = _("The graphical interface could not be started.

Either the required packages were not installed (minimal installation) or
the graphics card is not properly supported.

As a fallback, the text front-end of YaST2 will guide you
through the installation. This front-end offers the
same functionality as the graphical one, but the screens
appear different than those in the manual.
");
	}

	Report::Message(x11_msg);

	// show this warning only once
	Installation::shown_text_mode_warning = true;
    }


    //--------------------------------------------------------------------

    // Some abbreviations to keep the table below less wide
    boolean autoinst	= Mode::autoinst;
    boolean autoconf	= AutoInstall::autoconf;
    boolean live_eval	= Mode::live_eval;
    boolean test_mode	= Mode::test;
    boolean update_mode	= Mode::update;		// FIXME: work's only after reboot
    boolean repair	= Mode::repair;
    boolean screen_shot_mode = Mode::screen_shot;

    // - - - - - - - - - - - - -

    list modules   =


////////////////////////////////////////////////////////////////////////////////////////////////////
// Step:	       First step( initial) or continue mode (after first reboot)
// Module:	       Name of the module
// Back:	       Is Back-Button sensitive
// Next:	       Is Next-Button sensitive
// Architecture:       Step is executed if Architecture is "true".
// Mode:	       A Step is executed if Mode is "true".
// immediate_prepdisk: A special mode that be dynmically switched on, so we need an own column.
//                     Generally it should switch off all modules between inst_custom_part and inst_prepdisk.
//
// Caution: A Step is only executed if Architecture AND Mode is true!!
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  0-Step-	1-Module-	    -Back- -Next- -spec-  2-Architecture(s)-		      3-Mode(s)-                           4-immediate_prepdisk-

[
 [ `initial,  `inst_language	    (false, true, true), true,						! autoinst	&&    !	repair  , false],
 [ `initial,  `inst_repair	    (false, true),	 true,									repair	, false],
 [ `initial,  `inst_startup	    (false, true),       true,						  autoinst                      , false],
 [ `initial,  `autoinst_init	    (false, false),      true,			! test_mode &&		  autoinst			, false],
 [ `initial,  `autoinst_setup	    (false, false),      true,			! test_mode &&		  autoinst			, false],
 //---------------------------------------------------------------------------------------------------------------------------------------------------
 [ `initial,  `inst_proposal	    (true,  true, `ini), true,			true							, false],
 //---------------------------------------------------------------------------------------------------------------------------------------------------
 [ `initial,  `inst_do_resize	    (false, false),      Arch::i386||Arch::x86_64||Arch::ia64,	! live_eval &&	! autoinst && !Mode::update , false],
 //---------------------------------------------------------------------------------------------------------------------------------------------------
 [ `initial,  `inst_prepdisk	    (false, false),      true,			true,                                                    false],
 [ `initial,  `inst_rpmcopy	    (false, false),      true,			( ! live_eval	  ||	  screen_shot_mode) && !Mode::update, false],
 [ `initial,  `inst_rpmupdate	    (false, false),      true,			( ! live_eval	  ||	  screen_shot_mode) && Mode::update, false],
 //---------------------------------------------------------------------------------------------------------------------------------------------------
 [ `initial,  `inst_finish	    (false, false),      true,			! test_mode						, false],

 //===================================================================================================================================================

 [ `continue, `inst_netprobe	    (false, false),      true,		true								, false],
 [ `continue, `inst_rpmcopy	    (false, false),      true,		!autoconf && ! live_eval && ! test_mode				, false],
 [ `continue, `inst_language	    (false, true),       true,					  screen_shot_mode &&    ! update_mode  , false],
 [ `continue, `inst_root	    (false, true),       true,						! autoinst &&    ! update_mode	, true ],
 [ `continue, `inst_x11         (true,  true),       Arch::x11_setup_needed, Mode::x11_setup_needed &&    autoinst &&    ! update_mode  , false],
 [ `continue, `autoinst_configure   (false, false),      true,						  autoinst &&    ! update_mode	, false],
 [ `continue, `inst_proposal	    (true,  true, `net), true,						! autoinst &&    ! update_mode	, false],
 [ `continue, `inst_ask_net_test    (true,  true),       true,				! live_eval &&	! autoinst       	        , true ],
 [ `continue, `inst_do_net_test	    (true,  true),       true,				! live_eval &&	! autoinst                      , true ],
 [ `continue, `inst_you		    (true,  true),       true,				! live_eval &&	! autoinst               	, true ],
 [ `continue, `inst_auth	    (true,  true),       true,				! live_eval &&	! autoinst &&    ! update_mode	, true ],
 [ `continue, `inst_user	    (true,  true),       true,						! autoinst &&    ! update_mode	, true ],
 [ `continue, `inst_suseconfig	    (false, false),      true,			! test_mode						, false],
 [ `continue, `inst_release_notes   (true,  true),	 true,				! live_eval &&	! autoinst               	, false],
 [ `continue, `inst_proposal	    (true,  true, `hw),  true,						! autoinst &&    ! update_mode	, false],
 [ `continue, `inst_congratulate    (true,  true),	 true,				! live_eval &&	! autoinst               	, false]
];


    //////////////////////////////////////////////////////////////////
    // All settings the user does are saved into a map. The submodules
    // are called as functions and thus have access to this variable.
    // They return `next, `back, `cancel, `again or `auto.
    // A submodule that can't be loaded (syntax error) returns nil.

    any	    former_result = `next;
    integer m = 0;			// current module

    if ( UI::WidgetExists(`id(`next) ) )	UI::SetFocus(`id(`next) );
    else					UI::SetFocus(`id(`accept ) );

    while ((m >= 0) && (m < size(modules)))
    {
	list	  module_info		= modules[m]:[];
	symbol	  main_mode		= module_info[0]:`dummy;  // `initial or `continue
	term	  argterm		= module_info[1]:`dummy();
	boolean	  allowed_arch		= module_info[2]:true;
	boolean	  allowed_mode		= module_info[3]:false;
	boolean	  immediate_prep_mode	= module_info[4]:false;

	boolean	  do_continue		= false;

	symbol	  old_mode		= `dummy;

	if( m > 0 )
	{
	    list old_module_info = modules[m - 1]:[];
	    old_mode = old_module_info[0]:`dummy;
	}

	////////////////////////////////////////////////////////////////
	// Check if the module has to be executed

	if ( Mode::cont
	     &&	main_mode != `continue)
	{
	    do_continue = true;
	}
	if ( !Mode::cont
	     &&	main_mode != `initial
	     && !Mode::live_eval)
	{
	    do_continue = true;
	}
	if (!allowed_arch || !allowed_mode)
	{
	    do_continue = true;
	}
	if ( immediate_prep_mode
	     && Storage::immediate_prepdisk )
	{
	    do_continue = true;
	}

	if ( do_continue )
	{
	    if	    (former_result == `next) m = m + 1;
	    else			     m = m - 1;
	}

	if ( Mode::live_eval && main_mode != old_mode && main_mode == `continue )
	{
	    Mode::initial = false;
	    Mode::cont = true;

	    Wizard::CloseDialog();
	    Wizard::OpenNextBackDialog();
            // or, instead of the above, do:
            // Wizard::ReplaceButtonBox( Wizard::BackAbortNextButtonBox() );
	}

	if ( do_continue ) continue;
	//		   ^^^^^^^
	/////////////////////////////////////////////////////////////////

	// Tell modules if we were going backwards.
	argterm = add (argterm, former_result == `back);

	// Clear the old dialog contents for faster feedback

	symbol module_name = symbolof( argterm );

	if ( module_name != `inst_doit )	// This is only a popup
	{
	    Wizard::ClearContents();
	}

	// --------------------------------------
	// Call the wizard dialog

	y2milestone( "Calling %1", argterm );

	Hooks::Checkpoint ("" + module_name, true);		// entry hook, (""+symbol is a symbol->string conversion)

	symbol result = WFM::CallFunction (argterm);

	Hooks::Checkpoint ("" + module_name, false);		// exit hook


	Installation::immediate_prepdisk = false; //FIXME !

	if ( module_name == `inst_language || module_name == `autoinst_init )	// language change very likely
	{
	    retranslateWizardDialog();
	}


	// If the module return nil, something basic went wrong.
	// We show a stub dialog instead.
	if (result == nil)
	{
	    any r = nil;
	    r = Popup::ModuleError(("The module " + symbolof(argterm)) + " does not work.");
	    if	    (r == `next)   m = m + 1;
	    else if (r == `back)   m = m - 1;
	    else if (r != `again)
	    {
		UI::CloseDialog();
		return nil;
	    }
	    continue;
	}

	if	(result == `next)
	{
	    m = m + 1;
	}
	else if (result == `back)
	{
	    m = m - 1;
	}
	else if (result == `cancel)
	{
	    break;
	}
	else if (result == `abort)
	{
	    // disable all sources and finish target
	    Pkg::SourceFinishAll ();
	    Pkg::TargetFinish ();

	    // tell linuxrc that we aborted
	    Misc::WriteYaSTInf($["Aborted" : "1"]);
	    break;
	}
	else if (result == `finish)
	{
	    break;
	}
	else if (result == `again)
	{
	    continue; // Show same dialog again
	}
	else if (result == `auto)
	{
	    if (former_result != nil) {
		if	(former_result == `next) m = m + 1;
		else if (former_result == `back) m = m - 1;
	    }
	    continue;
	}
	former_result = result;
    }

    // re-enable automatic probing
    WFM::Execute (.local.bash, "/bin/echo \"/sbin/modprobe\" >/proc/sys/kernel/modprobe");

    if (Mode::cont)
    {
	// remove /etc/install.inf, not needed any more
	SCR::Execute (.target.remove, "/etc/install.inf");
	if (Mode::update)
	{
	    SCR::Execute(.target.remove, "/var/lib/YaST2/update_mode");
	    SCR::Execute(.target.bash, "/bin/rm -rf /var/adm/current_package_descr");
	}
	SCR::Execute(.target.remove, "/var/lib/YaST2/runme_at_boot");

	if (WFM::Read (.local.size, "/usr/share/YaST2/clients/product_post.ycp") > 0)
	    WFM::CallFunction (product_post(Mode::update));
    }

    // disable all sources and finish target
    Pkg::SourceFinishAll();
    Pkg::TargetFinish();

    UI::CloseDialog();

    if (m <= -1)	return `back;
    else		return `next;
}
