/**
 * Module:		installation.ycp
 *
 * Authors:		Klaus Kaempf <kkaempf@suse.de>
 *			Mathias Kettner <kettner@suse.de>
 *			Michael Hager <mike@suse.de>
 *			Stefan Hundhammer <sh@suse.de>
 *			Arvin Schnell <arvin@suse.de>
 *
 * Purpose:		Set up the UI and define macros for the
 *			installation dialog, general framework, ...
 *			Describing and calling all submodules, depending on
 *			the installation should be started or continued.
 *
 * $Id$
 */
{
    textdomain "installation";

    // this is installation, so start SCR always locally (as plugin) !

    integer scr_handle = WFM::SCROpen ("scr", false);
    WFM::SCRSetDefault (scr_handle);

    import "Arch";
    import "Mode";
    import "Directory";
    import "Stage";
    import "Installation";
    import "ProductControl";
    import "ProductFeatures";
    import "Language";
    import "Storage";
    Installation::scr_handle = scr_handle;

    import "AutoInstall";
    import "Mouse";
    import "Console";
    import "StorageDevices";
    import "Keyboard";
    import "Packages";

    import "Wizard";
    import "Label";
    import "Popup";
    import "Report";
    import "Hooks";

    import "FileSystems";
    import "Linuxrc";

    // ======================================================================


    /**
     * Re-translate static part of wizard dialog and other predefined messages
     * after language change
     */
    void retranslateWizardDialog()
    {
	y2debug( "Retranslating messages" );

	// Make sure the labels for default function keys are retranslated, too.
	// Using Label::DefaultFunctionKeyMap() from Label module.
	UI::SetFunctionKeys( Label::DefaultFunctionKeyMap() );

	// Activate language changes on static part of wizard dialog

	ProductControl::RetranslateWizardSteps();
	Wizard::RetranslateButtons();
	Wizard::SetFocusToNextButton();

    }

    // ======================================================================


    // properly set up initial language

    if (Stage::initial ())
    {
	Pkg::InstSysMode();

	Installation::encoding = Console::SelectFont( Language::language );

	if (lookup (UI::GetDisplayInfo(), "HasFullUtf8Support", true))
	{
	    Installation::encoding = "UTF-8";
	}

	UI::SetLanguage (Language::language, Installation::encoding);
	WFM::SetLanguage (Language::language, "UTF-8");
	UI::RecordMacro( Directory::logdir + "/macro_inst_initial.ycp" );
    }

    // Properly setup timezone for continue mode.
    //
    if ( Stage::cont () )
    {
	import "Timezone";
	Timezone::Set( Timezone::timezone, true );
	Pkg::SetLocale (Language::language);
	UI::RecordMacro( Directory::logdir + "/macro_inst_cont.ycp" );
    }

    ///////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////
    ///////								    ///////
    ///////		 OO   OO      OO      O	  OO	O		    ///////
    ///////		 OO   OO      OO      O	  OO	O		    ///////
    ///////		 O O O O     O	O     O	  O O	O		    ///////
    ///////		 O  O  O    OOOOOO    O	  O  O	O		    ///////
    ///////		 O     O   O	  O   O	  O   O O		    ///////
    ///////		 O     M  O	   O  O	  O    OO		    ///////
    ///////		 O     M  O	   O  O	  O    OO		    ///////
    ///////								    ///////
    ///////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////

    // Detect mode early to be able to setup steps correctly
    if (Stage::cont ())
    {
	if (SCR::Read(.target.size, Installation::destdir + "/var/lib/YaST2/update_mode") > 0)
	{
	    Mode::SetMode ("update");
	}
    }

    if ( Stage::initial () && ! Mode::repair () )
    {
	Wizard::OpenAcceptAbortStepsDialog();
    }
    else
    {
	Wizard::OpenNextBackStepsDialog();
    }

    // --------------------------------------------------------------
    //                   Mouse
    // --------------------------------------------------------------
    if (Stage::initial () && (!Arch::s390 () || Arch::board_iseries ()))
    {
	UI::BusyCursor();
	/* Busy popup label */
	UI::OpenDialog(`VBox(`Label(_("Probing mouse..."))));
	y2milestone("Call Mouse probing...");

	if (!Mouse::Found())
	{
	    // ...
	    // Let the USB modules settle for a while.
	    // Mouse probing may fail otherwise...
	    //
	    // FIXME: I don't think it's required any more but someone has to confirm
	    SCR::Execute(.target.bash, "/bin/sleep 4");
	    if ( Installation::x11_setup_needed () && !Linuxrc::text () ) {
		SCR::Execute (.target.bash, "/usr/X11R6/bin/xmset --disable");
	    }
	    Mouse::Set (Mouse::Probe ());
	    if ( Installation::x11_setup_needed () && !Linuxrc::text () ) {
		SCR::Execute (.target.bash, "/usr/X11R6/bin/xmset --enable");
	    }
	}

	UI::CloseDialog();
    }

    string wizard_mode = Mode::test () ? "installation" : Mode::mode ();

    // UI::WizardCommand() can safely be called even if the respective UI
    // doesn't support the wizard widget, but for optimization it makes sense
    // to do expensive operations only when it is available.
    list<map> stage_mode = [$["stage": "initial" , "mode": wizard_mode ],
			    $["stage": "continue", "mode": wizard_mode ],
			    $["stage": "normal",  "mode": wizard_mode ]];
    ProductControl::AddWizardSteps(stage_mode);

    // classified_user_settings contain secrets, like passwords ...
    // they should not be logged !
    map classified_user_settings = $[ "crypt_nb":0 ];

    if (Mode::autoinst ())
    {
	Report::DisplayErrors(true, 0);
	Report::DisplayMessages(true, 10);
	Report::DisplayWarnings(true, 10);
    }

    // Don't log Report messages by default
    Report::LogMessages(false);
    Report::LogErrors(false);
    Report::LogWarnings(false);

    /*
     * The Stage::cont () flag decides, if the installation
     * should be _started_ or _continued_.
     */

    ///////////////////////////////////////////////////////////////////
    // Settings for:
    // Installation: CONTINUE INSTALLATION
    ///////////////////////////////////////////////////////////////////

    if (Stage::cont ())
    {
	Installation::encoding = Console::Restore();
	if (lookup (UI::GetDisplayInfo(), "HasFullUtf8Support", true))
	{
	    Installation::encoding = "UTF-8";
	}

	////////////////////////////////////////////////////////////
	// activate language settings and console font

	string language = Language::language;

	UI::SetLanguage (language, Installation::encoding);
	WFM::SetLanguage (language, "UTF-8");

	string ckb_cmd = Keyboard::ckb_cmd;
	string xkb_cmd = Keyboard::xkb_cmd;


	if ( ! Mode::test () )
	{
	    if (ckb_cmd != "")
		SCR::Execute (.target.bash, ckb_cmd );
	    if (xkb_cmd != "")
		SCR::Execute (.target.bash, xkb_cmd );

            // ncurses calls 'dumpkeys | loadkeys --unicode' in UTF-8 locale
	    UI::SetKeyboard();
	    y2milestone ("lang: %1, encoding %2, ckb_cmd: %3 xkb: %4", language,
			 Installation::encoding, ckb_cmd, xkb_cmd);
	}

	retranslateWizardDialog();
    }
    else if (!Mode::screen_shot ()
             && !Stage::firstboot ()
             )
    {

        ///////////////////////////////////////////////////////////////////
        // Settings for:
        // Installation: INITIAL INSTALLATION
        ///////////////////////////////////////////////////////////////////

	// do we have a floppy drive attached ?

	if (StorageDevices::FloppyReady())
	{
	    // Try to load settings from disk, if a floppy is present

	    SCR::Execute(.target.mount, [StorageDevices::FloppyDevice, "/media/floppy"], "-t auto");

	    // Check for autoinst.xml. if available
	    // set mode to autoinst. Later, the file is parsed and installation
	    // is performed automatically.

	    if (SCR::Read(.target.size,"/media/floppy/autoinst.xml")>0)
	    {
		y2milestone("Found control file, switching to autoinst mode");
		Mode::SetMode ("autoinst");
		// initialize Report behavior
		// Default in autoinst mode is showing messages and warnings with timeout of 10 sec.
		// Errors are shown without timeout.

		Report::DisplayErrors(true, 0);
		Report::DisplayMessages(true, 10);
		Report::DisplayWarnings(true, 10);
	    }
	    SCR::Execute(.target.umount, "/media/floppy");
	}
    }

    /////////////////////////////////////////
    // show message if text_fallback
    /////////////////////////////////////////
    if ((Installation::text_fallback () || Installation::no_x11 ())
	&& (Installation::x11_setup_needed () && Arch::x11_setup_needed ())
	&& !Installation::shown_text_mode_warning)
    {
	string x11_msg = "";
	if ((Installation::no_x11 () || Installation::text_fallback ()) && Stage::initial ())
	{
	    // Somehow the graphical frontend failed and we're running in
	    // text mode. Inform the user about this fact.
	    x11_msg = sformat(_("Your computer does not fulfill all requirements for
a graphical installation. There is less than %1 MB
memory or the X server could not be started.

As a fallback, the text front-end of YaST2 will guide you
through the installation. This front-end offers the
same functionality as the graphical one, but the screens
differ from those in the manual.
"), "96");

	}
	else if ((Installation::no_x11 () || Installation::text_fallback ()) && Stage::cont ())
	{
	    // The script YaST2 wants to inform about a problem with the
	    // option no_x11 but it's broken.
	    // else if (Installation::no_x11 ())

	    // Somehow the graphical frontend failed and we're running in
	    // text mode. Inform the user about this fact.
	    x11_msg = _("The graphical interface could not be started.

The required packages were not installed (minimal installation) or
the graphics card is not properly supported.

As a fallback, the text front-end of YaST2 will guide you
through the installation. This front-end offers the
same functionality as the graphical one, but the screens
differ from those in the manual.
");
	}

	Report::Message(x11_msg);

	// show this warning only once
	Installation::shown_text_mode_warning = true;
    }


    //--------------------------------------------------------------------

    // Some abbreviations to keep the table below less wide
    boolean autoinst	= Mode::autoinst ();
    boolean autoconf	= AutoInstall::autoconf;
    boolean test_mode	= Mode::test ();
    boolean update_mode	= Mode::update ();		// FIXME: work's only after reboot
    boolean repair	= Mode::repair ();
    boolean screen_shot_mode = Mode::screen_shot ();


    //////////////////////////////////////////////////////////////////
    // All settings the user does are saved into a map. The submodules
    // are called as functions and thus have access to this variable.
    // They return `next, `back, `cancel, `again or `auto.
    // A submodule that can't be loaded (syntax error) returns nil.

    any	    former_result = `next;
    integer m = 0;			// current module

    Wizard::SetFocusToNextButton();

    y2debug("Starting Workflow with  \"%1\" \"%2\"",  Stage::stage (), Mode::mode ());
    list<map> modules = ProductControl::getModules(
            Stage::stage (),
            Mode::mode (),
            `enabled);

    map defaults = ProductControl::getModeDefaults(Stage::stage (), Mode::mode ());

    y2debug("modules: %1", modules);

    // skip language dialog if selected in isolinux. (#37679)
    if (Stage::initial () && SCR::Read (.etc.install_inf.Language)!= nil)
    {
        string tmp_language = (string)SCR::Read (.etc.install_inf.Language);
        if ( tmp_language !="" && ProductFeatures::skip_language_dialog )
        {
            ProductControl::DisabledModules=add(ProductControl::DisabledModules,
            "language");
        }
    }

    while ((m >= 0) && (m < size(modules)))
    {
        map mod = modules[m]:$[];
        term argterm = ProductControl::getTerm( mod, defaults);
        boolean retranslate = mod["retranslate"]:false;

        boolean   do_continue           = false;

        if (!ProductControl::checkArch(mod, defaults))
        {
            y2milestone("continue (arch)..");
            do_continue = true;
        }

        if (ProductControl::checkDisabled(mod))
        {
            y2milestone("continue (status)..");
            do_continue = true;
        }

        if (!mod["update"]:true && Mode::update ())
        {
            y2milestone("continue (update)..");
            do_continue = true;
        }

        if ( do_continue )
        {
            if      (former_result == `next) m = m + 1;
            else                             m = m - 1;
        }
        if ( do_continue ) continue;

        y2milestone("Running module: %1 (%2)", argterm, m);
        argterm = add (argterm, former_result == `back);

        symbol module_name = symbolof( argterm );

        if ( module_name != `inst_doit )        // This is only a popup
        {
            Wizard::ClearContents();
        }

       // --------------------------------------
       // Call the wizard dialog

        y2milestone( "Calling %1", argterm );
        // entry hook, (""+symbol is a symbol->string conversion)
        Hooks::Checkpoint (sformat("%1", module_name), true);
        Hooks::Run (mod["name"]:"", true);

        list args = [];

        integer i = 0;
        while (i < size(argterm)) 
        {
            any def = nil;
            args[i] = argterm[i]:def;
            i = i + 1;
        }

	UI::WizardCommand(`SetCurrentStep( mod["id"]:"" ) );
        ProductControl::CurrentWizardStep = mod["id"]:"";

        symbol result = (symbol) WFM::CallFunction (substring(sformat("%1", module_name), 1), args);

        // Dont call hook scripts after installation is done. (#36831)
        if (m < size(modules) - 1)
        {
            Hooks::Run (mod["name"]:"", false );
        }
        else
        {
            y2milestone("Not running hooks at the end of the installation");
        }

        // This should be safe (#36831)
        Hooks::Checkpoint ( mod["name"]:"", false);          // exit hook

        if ( retranslate )   // language change very likely
        {
            retranslateWizardDialog();
            retranslate = false;
        }

        // If the module return nil, something basic went wrong.
        // We show a stub dialog instead.
        if (result == nil)
        {
            any r = nil;
            r = Popup::ModuleError(sformat("The module %1 does not work.", symbolof(argterm)));
            if      (r == `next)   m = m + 1;
            else if (r == `back)   m = m - 1;
            else if (r != `again)
            {
                UI::CloseDialog();
                return nil;
            }
            continue;
        }

        if      (result == `next)
        {
            m = m + 1;
        }
        else if (result == `back)
        {
            m = m - 1;
        }
        else if (result == `cancel)
        {
            break;
        }
        else if (result == `abort)
        {
            // Close Sources
            Pkg::SourceFinishAll ();
            Pkg::TargetFinish ();

            // tell linuxrc that we aborted
            Linuxrc::WriteYaSTInf($["Aborted" : "1"]);
            break;
        }
        else if (result == `finish)
        {
            break;
        }
        else if (result == `again)
        {
            continue; // Show same dialog again
        }
        else if (result == `auto)
        {
            if (former_result != nil)
            {
                if      (former_result == `next) m = m + 1;
                else if (former_result == `back) m = m - 1;
            }
            continue;
        }
        former_result = result;

    }

    // re-enable automatic probing
    if (!Mode::test ())
        WFM::Execute (.local.bash, "/bin/echo \"/sbin/modprobe\" >/proc/sys/kernel/modprobe");

    if (Stage::cont ())
    {
	// remove /etc/install.inf, not needed any more
	SCR::Execute (.target.remove, "/etc/install.inf");
	if (Mode::update ())
	{
	    SCR::Execute(.target.remove, "/var/lib/YaST2/update_mode");
	    SCR::Execute(.target.bash, "/bin/rm -rf /var/adm/current_package_descr");
	}
	SCR::Execute(.target.remove, "/var/lib/YaST2/runme_at_boot");

	if (WFM::Read (.local.size, "/usr/share/YaST2/clients/product_post.ycp") > 0)
	    WFM::CallFunction ("product_post", [Mode::update ()]);
    }

    // disable all sources and finish target
    Pkg::SourceFinishAll();
    Pkg::TargetFinish();

    UI::CloseDialog();

    if (m <= -1)	return `back;
    else		return `next;
}
