/**
 * File:	clients/inst_suseconfig.ycp
 * Package:	Installation
 * Summary:	Run SUSEconfig
 * Authors:	Andreas Schwab <schwab@suse.de>
 *		Stefan Hundhammer <sh@suse.de>
 *
 * $Id$
 *
 * Purpose:
 * - shows the "Finishing the installation" frame
 * - runs "SuSEconfig"
 * - runs "init" to reread inittab, which has been changed by SuSEconfig.
 * - shows the loginname which can be used.
 */

{

    textdomain "installation";

    import "Arch";
    import "Directory";
    import "Installation";
    import "Mode";
    import "Stage";
    import "Popup";
    import "Wizard";
    import "Kernel";


    if ( size( WFM::Args() ) > 2 && WFM::Args(2) == true )	// going backwards?
	return `auto;					// don't execute this once more

    boolean reread_inittab = false;

    integer	current_step	= 0;	// Required by logStep()

    string log_destination = ">> " + Directory::logdir + "/y2log.SuSEconfig";		// Required by doStep()

    if ( Stage::cont () )
    {
	reread_inittab = true;
    }

    /**
     * Display a step in the LogView widget and increment the progress bar.
     * Uses global variable 'current_step'.
     *
     * @param step_descr description of the step.
     */
    define void logStep( string step_descr ) ``{
	current_step = current_step + 1;
	UI::ChangeWidget( `id(`progress), `Value, current_step );
	UI::ChangeWidget( `id(`log), `LastLine, step_descr + "\n" );
    };


    /**
     * Run a step on the target and log its output to the globally specified
     * 'log_destination'.
     *
     * @param step command to execute in this step
     */
    define void runStep( string step ) ``{

	string command = sformat( "HOME=%1 %2 %3 2>&1", Directory::tmpdir, step, log_destination );
	// Setting $HOME to Directory::tmpdir to avoid cluttering '/' with spurious files - bug #13204

	if ( Mode::test () )
	{
	    y2milestone( "Test mode - NOT executing '%1'", command );
	    sleep( 300 );
	}
	else
	{
	    y2milestone( "Executing '%1'", command );
	    SCR::Execute( .target.bash, command );
	}
    };


    ////////////////////////////////////////////////////////////////////////////////
    //                      Main Dialog
    ////////////////////////////////////////////////////////////////////////////////


    /* Help text for SUSEconfig dialog */
    string help = _("<p><tt>SuSEconfig</tt> must write the configuration
of your &product; system. Depending on the CPU and the amount of memory,
this process can take some time.</p>
");


    list<string> modules = (list<string>) SCR::Read( .run.get.suseconfig.modules );
    integer max_steps = size( modules ) + 1; // + ldconfig

    if ( reread_inittab )
    {
	max_steps = max_steps + 1;		// restart 'init'
    }

    term contents = `VBox(
			  `LogView(`id(`log), "", 10, 0 ),

			  // Progress bar that displays overall progress in this dialog
			  `ProgressBar(`id(`progress), _("Progress"), max_steps, 0 )
			  );


    boolean back_ok = false;
    boolean next_ok = false;
    if (size (WFM::Args()) > 1)
    {
	back_ok = (boolean) WFM::Args(0);
	next_ok = (boolean) WFM::Args(1);
    }
    Wizard::SetContents(
			  // Dialog title for SuSEconfig dialog
			  _("Writing the system configuration"),
			  contents, help, back_ok, next_ok);
    Wizard::DisableAbortButton();


    // --------------------------------------------------------------
    // Put config of installed kernel into kernel sources

    y2debug( "Testmode: %1", Mode::test () );

    //
    // Preliminary 'ldconfig' - this takes a long time at first run.
    //
    // SusEconfig calls this internally, too, but we want to avoid giving the
    // impression the very first SuSEconfig module takes that long: It's
    // simply not true, it's 'ldconfig' that takes this long. So make this fact
    // transparent by explicitly calling it (and informing the user about that)
    // prior to calling any SuSEconfig module.
    //

    logStep( _("Setting up linker cache") );
    runStep( "/sbin/ldconfig" );

    // This is the same as:
    //    runStep( "/sbin/SuSEconfig --verbose --module aaa_at_first" );
    // but that "aaa_at_first" module will go away soon. Or so it is said. ;-)


    if ( Stage::initial () || Stage::cont ()
	 || tolower( (string) SCR::Read(.sysconfig.suseconfig.ENABLE_SUSECONFIG) ) == "yes" )
    {
	//
	// Call each SuSEconfig module individually
	//

	foreach (string mod, modules, ``{
	    // inform user about current SuSEconfig step
	    logStep( sformat (_("Running SuSEconfig.%1"), mod));
	    runStep( "/sbin/SuSEconfig --verbose --module "   + mod );
	});

	if ( ! Mode::test () )
	{
	    SCR::Execute (.target.remove, "/var/lib/YaST2/run_suseconfig");
	}


	//
	// Call "all the rest" of the SuSEconfig main program
	//

	// inform user that SuSEconfig has finished
	logStep( _("Finishing SuSEconfig") );
	runStep( "/sbin/SuSEconfig --verbose --nomodule" );
    }
    else
    {
	// inform user that SuSEconfig has been disabled
	logStep( _("SuSEconfig disabled in /etc/sysconfig/suseconfig") );
	y2milestone( "SuSEconfig disabled in /etc/sysconfig/suseconfig" );
    }



    //
    // Tell init to reread inittab which might have been changed by SuSEconfig.
    //

    if ( reread_inittab )
    {
	runStep( "/sbin/init q" );
    }


    // The final LogView line to be displayed after SuSEconfig etc. is done.
    UI::ChangeWidget( `id(`log), `LastLine, "\n" + _("Done.") + "\n" );


    if ( Mode::test () )
    {
	UI::MakeScreenShot();	// doesn't work manually - not widget with keyboard focus!
	sleep( 5*1000 );
    }

    if ( Kernel::get_inform_about_kernel_change () )
    {
	// inform the user that he/she has to reboot to activate new kernel
	Popup::Message(_("Reboot your system
to activate the new kernel.
"));
    }

    // ...
    // Migrate configuration from XFree86 3.x to XFree86 4.x
    // if possible
    // ---
    if ( Mode::update () )
    {
	integer flag = (integer)
	    SCR::Execute (.target.bash,
			  "/usr/bin/tail -n 1 /etc/X11/XF86Config | grep -q '#3x'"
			  );
	if (flag == 0)
	{
	    SCR::Execute (.target.bash, Directory::ybindir + "/xmigrate.pl");
	}
    }

    if ( Mode::update () )
    {
	return `next;
    }
    else
    {
	return `auto;
    }
}
