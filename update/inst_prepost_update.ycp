/**
 * Module: 		inst_prepost_update.ycp
 *
 * Authors:		Dan Vesely <dan@suse.cz>
 *
 * Purpose:
 * Keep sound configuration in '/etc/modules.conf' during update
 *
 * Provides two functions:
 *   pre_update_actions ()
 *   post_update_actions ()
 * 
 * $Id$
 */

{
    textdomain "update";
    define pre_update_actions ()
    ``{
 
    
    list aliases  = SCR::Read(.modules.alias);
    list options  = SCR::Read(.modules.options);
    list save     = [];		// structure to save

    if (contains (aliases, "char-major-116"))
    {
	// alsa modules
	
	
	if (SCR::Read(.modules.alias, "char-major-116") == "snd")
	{

	    save = add (save, $["name"   : "snd", 
			       "alias"   : "char-major-116", 
			       "options" : SCR::Read(.modules.options, "snd"),
			       "comment" : SCR::Read(.modules.alias.comment, "char-major-116")]);

	    list minor_list = [0, 1, 3, 8, 11, 12];		
	    integer cards   = tointeger (save[0, "options", $[], "snd_cards_limit", 1]:"0");	// FIXME
	    map entry       = $[];
	    integer i       = 0;
	    string alias    = "";
	    string module_name   = "";
	    string comment  = "";
	    list oss_compat = []; // keep this in a separate list

	    // read the cards
	    while (i < cards) {

		// == snd-card-X ==
		entry = $[];
		alias = sformat ("snd-card-%1", i);

		if (!contains(aliases, alias)) { i = i + 1; continue;} // not found
		
		module_name  = SCR::Read(.modules.alias, alias);
		comment = SCR::Read(.modules.alias.comment, alias);

		entry = add (entry, "name", module_name);
		entry = add (entry, "alias", alias);
		if (contains (options, module_name))
		{
		   entry = add (entry, "options", SCR::Read(.modules.options, module_name));
		}
		if (size (comment) > 0)
		{
		    entry = add (entry, "comment", comment);
		}
		
		save = add (save, entry);

		// == snd-slot-X ==
		entry = $[];
		alias = sformat ("sound-slot-%1", i);

		if (!contains(aliases, alias)) { i = i + 1; continue;} // not found
		
		module_name  = SCR::Read(.modules.alias, alias);
		comment = SCR::Read(.modules.alias.comment, alias);

		entry = add (entry, "name", module_name);
		entry = add (entry, "alias", alias);
		if (contains (options, module_name)) entry = add (entry, "options", SCR::Read(.modules.options, module_name));
		if (size (comment) > 0) entry = add (entry, "comment", comment);
		
		oss_compat = add (save, entry);
		
		
		// read the rest (services - oss compat)
		maplist (`minor, minor_list, ``{
		    entry = $[];
		    alias = sformat ("sound-service-%1-%2", i, minor);
		    
		    if (contains (aliases, alias))
		    {
			module_name = SCR::Read(.modules.alias, alias);
			comment = SCR::Read(.modules.alias.comment, alias);
			
			entry = add (entry, "name", module_name);
			entry = add (entry, "alias", alias);
			if (contains (options, module_name)) entry = add (entry, "options", SCR::Read(.modules.options, module_name));
			if (size (comment) > 0) entry = add (entry, "comment", comment);
			
			oss_compat = add (oss_compat, entry);			
		    }
		});

		i = i + 1;
	    }

	    save = union (save, oss_compat);
	}
    }
    else if (contains (aliases, "char-major-14"))
    {
	// oss (poor support, should be enhanced ... )
	
	// list of aliases to be read
	list aliases = ["char-major-14",
		       "sound",
		       "midi",
		       "sound-slot-0",
		       "sound-service-0-0"];

	map entry      = $[];
	map option     = $[];
	string module_name  = "";
	string comment = "";
	
	maplist (`alias, aliases,
	``{
	    if (contains (aliases, alias))
	    {
		entry   = $[];
		module_name  = SCR::Read(.modules.alias, alias);
		comment = SCR::Read(.modules.alias.comment, alias);
		if (contains (options, module_name))
		{
		    option = SCR::Read(.modules.options, module_name);
		}
		else
		{
		    option = $[];
		}
		if (size (module_name) > 0)
		{
		    entry = add (entry, "alias", alias);
		    entry = add (entry, "name", module_name);
		    if (size (option) > 0)
			entry = add (entry, "options", option);
		    if (size (comment) > 0)
			entry = add (entry, "comment", comment);
		}
		
		if (size (entry) > 0)
		    save = add (save, entry);
	    }
	});
    }

    return SCR::Write(.dumpto.var.lib.YaST2.updateSound, save);

    } // pre_update_actions

    define post_update_actions ()
    ``{

    map options    = $[];
    string comment = "";
    string alias   = "";
    string module_name  = "";
    boolean ret    = true;

    list save = SCR::Read(.target.ycp, Installation::yast2dir + "/updateSound");

    if (save == nil) return false; // saved info not found

    maplist (`e, save, ``{
	alias   = lookup(e, "alias", "");
	module_name    = lookup(e, "name", "");
	options = lookup (e, "options", $[]);
	comment = lookup (e, "comment", "");

	if (size (alias) > 0)
	{
	    if (size (module_name) > 0) ret = ret && SCR::Write(.modules.alias, module_name, alias);
	    if (size (options) > 0) ret = ret && SCR::Write(.modules.options, options, lookup (e, "alias", ""));
	    if (size (comment) > 0) ret = ret && SCR::Write(.modules.alias.comment, comment, lookup (e, "alias", ""));
	}
    });

    return ret && SCR::Write(.modules, nil);
    } // post_update_actions
}
