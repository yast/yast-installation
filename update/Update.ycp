/**
 * Module:		Update.ycp
 *
 * Authors:		Anas Nashif (nashif@suse.de)
 *
 * Purpose:		Update module
 *
 *
 * $Id$
 */
{
    module "Update";

    global integer affected_count = 0;
    // number of packages affected by update

    global string newKernel = "";
    // update kernelname if there has not been found a old kernel
    // in the db.

    global list manuall_update_list = [];
    // List of packages which have to decide the user

    global list unmaintained_list = [];
    // List of packages which are not maintained

    global boolean deleteOldPackages = false;
    // Flag is set true if the user decides to delete unmaintained packages

    global integer last_runlevel = -1;

    global  list notDeletedPackages = [];

    global list notInsertedPackages = [];

    global string selectedRootPartition = "";
    // selected rootpartition for the update

    global map validRootPartitions = $[];
    // available rootpartitions (key) and SuSE versions (value)

    global boolean onlyUpdateSelected = false;
    // Only an update, NOT an upgrade

    global boolean updateEvaluated = false;
    // Flag if the updatelist has already evaluated

    global string installedVersion = "";
    // Version of the targetsystem

    global string updateVersion = "";
    // Version of the source medium

    global boolean updateBasePackages = false;
    // Flag, if the basesystem have to be installed

    global integer packagesInstalled = 0;
    // counter for installed packages

    /**
     * List of mounted partitions, activated swap partitions and loop devices.
     * Used for reversing action if mode is changed from update to new
     * installation or if root directory for update is changed. Each item is
     * list [string value, string type], where type is "mount", "swap", "loop",
     * value is path to mounted directory, swap partition name or loop device
     * name according to type value.
     */
    list activated = [];

    /*-----------------------------------------------------------------------
     * GLOBAL FUNCTIONS
     *-----------------------------------------------------------------------*/

    /**
     * Unmount all mounted partitions, deactivate swaps, detach loopback
     * devices. Uses list activated to make actions in reverse order.
     * @return void
     */
    global define void UnmountPartitions() ``{
	 y2milestone("Unmount partitions: %1", activated);

	 foreach(list info, activated, ``{
		string file = info[0]:"";
		string type = info[1]:"";

		if (file != "" && type != "")
		{
		    if (type == "mount")
		    {
			if (SCR::Execute (.target.umount, file) != 0)
			{
			    y2error("Cannot unmount partition %1", file);
			}
		    }
		    else if (type == "swap")
		    {
			if (SCR::Execute (.target.bash, "/sbin/swapoff " + file) != 0)
			{
			    y2error("Cannot deactivate swap %1", file);
			}
		    }
		    else if (type == "loop")
		    {
			if (WFM::Execute(.local.bash, "losetup -d " + file) != 0)
			{
			    y2error("Cannot deactivate loopback device %1", file);
			}
		    }
		}
	    }
	);

        SCR::Write(.lvm.deactivate, "");
	SCR::Write(.md.deactivate, "");

	// clear activated list
	activated = [];
    };

    /**
     * Add information about mounted partition to internal list.
     * @param partinfo partinfo has to be list with exactly two strings, see description of list "activated"
     * @return void
     */
    global define void AddMountedPartition(list partinfo) ``{
	y2debug("Added partition info: %1", partinfo);
	activated = prepend(activated, partinfo);
	y2debug("Total partition info: %1", activated);
    }

    /**
     * Restore()
     * Restore saved package list
     * @return void
     *
     */

    global define void Restore()
    ``{
	// TODO remove this later ??
	Pkg::InitTarget("/", false);

	if (!Mode::test)
	{
	    notDeletedPackages = SCR::Read (.target.ycp,
					    [Installation::yast2dir + "/notDeletedPackages.ycp",
					     []]);
	}
	else
	{
	    notDeletedPackages = SCR::Read (.target.ycp,
					    ["/tmp/notDeletedPackages.ycp",
					     []]);
	}

	if (!Mode::test)
	{
	    notInsertedPackages = SCR::Read (.target.ycp,
					     [Installation::yast2dir + "/notInsertedPackages.ycp",
					      []]);
	}
	else
	{
	    notInsertedPackages = SCR::Read (.target.ycp,
					     ["/tmp/notInsertedPackages.ycp",
					      []]);
	}

	list update_list = [];

	if (!Mode::test)
	{
	    update_list = SCR::Read (.target.ycp,
				     [Installation::yast2dir + "/pacs_to_update.ycp",
				      []]);
	}
	else
	{
	    update_list = SCR::Read (.target.ycp,
				     ["/tmp/pacs_to_update.ycp",
				      []]);
	}

	// TODO FIXME: use Pkg::
	// SCR::Execute (.package.setUpdateSelection, update_list );

	packagesInstalled = SCR::Read (.target.ycp,
			       [Installation::yast2dir+"/package_counter.ycp",
			       0] );

	y2milestone("Restored updatelist list");
	return;
    }

    /**
     * Save()
     * Used in inst_finish.ycp
     *
     */

    global define void Save()
    ``{
	if (!Mode::test)
	{
	    SCR::Write (.target.ycp,
			Installation::destdir +
			Installation::yast2dir+
			"/notDeletedPackages.ycp",
			notDeletedPackages );
	}
	else
	{
	    SCR::Write (.target.ycp,
			"/tmp"+
			"/notDeletedPackages.ycp",
			notDeletedPackages );
	}

	if (!Mode::test)
	{
	    SCR::Write (.target.ycp,
			Installation::destdir +
			Installation::yast2dir+
			"/notInsertedPackages.ycp",
			notInsertedPackages );
	}
	else
	{
	    SCR::Write (.target.ycp,
			"/tmp"+
			"/notInsertedPackages.ycp",
			notInsertedPackages );
	}


	list update_list = SCR::Read (.package.updatePackageNames);

	if (!Mode::test)
	{
	    SCR::Write (.target.ycp,
			Installation::destdir +
			Installation::yast2dir+
			"/pacs_to_update.ycp",
			update_list );
	}
	else
	{
	    SCR::Write (.target.ycp,
			"/tmp"+
			"/pacs_to_update.ycp",
			update_list );
	}

	SCR::Write (.target.ycp,
		    Installation::destdir +
		    Installation::yast2dir+"/package_counter.ycp",
		    packagesInstalled );

	return;
    }


}


