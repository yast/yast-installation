/**
 * File:	modules/ProductControl.ycp
 * Package:	installation
 * Summary:	Product Control routines
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 */
{
module "ProductControl";

import "XML";
import "Product";
import "ProductFeatures";
import "Mode";
import "Arch";

// current proposal label
global string current_proposal_label = "";


// The complete parsed control file
global map productControl = $[];

// all workflows
global list<map> workflows = [];

// all proposals
global list<map> proposals = [];

// Flexible partitioning map. XML represenation of the the part.info file
global map partitioning = $[];

// Software configuration
global map software = $[];

// Software configuration
global map<string, any> globals = $[];

// The custom control file location, usually copied from
// the root of the CD to the installation directory by linuxrc
global string default_control_file = "/control.xml";

// The file above get saved into the installed system for later
// processing
global string saved_control_file = "/var/lib/YaST2/control.xml";

// The packaged file which contains all default worklfows
global string packaged_control_file = "/usr/share/YaST2/control/control.xml";

// The control file we are using for this session.
global string current_control_file = "";



// Current Wizard Step
global string CurrentWizardStep = "";


// Last recently used stage_mode for RetranslateWizardSteps
global list<map> last_stage_mode = [];


// List of module to disable in the current run
global list<string> DisabledModules = [];


global list<string> logfiles = [];


/**
 * Check if a module is disabled
 * @param map module map
 * @return boolean
 */
global define boolean checkDisabled (map mod ) {
    if (contains(DisabledModules, mod["name"]:""))
    {
        return true;
    }
    return false;
}

/**
  * Read XML Control File
  * @param string control file
  * @return boolean
  */
global define boolean Read( string controlfile) ``{

    productControl = XML::XMLToYCPFile(controlfile);
    workflows = productControl["workflows"]:[];
    proposals = productControl["proposals"]:[];

    if (haskey(productControl, "partitioning"))
    {
        if (size( productControl["partitioning", "partitions"]:[] ) > 0)
        {
            partitioning = productControl["partitioning"]:$[];
            ProductFeatures::flexible_partitioning = true;
            ProductFeatures::FlexiblePartitioning = partitioning;
        }
        if (productControl["partitioning", "evms_config"]:false)
        {
            ProductFeatures::evms_config = true;
        }
    }
    if (haskey(productControl, "software"))
    {
        software = productControl["software"]:$[];
        ProductFeatures::base_selection_choice = software["selection_type"]:`auto;
        if (size(software["base_selection"]:"") > 0 )
        {
            ProductFeatures::fixed_base_selection = software["base_selection"]:"Minimal";
        }
        // Default is true
        ProductFeatures::delete_old_packages = software["delete_old_packages"]:true;
        ProductFeatures::onlyUpdateInstalled =
            software["only_update_installed"]:false;

        // What is the software proposal based on?
        // Possible values: selection|desktop
        //
        ProductFeatures::software_proposal =
            software["software_proposal"]:"selection";

        // TODO: Temporary workaround. This should be checked in the control file
        if (Arch::i386 && issubstring(Product::distproduct, "DVD"))
        {
            ProductFeatures::inform_about_suboptimal_distribution =
            software["inform_about_suboptimal_distribution"]:false;
        }
    }
    if (haskey(productControl, "globals"))
    {
        globals = productControl["globals"]:$[];
        ProductFeatures::enable_autologin = globals["enable_autologin"]:true;
        ProductFeatures::language = globals["language"]:"";
        ProductFeatures::keyboard = globals["keyboard"]:"";
        ProductFeatures::timezone = globals["timezone"]:"";
        ProductFeatures::ui_mode = globals["ui_mode"]:"expert";
        ProductFeatures::use_desktop_scheduler =
            globals["use_desktop_scheduler"]:true;
        ProductFeatures::io_scheduler =
            globals["io_scheduler"]:"as";
    }

    return true;
}



boolean Check(string allowed, string current)
{
    list<string> allowedlist = filter(string s,
            splitstring(deletechars(allowed, " "), ","), ``(s!=""));
    y2debug("allowedlist: %1", allowedlist );
    y2debug("current: %1", current );
    if (size(allowedlist) == 0 )
        return true;
    else if (contains(allowedlist, current ))
        return true;
    else
        return false;
}


/**
  * ProductControl Constructor
  * @return void
  */
global define void ProductControl() ``{

    // FIXME: Hack, with fixed names. Should be changed after SLES.
    // #41696: Default control file is the one from 9.1. This is
    // only a fallback solution if someone forgets the control.xml
    // file in the installation source. Can happen with alot of
    // customers used to older products.
    if (issubstring(Product::name, "SLES"))
    {
        packaged_control_file = "/usr/share/YaST2/control/control.SLES.xml";
    }
    boolean ret = false;
    current_control_file = "";
    list<string> order =
        [
	 default_control_file,  // "/control.xml"
	 saved_control_file, // "/var/lib/YaST2/control.xml"
	 packaged_control_file // "/usr/share/YaST2/control/control.xml"
	 ];
    foreach(string cf, order, ``{
	if ((integer)SCR::Read( .target.size, cf )>0
            && current_control_file == "")
	{
	    current_control_file = cf;
	}
    });

    // Just to be sure..
    if (current_control_file == "")
    {
        current_control_file = packaged_control_file; // /usr/share/YaST2/control/control.xml
    }

    y2milestone("Reading controlfile: %1", current_control_file );
    Read( current_control_file );
    return;
}

/**
 * Check if valid architecture
 * @param map module data
 * @param map default data
 * @return boolean true if arch match
 */
global define boolean checkArch(map mod , map def) ``{
    y2milestone("mod: %1", mod);
    string archs = mod["archs"]:"";
    if (archs == "")
    {
        archs=def["archs"]:"all";
    }

    if (archs == "all") {
        return true;
    }

    y2milestone("short arch desc: %1", Arch::arch_short );
    y2milestone("supported archs: %1", archs );
    if (issubstring(archs,Arch::arch_short))
    {
        return true;
    }

    return false;
};



/**
 * Return term to be used to run module
 * @param map module data
 * @param map default data
 * @return term module data with params
 */
global define term getTerm (map mod, map def) ``{
    // All client start with "inst_".

    string client = "";
    if (issubstring(mod["name"]:"dummy", "inst_"))
        client = mod["name"]:"dummy";
    else
        client = "inst_" + mod["name"]:"dummy";


    term a = toterm(client);
    string arguments = mod["arguments"]:"";
    list<string> args = splitstring(arguments, ",");
    if (size(args) == 0 )
    {
        args = splitstring(def["arguments"]:"", ",");
    }
    foreach(string arg, args,
            ``{
            if (arg == "true")
            {
            a=add(a, true);
            }
            else if (arg == "false") {
            a=add(a, false);
            }
            else if (findfirstof(arg, "`") != nil)
            {
            if (findfirstof(arg, "`") == 0)
            {
            term s = toterm(substring(arg,1));
            symbol ss = symbolof(s);
            a=add(a, ss);
            }
            }
            else
            {
            a=add(a,arg);
            }
            });
    return a;
}


/**
 * Get workflow defaults
 * @param string stage
 * @param string mode
 * @return map defaults
 */
global define map getModeDefaults(string stage, string mode)
``{
    map workflow = (map)select(filter(map wf, workflows, ``(
                Check(wf["stage"]:"", stage) && Check(wf["mode"]:"", mode )
                    )), 0 , $[] );
    return workflow["defaults"]:$[];
}

void PrepareScripts(map m) {
    string tmp_dir = (string)WFM::Read(.local.tmpdir, []);
    if (haskey(m,"prescript"))
    {
        string interpreter = m["prescript", "interpreter"]:"shell";
        string source = m["prescript", "source"]:"";
        string type = (interpreter == "shell") ? "sh" : "pl";
        string f = sformat("%1/%2_pre.%3", tmp_dir, m["name"]:"", type);
        WFM::Write(.local.string,f , source);
        logfiles = add(logfiles, sformat("%1.log", sformat("%1_pre.%2",
                        m["name"]:"", type)));
    }
    if (haskey(m,"postscript"))
    {
        string interpreter = m["postscript", "interpreter"]:"shell";
        string source = m["postscript", "source"]:"";
        string type = (interpreter == "shell") ? "sh" : "pl";
        string f = sformat("%1/%2_post.%3", tmp_dir, m["name"]:"", type);
        WFM::Write(.local.string, f, source);
        logfiles = add(logfiles, sformat("%1.log", sformat("%1_post.%2",
                         m["name"]:"", type)));
    }
    return;
}
/**
 * Get modules of current Workflow
 * @param string stage
 * @param string mode
 * @return list<map> modules
 */
global define list<map> getModules(string stage, string mode)
``{
    map workflow = select(filter(map wf, workflows, ``(
                Check(wf["stage"]:"",stage) && Check(wf["mode"]:"", mode )
                    )), 0 , $[] );
    list<map> modules = workflow["modules"]:[];
    integer id = 1;
    modules = maplist(map m, modules, ``{
            m["id"] = sformat("%1_%2", stage, id);
            PrepareScripts(m);
            id = id + 1;
            return (m);
            });
    y2debug("Log files: %1", logfiles);
    return modules;
}

/**
 * Get Workflow Label
 * @param string stage
 * @param string mode
 * @return string
 */
global define string getWorkflowLabel(string stage, string mode)
``{
    map workflow = select(filter(map wf, workflows, ``(
                Check(wf["stage"]:"",stage) && Check(wf["mode"]:"",mode)
                    )), 0 , $[] );
    return workflow["label"]:"";

}



/**
 * Add Wizard Steps
 *
 */
global define void AddWizardSteps(list<map> stagemode) ``{
    last_stage_mode = stagemode;

    // UI::WizardCommand() can safely be called even if the respective UI
    // doesn't support the wizard widget, but for optimization it makes sense
    // to do expensive operations only when it is available.

    // if ( ! UI::HasSpecialWidget(`Wizard ) )
    // return;

    string wizard_textdomain = (string) productControl["textdomain"]:"control";
    y2debug( "Using textdomain '%1' for wizard steps", wizard_textdomain );

    string first_id = "";
    // UI::WizardCommand(`SetVerboseCommands( true ) );
    foreach (map sm , stagemode, ``{
	y2debug( "Adding wizard steps for %1", sm );
	string slabel = getWorkflowLabel(sm["stage"]:"", sm["mode"]:"");
	if ( slabel != "" )
	    UI::WizardCommand(`AddStepHeading( dgettext( wizard_textdomain, slabel ) ) );
	foreach(map m, getModules(sm["stage"]:"", sm["mode"]:""), ``{
	    y2debug("Adding wizard step: %1", m );
	    if (m["label"]:"" != "") {
		if (first_id=="")
		{
		    first_id = m["id"]:"";
		}
		UI::WizardCommand(`AddStep( dgettext( wizard_textdomain, m["label"]:"" ), m["id"]:"" ) );
	    }
	});
    });

    UI::WizardCommand(`SetCurrentStep( first_id ) );
    return;
}



/**
 * Update Steps
 */
global define void UpdateWizardSteps(list<map> stagemode) ``{
    last_stage_mode = stagemode;

    UI::WizardCommand(`DeleteSteps());
    AddWizardSteps( stagemode );
    UI::WizardCommand(`UpdateSteps());
    UI::WizardCommand(`SetCurrentStep( CurrentWizardStep ) );
    return;
}


global define void RetranslateWizardSteps() ``{
    if ( size( last_stage_mode ) > 0 )
    {
	y2debug( "Retranslating wizard steps" );
	UpdateWizardSteps( last_stage_mode );
    }
};


/**
 * Get modules of current Workflow
 * @param string stage
 * @param string mode
 * @return list<string> modules
 */
global define list<string> getProposals(string stage, string mode, string proptype)
``{
    // First we search for proposals for current stage if there are
    // any. (initial or continue)

    list<map> props = filter(map p, proposals, ``(Check(p["stage"]:"", stage)));

    // Then we check for mode: installation or update
    props = filter(map p, props, ``(
                    Check(p["mode"]:"", mode)));

    // Now we check for architecture
    y2debug("Architecture: %1", Arch::architecture );
    list<map> arch_proposals = filter(map p, props, ``(
                p["type"]:"" == proptype &&
                issubstring(p["archs"]:"dummy", Arch::arch_short )));

    y2debug("arch proposals: %1", arch_proposals );
    props = filter(map p, props, ``(
                    p["archs"]:"" == "all" || !haskey(p, "archs") ));


    // If architecture specific proposals available, we continue with those
    // and check for proposal type, else we continue with pre arch proposal
    // list
    if (size(arch_proposals) > 0 )
    {
        props = filter(map p, arch_proposals, ``(
                     p["type"]:"" == proptype ));

    }
    else
    {
        props = filter(map p, props, ``(
                     p["type"]:"" == proptype ));
    }
    if (size(props)> 1 )
    {
        y2error("Something Wrong happened, more than one proposal after filter:
                %1", props);
    }

    // All proposal file names end with _proposal
    list<string> final_proposals = maplist(string p, props[0, "proposal_modules"]:[], ``{
            if (!issubstring(p, "_proposal"))
                return(p + "_proposal");
            else
                return(p);

            });
    string proposal_textdomain = (string)
           productControl["textdomain"]:"control";

    y2debug( "Using textdomain '%1' for proposals", proposal_textdomain);
    current_proposal_label = dgettext( proposal_textdomain , props[0, "label"]:"" );
    y2milestone("Proposal label: %1", current_proposal_label );

    return final_proposals;
}



// EOF
}
