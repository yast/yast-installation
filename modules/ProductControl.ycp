/**
 * File:	modules/ProductControl.ycp
 * Package:	installation
 * Summary:	Product Control routines
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 */
{
module "ProductControl";

import "XML";
import "Product";
import "ProductFeatures";
import "Mode";
import "Arch";

// The complete parsed control file
global map productControl = $[];

// all workflows
global list<map> workflows = [];

// all proposals
global list<map> proposals = [];

// Flexible partitioning map. XML represenation of the the part.info file
global map partitioning = $[];

// Software configuration
global map software = $[];

// Software configuration
global map<string, any> globals = $[];

// The custom control file location, usually copied from
// the root of the CD to the installation directory by linuxrc
global string default_control_file = "/control.xml";

// The file above get saved into the installed system for later
// processing
global string saved_control_file = "/var/lib/YaST2/control.xml";

// The packaged file which contains all default worklfows
global string packaged_control_file = "/usr/share/YaST2/control/control.xml";

// The control file we are using for this session.
global string current_control_file = "";



// Current Wizard Step
global string CurrentWizardStep = "";

/**
  * Read XML Control File
  * @param string control file
  * @return boolean
  */
global define boolean Read( string controlfile) ``{

    productControl = XML::XMLToYCPFile(controlfile);
    workflows = productControl["workflows"]:[];
    proposals = productControl["proposals"]:[];

    if (haskey(productControl, "partitioning") &&
            size( productControl["partitioning", "partitions"]:[] ) > 0)
    {
        partitioning = productControl["partitioning"]:$[];
        ProductFeatures::flexible_partitioning = true;
        ProductFeatures::FlexiblePartitioning = partitioning;
    }
    if (haskey(productControl, "software"))
    {
        software = productControl["software"]:$[];
        ProductFeatures::base_selection_choice = software["selection_type"]:`auto;
        if (size(software["base_selection"]:"") > 0 )
        {
            ProductFeatures::fixed_base_selection = software["base_selection"]:"Minimal";
        }
        // Default is true
        ProductFeatures::delete_old_packages = software["delete_old_packages"]:true;
    }
    if (haskey(productControl, "globals"))
    {
        globals = productControl["globals"]:$[];
        ProductFeatures::enable_autologin = globals["enable_autologin"]:true;
    }

    // FIXME: Handle reading errors
    return true;
}




boolean Check(string allowed, string current) {
    list<string> allowedlist = filter(string s, splitstring(deletechars(allowed, " "), ","), ``(s!=""));
    y2debug("allowedlist: %1", allowedlist );
    y2debug("current: %1", current );
    if (size(allowedlist) == 0 )
        return true;
    else if (contains(allowedlist, current ))
        return true;
    else
        return false;
}


/**
  * ProductControl Constructor
  * @return void
  */
global define void ProductControl() ``{


    boolean ret = false;
    if (Mode::initial)
    {
        ret = (integer)SCR::Read( .target.size, default_control_file )>0;
    }
    else if (Mode::cont)
    {
        ret = (integer)SCR::Read( .target.size, saved_control_file )>0;
    }

    if (!ret)
    {
        current_control_file = packaged_control_file;
    }
    else
    {
        if (Mode::initial)
            current_control_file = "/control.xml";
        else
            current_control_file = saved_control_file;
    }
    y2milestone("Reading controlfile: %1", current_control_file );
    Read( current_control_file );
}

/**
 * Check if valid architecture
 * @param map module data
 * @param map default data
 * @return boolean true if arch match
 */
global define boolean checkArch(map mod , map def) ``{
    y2milestone("mod: %1", mod);
    string archs = mod["archs"]:"";
    if (archs == "")
    {
        archs=def["archs"]:"all";
    }

    if (archs == "all") {
        return true;
    }

    y2milestone("short arch desc: %1", Arch::arch_short );
    y2milestone("supported archs: %1", archs );
    if (issubstring(archs,Arch::arch_short))
    {
        return true;
    }

    return false;
};



/**
 * Return term to be used to run module
 * @param map module data
 * @param map default data
 * @return term module data with params
 */
global define term getTerm (map mod, map def) ``{
    // All client start with "inst_".

    string client = "";
    if (issubstring(mod["name"]:"dummy", "inst_"))
        client = mod["name"]:"dummy";
    else
        client = "inst_" + mod["name"]:"dummy";


    term a = toterm(client);
    string arguments = mod["arguments"]:"";
    list<string> args = splitstring(arguments, ",");
    if (size(args) == 0 )
    {
        args = splitstring(def["arguments"]:"", ",");
    }
    foreach(string arg, args,
            ``{
            if (arg == "true")
            {
            a=add(a, true);
            }
            else if (arg == "false") {
            a=add(a, false);
            }
            else if (findfirstof(arg, "`") != nil)
            {
            if (findfirstof(arg, "`") == 0)
            {
            term s = toterm(substring(arg,1));
            symbol ss = symbolof(s);
            a=add(a, ss);
            }
            }
            else
            {
            a=add(a,arg);
            }
            });
    return a;
}


/**
 * Get workflow defaults
 * @param string stage
 * @param string mode
 * @return map defaults
 */
global define map getModeDefaults(string stage, string mode)
``{
    map workflow = (map)select(filter(map wf, workflows, ``(
                Check(wf["stage"]:"", stage) && Check(wf["mode"]:"", mode )
                    )), 0 , $[] );
    return workflow["defaults"]:$[];
}

/**
 * Get modules of current Workflow
 * @param string stage
 * @param string mode
 * @return list<map> modules
 */
global define list<map> getModules(string stage, string mode)
``{
    map workflow = select(filter(map wf, workflows, ``(
                Check(wf["stage"]:"",stage) && Check(wf["mode"]:"", mode )
                    )), 0 , $[] );
    list<map> modules = workflow["modules"]:[];
    integer id = 1;
    modules = maplist(map m, modules, ``{
            m["id"] = sformat("%1_%2", stage, id);
            id = id + 1;
            return (m);
            });
    return modules;
}

/**
 * Get Workflow Label
 * @param string stage
 * @param string mode
 * @return string
 */
global define string getWorkflowLabel(string stage, string mode)
``{
    map workflow = select(filter(map wf, workflows, ``(
                Check(wf["stage"]:"",stage) && Check(wf["mode"]:"",mode)
                    )), 0 , $[] );
    return workflow["label"]:"";

}


/**
 * Add Wizard Steps
 *
 */
global define void AddWizardSteps(list<map> stagemode) ``{
    string first_id = "";
    foreach (map sm , stagemode, ``{
            string slabel = getWorkflowLabel(sm["stage"]:"", sm["mode"]:"");
            UI::WizardCommand(`AddStepHeading( slabel ) );
            foreach(map m, getModules(sm["stage"]:"", sm["mode"]:""), ``{
                y2debug("adding step: %1", m );
                if (m["label"]:"" != "") {
                if (first_id=="")
                {
                first_id = m["id"]:"";
                }
                UI::WizardCommand(`AddStep( m["label"]:"",     m["id"]:"" ) );
                }
                });
            });

    UI::WizardCommand(`SetCurrentStep( first_id ) );
    return;
}


/**
 * Update Steps
 */
global define void UpdateWizardSteps(list<map> stagemode) ``{
    UI::WizardCommand(`DeleteSteps());
    AddWizardSteps( stagemode );
    UI::WizardCommand(`UpdateSteps());
    UI::WizardCommand(`SetCurrentStep( CurrentWizardStep ) );
    return;
}


/**
 * Get modules of current Workflow
 * @param string stage
 * @param string mode
 * @return list<string> modules
 */
global define list<string> getProposals(string stage, string mode, string proptype)
``{
    // First we search for proposals for current stage if there are
    // any. (initial or continue)

    list<map> props = filter(map p, proposals, ``(Check(p["stage"]:"", stage)));

    // Then we check for mode: installation or update
    props = filter(map p, props, ``(
                    Check(p["mode"]:"", mode)));

    // Now we check for architecture
    y2debug("Architecture: %1", Arch::architecture );
    list<map> arch_proposals = filter(map p, props, ``(
                    issubstring(p["archs"]:"dummy", Arch::arch_short )));

    y2debug("arch proposals: %1", arch_proposals );
    props = filter(map p, props, ``(
                    p["archs"]:"" == "all" || !haskey(p, "archs") ));


    // If architecture specific proposals available, we continue with those
    // and check for proposal type, else we continue with pre arch proposal
    // list
    if (size(arch_proposals) > 0 )
    {
        props = filter(map p, arch_proposals, ``(
                     p["type"]:"" == proptype ));

    }
    else
    {
        props = filter(map p, props, ``(
                     p["type"]:"" == proptype ));
    }
    if (size(props)> 1 )
    {
        y2error("Something Wrong happened, more than one proposal after filter:
                %1", props);
    }

    // All proposal file names end with _proposal
    list<string> final_proposals = maplist(string p, props[0, "proposal_modules"]:[], ``{
            if (!issubstring(p, "_proposal"))
                return(p + "_proposal");
            else
                return(p);

            });

    return final_proposals;
}



// EOF
}
