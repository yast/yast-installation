/**
 * File:
 *	ModulesConf.ycp
 *
 * Module:
 *	ModulesConf
 *
 * Authors:
 *	Klaus Kaempf (kkaempf@suse.de)
 *
 * Summary:
 *	All modules.conf related functions are here
 *
 * $Id$
 */
{
    module "ModulesConf";

    import "Arch";
    import "Misc";

    textdomain "installation";

    map modules = $[];

    /**
     * ModuleArgs
     * save arguments for a kernel module
     * @param name	string, name of kernel module
     * @param arg	string, arguments ("opt1=val1 opt2=val2 ...")
     *
     */
    global define void ModuleArgs (string name, string arg)
    ``{
	if (name == "")
	    return;

	map moduledata = modules[name]:$[];
	if (arg != "")
	{
	    moduledata["options"] = arg;
	}
	modules[name] = moduledata;

	return;
    }


    /**
     * RunDepmod
     * runs /sbin/depmod
     * !! call only when SCR runs on target !!
     */
    global define void RunDepmod ()
    ``{
	import "Kernel";

	string kernel_version = SCR::Read (.boot.vmlinuz_version, ["/boot/" + Kernel::binary]);

	y2milestone ("running /sbin/depmod");

	if (size (kernel_version) > 0)
	{
	    SCR::Execute(.target.bash, "unset MODPATH; /sbin/depmod -a -F /boot/System.map-"+kernel_version+" "+kernel_version);
	}
	else
	{
	    SCR::Execute(.target.bash, "unset MODPATH; /sbin/depmod -a -F /boot/System.map-`uname -r` `uname -r`");
	}
    }


    /**
     * Save
     * save module names and arguments to /etc/modules.conf
     * !! call only when SCR runs on target !!
     *
     * TODO: at a flag to run depmod unconditionally and use it in inst_finish
     */
    global define void Save ()
    ``{
	list module_names = StorageControllers::moduleNames;
	list module_args = StorageControllers::moduleArgs;

	// make module names to one long string
	// start with modules from linuxrc

	// write module options to modules.conf, mk_initrd handles the rest

	boolean modules_conf_changed = false;

	foreach (`mname, `mdata, modules,
	``{
	    string options = mdata["options"]:"";

	    if (options != "")
	    {
		// we have options, pass them to modules.conf

		map current_options = SCR::Read (.modules.options, mname);

		map new_options = Misc::MergeOptions (options, current_options);

		modules_conf_changed = true;

		SCR::Write (.modules.options, new_options, mname);
	    }
	});

	//////////////////////////////////////////////////////////////
	// Attention: for s390 inst_s390netadopt inserts alias modules

	if (!Arch::s390)
	{
	    string install_alias = SCR::Read (.etc.install_inf.Alias);
	    if (install_alias != nil)
	    {
		list install_alias_split = splitstring (install_alias, " ");
		if (size (install_alias_split) == 2)
		{
		    SCR::Write (.modules.alias, install_alias_split[1]:"",
				install_alias_split[0]:"");
		    modules_conf_changed = true;
		}
	    }
	}

	// if needed, re-write /etc/modules.conf and run /sbin/depmod

	if (modules_conf_changed)
	{
	    SCR::Write (.modules, nil);

	    if (!Mode::test)
	    {
		RunDepmod ();
	    }
	}
    }

}
