/**
 * File:	clients/inst_proposal.ycp
 * Module:	Installation
 * Summary:	Create and display proposal
 * Authors:	Stefan Hundhammer <sh@suse.de>
 *		Arvin Schnell <arvin@suse.de>
 *
 * $Id$
 *
 * Create and display reasonable proposal for basic
 * installation and call sub-workflows as required
 * on user request.
 *
 * See also file proposal-API.txt for details.
 */

{
    textdomain "installation";

    import "Arch";
    import "Mode";
    import "Installation";
    import "AutoInstall";
    import "Wizard";
    import "HTML";
    import "Popup";


    // values used in defined functions

    list	submodules = [];
    list	titles     = [];
    map		submod2id  = $[];
    map		id2submod  = $[];
    boolean	have_blocker = false;
    symbol	proposal_mode = nil;

    // skip if not interactive mode.
    if (!AutoInstall::interactive && Mode::autoinst) {
	return `auto;
    }

    /**
     * Display preformatted proposal in the RichText widget
     *
     * @param proposal human readable proposal preformatted in HTML
     **/

    define void display_proposal( string proposal ) ``{
	UI::ChangeWidget(`id(`proposal), `Value, proposal );
    };


    /**
     * Call a submodule's MakeProposal() function.
     *
     * @param  submodule	name of the submodule's proposal dispatcher
     * @param  force_reset	discard any existing (cached) proposal
     * @param  language_changed	installation language changed since last call
     * @return proposal_map	see proposal-API.txt
     **/

    define map submod_make_proposal( string submodule, boolean force_reset,
				     boolean language_changed )
    ``{
	map proposal = WFM::CallFunction ( submodule, [ "MakeProposal",
							$[ "force_reset" : force_reset,
							   "language_changed" : language_changed ] ] );
	y2debug( "%1 MakeProposal() returns %2", submodule, proposal );

	return proposal;
    };


    /**
     * Call a submodule's AskUser() function.
     *
     * @param  submodule	name of the submodule's proposal dispatcher
     * @param  has_next		force a "next" button even if the submodule would otherwise rename it
     * @return workflow_sequence see proposal-API.txt
     **/

    define symbol submod_ask_user( string submodule, boolean has_next )
    ``{
	// Call the AskUser() function

	map     ask_user_result   = WFM::CallFunction( submod, [ "AskUser", $[ "has_next": false] ] );
	symbol  workflow_sequence = ask_user_result["workflow_sequence"]:`next;
	boolean language_changed  = ask_user_result["language_changed"]:false;
	boolean mode_changed      = ask_user_result["mode_changed"]:false;
	boolean rootpart_changed  = ask_user_result["rootpart_changed"]:false;

	if (workflow_sequence != `cancel && workflow_sequence != `back &&
	    workflow_sequence != `abort && workflow_sequence != `finish)
	{
	    if ( language_changed )
	    {
		retranslate_proposal_dialog();
	    }

	    /*
	    if (mode_changed || rootpart_changed ||
		workflow_sequence == `finish)
	    {
		RootPart::UnmountPartitions ();
	    }
	    */

	    if (mode_changed)
	    {
		submodules = load_matching_submodules_list();
		if (!get_submod_descriptions_and_build_menu ())
		{
		    y2error ("i'm in dutch");
		}
	    }

	    // Make a new proposal based on those user changes
	    make_proposal( false, language_changed );
	}

	return workflow_sequence;
    };


    /**
     * Call a submodule's Description() function.
     *
     * @param  submodule	name of the submodule's proposal dispatcher or nil if no such module
     * @return description_map	see proposal-API.txt
     **/

    define map submod_description (string submodule)
    ``{
	map description = WFM::CallFunction( submodule, [ "Description", $[] ] );

	return description;
    };


    /**
     * Call each submodule's MakeProposal() function in turn and display the
     * proposals in the RichText widget.
     *
     * @param  force_reset	discard any existing (cached) proposal
     * @param  language_changed	installation language changed since last call
     **/

    define void make_proposal( boolean force_reset, boolean language_changed )
    ``{
	string prop = "";
	integer no = 0;
	map prop_map = $[];
	boolean skip_the_rest = false;
	have_blocker = false;

	UI::BusyCursor();

	foreach ( `submod, submodules,
	``{
	    if ( ! skip_the_rest )
	    {
		prop = prop + HTML::Heading( HTML::Link( select( titles, no, "ERROR: missing title" ),
							 submod2id[submod]:"" ) );
		prop_map = submod_make_proposal( submod, force_reset, language_changed );
	    }

	    if ( prop_map["language_changed"]:false )
	    {
		skip_the_rest = true;
		retranslate_proposal_dialog();
		make_proposal( force_reset, true );
	    }

	    if ( ! skip_the_rest )
	    {
		prop = prop + format_sub_proposal( prop_map );
		display_proposal( prop );
		no = no + 1;
	    }

	    if ( prop_map["warning_level"]:`none == `fatal )
	    {
		skip_the_rest = true;
	    }
	});

	UI::NormalCursor();
    };


    /**
     * Format a submodule's proposal in HTML
     *
     * @param  prop proposal map - see proposal-API.txt
     * @return HTML string
     **/

    define string format_sub_proposal( map prop )
    ``{
	string html = "";
	string warning = prop["warning"]:"";

	if ( warning != nil && warning != "" )
	{
	    symbol level = prop["warning_level"]:`warning;

	    if      ( level == `notice  )	warning = HTML::Bold( warning );
	    else if ( level == `warning )	warning = HTML::Colorize( warning, "red" );
	    else if ( level == `error	)	warning = HTML::Colorize( warning, "red" );
	    else if ( level == `blocker	|| level == `fatal )
	    {
		have_blocker = true;
		warning = HTML::Colorize( warning, "red" );
	    }

	    html = html + HTML::Para( warning );
	}

	string preformatted_prop = prop["preformatted_proposal"]:"";

	if ( preformatted_prop != "" )
	{
	    html = html + preformatted_prop;
	}
	else
	{
	    list raw_prop = prop["raw_proposal"]:["ERROR: No proposal"];
	    html = html + HTML::List( raw_prop );
	}

	return html;
    };




    /**
     * Call a submodule's Write() function.
     *
     * @param  submodule	name of the submodule's proposal dispatcher
     * @return success		true if Write() was successful of if there is no Write() function
     **/
    define boolean submod_write_settings( string submodule )
    ``{
	map result = WFM::CallFunction( submodule, [ "Write", $[] ] );
	if ( result == nil )
	    result = $[];

	return result["success"]:true;
    };


    /**
     * Call each submodule's "Write()" function to let it write its settings,
     * i.e. the settings effective.
     **/
    define void write_settings() ``{

	boolean success = true;

	foreach ( `submod, submodules, ``{
	    boolean submod_success = submod_write_settings( submod );
	    if (submod_success == nil)
		submod_success = true;

	    if ( ! submod_success )
		y2error( "Write() failed for submodule %1", submod );

	    success = success && submod_success;
	});

	if ( ! success )
	{
	    y2error( "Write() failed for one or more submodules" );
	    // Submodules handle their own error reporting

	    // text for a message box
	    Popup::TimedMessage( _("Configuration saved.\nThere were errors."), 3 );
	}
	// else
	// {
	//     // text for a message box
	//     Popup::TimedMessage( _("Configuration saved successfully."), 3 );
	// }
    };


    /**
     * Force a RichText widget to use the busy cursor
     *
     * @param widget_id  ID  of the widget, e.g. `id(`proposal)
     **/
    define void richtext_busy_cursor( any widget_id ) ``{
	UI::ChangeWidget( widget_id, `Enabled, false );
    };


    /**
     * Switch a RichText widget back to use the normal cursor
     *
     * @param widget_id  ID  of the widget, e.g. `id(`proposal)
     **/
    define void richtext_normal_cursor( any widget_id ) ``{
	UI::ChangeWidget( widget_id, `Enabled, true );
    };


    /**
     * Retranslate the proposal (wizard) dialog after the language is changed.
     **/
    define void retranslate_proposal_dialog() ``{

	y2debug( "Retranslating proposal dialog" );

	build_dialog();
	Wizard::ReplaceButtonBox( Wizard::HasAcceptButton() ?
				  Wizard::AbortAcceptButtonBox() :
				  Wizard::NextBackButtonBox() );
	get_submod_descriptions_and_build_menu();
    };


    /**
     * Load a list of submodules. Try loading it from a file named 'file_name'
     * from one of several predefined directories. If there is no such list,
     * use 'fallback_list'.
     *
     * @param  file_name	YCP file name to load from
     * @param  fallback_list	fallback list of submodule names (strings)
     * @return submodules_list	list of submodule names (strings)
     **/
    define list load_submodules_list( string file_name, list fallback_list ) ``{

	list submodules = SCR::Read(.target.ycp, [ file_name, [] ] );

	if ( submodules == [] )
	{
	    submodules = SCR::Read(.target.yast2, [ file_name, [] ] );
	}

	if ( submodules == [] )
	{
	    submodules = fallback_list;
	}

	return submodules;
    };


    /**
     * Load a list of submodules matching the current internal states
     * @param mode `ini, `net, or `hw to indicate which list to use
     *
     * @return submodules_list	list of submodule names (strings)
     **/
    define list load_matching_submodules_list() ``{

	list submodules = [];

	if ( proposal_mode == `ini && Mode::installation)
	{
	    // Module list for installation proposal

	    if (Arch::s390)
	    {
		submodules = load_submodules_list( "installation-proposals-s390.ycp",
						   [
						    // Fallback list
						    "proposal_mode",
						    "proposal_partitions",
						    "proposal_software",
						    "proposal_timezone",
						    "proposal_language",
						    ]
						   );
	    }
	    else
	    {
		if (Mode::live_eval)
		{
		    submodules = [
				  "proposal_keyboard",
				  "proposal_mouse",
				  "proposal_timezone",
				  "proposal_language"
		    ];
		}
		else
		{
		    submodules = load_submodules_list( "installation-proposals.ycp",
						       [
							// Fallback list
							"proposal_mode",
							"proposal_keyboard",
							"proposal_mouse",
							"proposal_partitions",
							"proposal_software",
							"bootloader_proposal",
							"proposal_timezone",
							"proposal_language",
							]
						       );
		}
	    }
	}
	else if ( proposal_mode == `ini && Mode::update)
	{
	    // Module list for update proposal

	    if (Arch::s390)
	    {
		submodules = load_submodules_list( "update-proposals-s390.ycp",
						   [
						    // Fallback list
						    "proposal_mode",
						    "proposal_rootpart",
						    "proposal_update",
						    "proposal_packages",
						    "proposal_backup",
						    "proposal_language"
						    ]
						   );
	    }
	    else
	    {
		submodules = load_submodules_list( "update-proposals.ycp",
						   [
						    // Fallback list
						    "proposal_mode",
						    "proposal_rootpart",
						    "proposal_update",
						    "proposal_packages",
						    "proposal_backup",
						    "proposal_language",
						    "proposal_keyboard"
						    ]
						   );
	    }
	}
	else if ( proposal_mode == `net )
	{
	    // Module list for network configuration proposal

	    if ( Arch::sparc )
	    {
		submodules = load_submodules_list( "net-config-proposals-sparc.ycp",
						   [
						    // Fallback list
						    "lan_proposal",
						    "modem_proposal",
						    "proxy_proposal",
						    "remote_proposal"
						    ]
						   );
	    }
	    else if ( Arch::ppc64 )
	    {
		submodules = load_submodules_list( "net-config-proposals-ppc64.ycp",
						   [
						    // Fallback list
						    "lan_proposal",
						    "proxy_proposal",
						    "remote_proposal"
						    ]
						   );
	    }
	    else if ( Arch::s390 )
	    {
		submodules = load_submodules_list( "net-config-proposals-s390.ycp",
						   [
						    // Fallback list
						    "lan_proposal",
						    "proxy_proposal",
						    "remote_proposal"
						    ]
						   );
	    }
	    else
	    {
		submodules = load_submodules_list( "net-config-proposals.ycp",
						   [
						    // Fallback list
						    "lan_proposal",
						    "dsl_proposal",
						    "isdn_proposal",
						    "modem_proposal",
						    "proxy_proposal",
						    "remote_proposal"
						    ]
						   );
	    }
	}
	else if ( proposal_mode == `hw )
	{
	    // Module list for hardware configuration proposal

	    if ( Arch::sparc )
	    {
		submodules = load_submodules_list( "hw-config-proposals-sparc.ycp",
						   [
						    // Fallback list
						    "x11_proposal",
						    "printer_proposal",
						    "sound_proposal"
						    ]
						   );
	    }
	    else if ( Arch::ppc64 )
	    {
		submodules = load_submodules_list( "hw-config-proposals-ppc64.ycp",
						   [
						    // Fallback list
						    "x11_proposal",
						    "printer_proposal"
						    ]
						   );
	    }
	    else if ( Arch::s390 )
	    {
		submodules = load_submodules_list( "hw-config-proposals-s390.ycp",
						   [
						    // Fallback list
						    "printer_proposal"
						    ]
						   );
	    }
	    else
	    {
		submodules = load_submodules_list( "hw-config-proposals.ycp",
						   [
						    // Fallback list
						    "x11_proposal",
						    "printer_proposal",
						    "sound_proposal",
						    "tv_proposal"
						    ]
						   );
	    }
	}
	else
	{
	    y2error( "Undefined mode - no submodule list" );
	}

	// in normal mode we don't want to switch between installation and update
	if (Mode::normal)
	{
	    submodules = filter (`v, submodules, ``(v != "proposal_mode"));
	}

	return submodules;
    };


    /**
     * Find out if the target machine has a network card.
     * @return true if a network card is found, false otherwise
     **/
    define boolean have_network_card() ``{

	// Maybe obsolete

	if ( Mode::test )
	    return true;

	return size( SCR::Read(.probe.netcard) ) > 0;
    };


    /**
     * Create the proposal dialog
     * (the inner part, excluding the wizard frame)
     **/
    define void build_dialog () ``{

	if ( Mode::initial )
	{
	    Wizard::SetEasyInstallationStep( EasyInstallationStepDescriptions(), 2 );
	}

	// headline for installation proposal
	string headline = _("Installation Settings");

	if ( proposal_mode == `net)
	    headline = _("Network Configuration");
	else if ( proposal_mode == `hw)
	    headline = _("Hardware Configuration");

	/* radiobuttons */
	term skip_buttons =
	    `RadioButtonGroup (
			       `VBox (
				      `VSpacing(1),
				      `Left(`RadioButton(`id(`skip), `opt(`notify),
							 // Check box: Skip all the configurations in this dialog -
							 // do this later manually or not at all
							 // Translators: About 40 characters max,
							 // use newlines for longer translations.
							 _("&Skip Configuration"), false)),
				      `Left(`RadioButton(`id(`dontskip), `opt(`notify),
							 _("&Use Following Configuration"), true)),
				      `VSpacing(1)
				      )
			       );

	/* change menu */
	term menu_box =
	    `HBox (
		   `HStretch (),
		   `ReplacePoint(`id(`rep_menu),
				 `MenuButton(`id(`menu_dummy), _("&Change..."), [`item(`id(`dummy), "" ) ] )
				 ),
		   `HStretch ()
		   );

	term vbox = nil;

	if ( proposal_mode == `ini )
	{
	    vbox = `VBox(
			 // Help message between headline and installation proposal / settings summary.
			 // May contain newlines, but don't make it very much longer than the original.
			 `Left( `Label( _("Click any headline to make changes or use the \"Change...\" menu below.") ) ),
			 `RichText( `id(`proposal),
				    // Initial contents of proposal subwindow while proposals are calculated
				    HTML::Newlines( 3 ) + HTML::Para( _("Analyzing your system...") )
				    ),
			 menu_box
			 );
	}
	else
	{
	    vbox = `VBox(
			 skip_buttons,
			 `HBox (
				`HSpacing (4),
				`RichText( `id(`proposal),
					   // Initial contents of proposal subwindow while proposals are calculated
					   HTML::Newlines( 3 ) + HTML::Para( _("Analyzing your system...") )
					   )
				),
			 menu_box
			 );
	}

	Wizard::SetContents(headline,
			    vbox,
			    UI::WidgetExists(`id(`HelpText) ) ? help_text() : "",
			    WFM::Args(0),	// have_back_button
			    false	// have_next_button
			    );
    };



    /**
     * Query all submodules about their descriptions, build a "Change" menu
     * from that, and cache the descriptions for further usage: They will
     * become hyperlinks in the RichText widget, too. Return false if no
     * submodule exists.
     **/
    define boolean get_submod_descriptions_and_build_menu() ``{

	list	menu_list	= [];
	list	new_submodules	= [];
	integer	no		= 1;
	titles = [];

	foreach(`submod, submodules, ``{
	    map description   = submod_description( submod );

	    if ( description == nil )
	    {
		y2milestone( "Submodule %1 not available (not installed?)", submod );
	    }
	    else
	    {
		if ( description != $[] )
		{
		    new_submodules = add( new_submodules, submod );
		    string title      = description["rich_text_title"]:submod;
		    string menu_title = description["menu_title"     ]:title;
		    string id         = description["id"             ]:sformat( "module_%1", no );

		    titles            = add( titles,  title );
		    submod2id[submod] = id;
		    id2submod[id]     = submod;
		    menu_list         = add( menu_list, `item(`id( id ), menu_title + "..." ) );

		    no = no + 1;
		}
	    }
	});

	submodules = new_submodules;	// maybe some submodules are not installed

	menu_list = add( menu_list, `item(`id(`reset_to_defaults), _("&Reset to defaults") ) );
	UI::ReplaceWidget(`id(`rep_menu), `MenuButton(`id(`menu), _("&Change..."), menu_list ) );

	return no > 1;
    };



    /**
     * Help text for proposal dialog.
     *
     * @return string help text
     **/
    define string help_text() ``{

	string help_text = "";

	    // General part of the help text for all types of proposals
	string how_to_change = _("<p>
Change the values by clicking on the respective headline
or by using the <b>Change...</b> menu.
</p>
");

	if ( proposal_mode == `ini && Mode::installation )
	{
	    // Help text for installation proposal
	    // General part ("You can change values...") is added as the next paragraph.
	    help_text = _("<p>
Use <b>Accept</b> to perform a new installation with the values displayed.
</p>
") + how_to_change;

	    // Help text for installation proposal, continued
	    help_text = help_text + _("<p>
To update an existing &product; system instead of doing a new install,
click the <b>Mode</b> headline or select <b>Mode</b> in the
<b>Change...</b> menu.
</p>
");
	    /**
	     * Deliberately omitting "boot installed system" here to avoid
	     * confusion: The user will be prompted for that if Linux
	     * partitions are found.
	     * - sh@suse.de 2002-02-26
	     **/

	    // Help text for installation proposal, continued
	    help_text = help_text + _("<p>
Your hard disk has not been modified in any way, so you can still safely abort.
</p>
");
	}
	else if ( proposal_mode == `ini && Mode::update )
	{
	    // Help text for update proposal
	    // General part ("You can change values...") is added as the next paragraph.
	    help_text = _("<p>
Use <b>Accept</b> to perform an update with the values displayed.
</p>
") + how_to_change;

	    /**
	     * Deliberately omitting "boot installed system" here to avoid
	     * confusion: The user will be prompted for that if Linux
	     * partitions are found.
	     * - sh@suse.de 2002-02-26
	     **/

	    // Help text for installation proposal, continued
	    help_text = help_text + _("<p>
Your hard disk has not been modified in any way, so you can still safely abort.
</p>
");
	}
	else if ( proposal_mode == `net )
	{
	    // Help text for network configuration proposal
	    // General part ("You can change values...") is added as the next paragraph.
	    help_text = _("<p>
Put the network settings into effect by pressing <b>Next</b>.
</p>
") + how_to_change;
	}
	else if ( proposal_mode == `hw )
	{
	    // Help text for hardware configuration proposal
	    // General part ("You can change values...") is added as the next paragraph.
	    help_text = _("<p>
Put the hardware settings into effect by pressing <b>Next</b>.
</p>
") + how_to_change;
	}
	else
	{
	    // Generic help text for other proposals (not basic installation or
	    // hardhware configuration.
	    // General part ("You can change values...") is added as the next paragraph.
	    help_text = _("<p>
To use the settings as displayed, press <b>Next</b>.
</p>
") + how_to_change;
	}

	return help_text;
    };



    /*-----------------------------------------------------------------------*/
    /*				    main()				     */
    /*-----------------------------------------------------------------------*/



    //
    // Create dialog
    //
    // This is done as early as possible for instant feedback, even though the
    // menu is still empty. Fortunately enough, nobody will notice this since
    // we also disable it until everything in there is known. This is to be
    // done before even the submodule descriptions are known since they usually
    // are in separate YCP files that liberally import other YCP modules which
    // in turn takes considerable time for the module constructors.
    //

    y2milestone( "Installation step #2" );
    proposal_mode = WFM::Args(2);
    build_dialog();

    UI::ChangeWidget(`id(`menu_dummy), `Enabled, false );
    richtext_busy_cursor(`id(`proposal ) );

    // don't know who disables the button
    UI::ChangeWidget(UI::WidgetExists(`id(`accept)) ? `id(`accept) : `id(`next), `Enabled, true);

    if ( Mode::initial )
    {
	// Do hardware probing
	//
	// This must happen before submodule descriptions are initialized; module
	// constructors might depend on it.
	// In autoinst mode, this has been called already.

	if (!Mode::autoinst)
	    WFM::CallFunction(`inst_startup() );

	// Let user decide between
	//
	// - New installation
	// - Update
	// - Boot installed system

        if ( !Mode::live_eval )
        {
	    while (true)
	    {
	        any ret = WFM::CallFunction (`inst_mode());

	        if (ret == `abort || ret == `finish)
		    return ret;

		if (ret != `again)
		    break;
	    }
	}
    }


    //
    // Get submodule descriptions
    //

    submodules = load_matching_submodules_list();
    if (!get_submod_descriptions_and_build_menu ())
    {
	return `auto;
    }


    //
    // Make the initial proposal
    //

    make_proposal( false, false );

    // Set keyboard focus to the [Accept] or [Next] button
    UI::SetFocus(UI::WidgetExists(`id(`accept)) ? `id(`accept) : `id(`next));

    //
    // Input loop
    //

    any input = nil;

    while ( true )
    {
	richtext_normal_cursor(`id(`proposal ) );
	input = Wizard::UserInput();
	richtext_busy_cursor(`id(`proposal ) );

	// check for hyperlink id

	if (is (input, string))
	{
	    // get module for hyperlink id
	    string submod = id2submod[input]:"";
	    if (submod != "")
	    {
		// Call AskUser() function.
		// This will trigger another call to make_proposal() internally.
		input = submod_ask_user( submod, false );

		// The workflow_sequence doesn't get handled as a workflow sequence
		// so we have to do this special case here. Kind of broken.
		if (input == `finish)
		    return `finish;
	    }
	}
	else if (input == `finish)
	{
	    return `finish;
	}
	else if (input == `abort)
	{
	    if ( Mode::initial && !Mode::live_eval )
	    {
		if (Popup::ConfirmAbort (`painless))
		    return `abort;
	    }
	    else
	    {
		if (Popup::ConfirmAbort (`incomplete))
		    return `abort;
	    }
	}
	else if (input == `reset_to_defaults
		 && Popup::ContinueCancel(
					    // question in a popup box
					    _("Really reset everything to default values?") + "\n" +
					    // explain consequences of a decision
					    _("You will lose all changes.") ) )
	{
	    make_proposal( true, false );	// force_reset
	}
	else if ( input == `skip || input == `dontskip )
	{
	    if (UI::QueryWidget (`id(`skip), `Value))
	    {
		// User doesn't want to use any of the settings
		UI::ChangeWidget( `id(`proposal), `Value,
				  HTML::Newlines( 3 ) +
				  // message show when user has disabled the configuration
				  HTML::Para( _("Skipping configuration upon user request") )
				  );
		UI::ChangeWidget(`id(`menu), `Enabled, false );
	    }
	    else
	    {
		// User changed his mind and wants the settings back - recreate them
		make_proposal( false, false );
		UI::ChangeWidget(`id(`menu), `Enabled, true );
	    }
	}
	else if ( input == `next )
	{
	    if (have_blocker)
	    {
		// error message is a popup
		Popup::Error (_("The proposal contains an error that must be
resolved before continuing.
"));
		continue;
	    }

	    if ( Mode::initial && !Mode::live_eval )
	    {
		input = WFM::CallFunction(`inst_doit( true,		// have_back
						      true,		// have_next
						      false ) );	// going_backwards
	    }

	    if ( input == `next )
	    {
		boolean skip = UI::WidgetExists(`id(`skip) ) ? UI::QueryWidget(`id(`skip), `Value ) : true;

		if ( ! skip )
		{
		    write_settings();
		}

		if( ! Mode::initial &&
		    ( Product::openteam_server || Product::fwadmin_host ) )
		{
		    if ( Product::openteam_server )
		    {
			return WFM::CallFunction( `openteam() );
		    }
		    else if ( Product::fwadmin_host )
		    {
			return WFM::CallFunction( `fwcdadmin() );
		    }
		}
		else
		{
		    return `next;
		}
	    }
	}
	else if ( input == `back )
	{
	    return `back;
	}
	else if ( input == `help )
	{
	    Wizard::ShowHelp( help_text() );
	}

    } // while input loop


// NOTREACHED

/* EOF */
}
