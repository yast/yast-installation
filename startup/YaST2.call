#!/bin/sh
#================
# FILE          : YaST2.call
#----------------
# PROJECT       : YaST (Yet another Setup Tool v2)
# COPYRIGHT     : (c) 2004 SUSE Linux AG, Germany. All rights reserved
#               :
# AUTHORS       : Steffen Winterfeldt <snwint@suse.de>
#               : Arvin Schnell <arvin@suse.de>
#               : Marcus Schaefer <ms@suse.de>
#               : Lukas Ocilka <locilka@suse.cz>
#               :
# BELONGS TO    : System installation and Administration
#               :
# DESCRIPTION   : This is the main script to start the YaST2 installer
#               : according to the possible installation environments
#               : These are:
#               : ---
#               : - Standard Installation X11 or text based
#               : - Via serial line ttyS0/115200 baud, 8N1, RTS/CTS
#               :   which is the same as the NCURSES mode
#               : - VNC Installation via browser
#               :
# STATUS        : $Id$
#----------------
#
#set -x

. /etc/YaST2/XVersion

#=============================================
# Functions...
#---------------------------------------------
#----[ wait_for_x11 ]----#
function wait_for_x11() {
#------------------------------------------------------
# after a X-Server has been started you can wait until
# the server is ready for requests using this function
# ---
	server_running=0
	TESTX=/usr/sbin/testX
	while kill -0 $xserver_pid 2>/dev/null ; do
		sleep 1
		if test -e /tmp/.X11-unix/X0 && test -x $TESTX ; then
			$TESTX "$YaST2color" 2>/dev/null
			err=$?
			# exit code 1 -> XOpenDisplay failed...
			if test $err = 1;then
				log "\tTestX: XOpenDisplay failed"
				server_running=0
				continue
			fi
			# exit code 2 -> color or dimensions doesn't fit...
			if test $err = 2;then
				log "\tTestX: color or dimensions doesn't fit"
				kill $xserver_pid
				server_running=0
				break;
			fi
			# server is running, detach oom-killer from it
			echo -n '-17' > /proc/$xserver_pid/oom_adj
			server_running=1
			# tweak server (see bnc #345186)
			xset r on
			break
		fi
	done
}

#----[ get_bus_id ]----#
function get_bus_id () {
#------------------------------------------------------
# ask the PCi bus for the location of the first
# graphics card.
# ---
	for line in $(/sbin/lspci -n | grep "Class 0300" | cut -f 1 -d " ");do
		echo $line |\
			grep -q -E "^[0-9a-f]{2}:[0-9a-f]{2}\.[0-9a-f]"
		if [ $? = 0 ];then
			PCIBus=$(echo $line | cut -f1 -d:);
			PCISlot=$(echo $line | cut -f2 -d: | cut -f 1 -d.);
			PCIFunc=$(echo $line | cut -f2 -d.);
			log "\tFound standard BusID: $PCIBus:$PCISlot:$PCIFunc"
			printf "PCI:%d@0:%d:%d" \
				0x$PCIBus 0x$PCISlot 0x$PCIFunc
			break
		else
			echo $line |\
				grep -q -E "^[0-9a-f]{4}:[0-9a-f]{2}:[0-9a-f]{2}\.[0-9a-f]"
			if [ $? = 0 ];then
				PCIDomain=$(echo $line | cut -f1 -d:);
				PCIBus=$(echo $line | cut -f2 -d:);
				PCISlot=$(echo $line | cut -f3 -d: | cut -f 1 -d.);
				PCIFunc=$(echo $line | cut -f2 -d.);
				log "\tFound domain BusID: $PCIBus@$PCIDomain:$PCISlot $PCIFunc"
				printf "PCI:%d@%d:%d:%d" \
					0x$PCIBus 0x$PCIDomain 0x$PCISlot 0x$PCIFunc
				break
			fi
		fi
	done
}

#----[ count_x11_geometry ]----#
function count_x11_geometry () {
    # current X-resolution, display 0
    XRES=$(/usr/sbin/xquery -d :0 -r)

    log "\t===X11 Geometry==="
    log "\tResolution: ${XRES}"

    # failed to get display info
    if [ "$?" != "0" ]; then
	X_GEOMETRY=""
	return
    fi

    # current X and Y resolution
    XRES_X=$(echo $XRES | sed '
	s|[0123456789]\+ \([0123456789]\+\)x[0123456789]\+|\1|
	s|[^0123456789]||g')
    XRES_Y=$(echo $XRES | sed '
	s|[0123456789]\+ [0123456789]\+x\([0123456789]\+\)|\1|
	s|[^0123456789]||g')

    log "\tX: ${XRES_X}"
    log "\tY: ${XRES_Y}"

    # default values
    OFFSET_X=0
    OFFSET_Y=0
    BACKGROUND_IMAGE=""

    # wrong X and/or Y resolution
    if [ "${XRES_X}" == "" ] || [ "${XRES_Y}" == "" ]; then
	X_GEOMETRY=""
	log "\tError: Cannot get X and/or Y from given resolution"
	return
    # reasonable sizes
    else
	# must be bigger or equal to 1400x1050
	if [ "$(expr $XRES_X \>= 1400)" == "1" ] && [ "$(expr $XRES_Y \>= 1050)" == "1" ]; then
	    WINDOW_SIZE_X=1024
	    WINDOW_SIZE_Y=786
	# exception for PPC: 832x624, see bugzilla #207321
	elif [ "${XRES_X}" == "832" ] && [ "${XRES_Y}" == "624" ]; then
	    WINDOW_SIZE_X=${XRES_X}
	    WINDOW_SIZE_Y=${XRES_Y}
	# must be bigger or equal to 800x600
	elif [ "$(expr $XRES_X \>= 800)" == "1" ] && [ "$(expr $XRES_Y \>= 600)" == "1" ]; then
	    WINDOW_SIZE_X=800
	    WINDOW_SIZE_Y=600
	# or fullscreen
	else
	    WINDOW_SIZE_X=${XRES_X}
	    WINDOW_SIZE_Y=${XRES_Y}
	fi

	# Conversion from jpg to png is done later
	BACKGROUND_IMAGE="/usr/lib/YaST2/startup/InstallImages/${XRES_X}x${XRES_Y}.jpg"

	# X and Y offsets
	OFFSET_X=$(expr ${XRES_X} - ${WINDOW_SIZE_X})
	OFFSET_X=$(expr ${OFFSET_X} / 2)
	OFFSET_Y=$(expr ${XRES_Y} - ${WINDOW_SIZE_Y})
	OFFSET_Y=$(expr ${OFFSET_Y} / 2)
    fi

    log "\tWindow size X: ${WINDOW_SIZE_X}"
    log "\tWindow size Y: ${WINDOW_SIZE_Y}"
    log "\tOffset X: ${OFFSET_X}"
    log "\tOffset Y: ${OFFSET_Y}"

    if [ "${OFFSET_X}" == "0" ] || [ "${OFFSET_Y}" == "0" ] || [ "${OFFSET_X}" == "" ] || [ "${OFFSET_Y}" == "" ]; then
	# will run in fullscreen mode
	X_GEOMETRY=""
    else
	# final window geometry, 'Window_XxWindow_Y+Offset_X+Offset_Y'
	X_GEOMETRY="${WINDOW_SIZE_X}x${WINDOW_SIZE_Y}+${OFFSET_X}+${OFFSET_Y}"
    fi

    log "\tUsed geometry: ${X_GEOMETRY}"
}

#----[ prepare_for_x11 ]----#
function prepare_for_x11 () {
#------------------------------------------------------
# prepare X11 installation
# ---
	local fbdevname
	set_splash 100

	#=============================================
	# patch X11 conf. if not update/continue mode
	#---------------------------------------------
	if [ ! -f /etc/reconfig_system ];then
	if [ ! -f /var/lib/YaST2/runme_at_boot ];then
	if [ ! -f /etc/X11/xorg.conf.instorig ];then
		# create backup copy...
		cp /etc/X11/xorg.conf /etc/X11/xorg.conf.instorig

		# Activate correct device/screen section...
		sed -e "s#Screen.*Screen\[.*\]#Screen   "\""Screen[$X11_CONFIG_ID]#" \
			/etc/X11/xorg.conf >/etc/X11/xorg.conf.new
		mv /etc/X11/xorg.conf.new /etc/X11/xorg.conf

		# update core pointer input device section...
		if [ -f "/usr/sbin/xupdate" ];then
			cat /etc/X11/xorg.conf | \
				/usr/sbin/xupdate > /etc/X11/xorg.conf.new
			mv /etc/X11/xorg.conf.new /etc/X11/xorg.conf
		fi

		# update driver and busID if accelerated driver should be used...
		if [ "$X11_CONFIG_ID" = 0 ];then
			# replace BusID placeholder with real busID
			XBusID=$(get_bus_id)
			if [ ! -z "$XBusID" ];then
				sed -e 's/#BusID/BusID/' \
					-e "s#1:0:0#$XBusID#" /etc/X11/xorg.conf \
				> /etc/X11/xorg.conf.new
				mv /etc/X11/xorg.conf.new /etc/X11/xorg.conf
			fi

			# replace driver placeholder with real name
			sed -e "s#ChangeMe#$XServer#" /etc/X11/xorg.conf \
			> /etc/X11/xorg.conf.new
			mv /etc/X11/xorg.conf.new /etc/X11/xorg.conf
		fi
		# check DefaultDepth setup
		if [ -f /sys/class/graphics/fb0/name ];then
			read fbdevname < /sys/class/graphics/fb0/name
			case "$fbdevname" in
				# The DefaultDepth 16 will not work if the card does not
				# have enough video ram, or if 15bit has to be used
				# Let the X11 fbdev driver use whatever the kernel driver uses
				platinum|control|valkyrie|OFfb)
				;;
				# Force DefaultDepth 16, or Qt/Gtk will not look nice
				# nvidiafb uses 'NV%x'
				# rivafb uses 'NV%x'
				# aty128fb uses 'ATY Rage128'
				# radeonfb uses 'ATI Radeon XX '
				NV*|*Rage128|*Radeon*)
				sed -i -e "/@DefaultDepth@/s/^.*/DefaultDepth 16/" /etc/X11/xorg.conf
				;;
				# drivers that are not yet tested
				# atyfb uses 'ATY Mach64', may not have enough video ram
				MATROX|*Mach64)
				;;
				*)
				;;
			esac
		fi
	fi
	fi
	fi
	#=============================================
	# start X-Server and wait until ready
	#---------------------------------------------
	if [ ! -z "$NEED_XSERVER" ];then
		export DISPLAY=:0
		[ -z $Xstartpath ] || ln -snf $Xbindir/XFree86 /var/X11R6/bin/X
		$Xexecutable -deferglyphs 16 2>/dev/tty8 1>&2 vt07 &
		xserver_pid=$!
		wait_for_x11
		if [ "$server_running" = 1 ];then
			log "\tX-Server is ready: $xserver_pid"
		fi
	fi
	#=============================================
	# set YaST2 Qt/Gtk options for local displays
	#---------------------------------------------
	if [ ! -z "$NEED_XSERVER" ];then
		Y2_UI_ARGS="--noborder --auto-fonts"
##* Bugzilla #208307 Use only the fullscreen mode
##*		count_x11_geometry # currently not used
##*		if [ "${X_GEOMETRY}" == "" ]; then
		    log "\tUI_args: Running in fullscreen mode"
		    Y2_UI_ARGS="${Y2_UI_ARGS} --fullscreen"
##*		else
##*		    log "\tUI_args: Running in window"
##*		    Y2_UI_ARGS="${Y2_UI_ARGS} -geometry ${X_GEOMETRY}"
##*		fi
	fi
}


#----[ prepare_for_qt ]----#
function prepare_for_qt () {
    set_inst_qt_env
    prepare_for_x11
}


#----[ prepare_for_gtk ]----#
function prepare_for_gtk () {
    prepare_for_x11
}


#----[ prepare_for_ncurses ]----#
function prepare_for_ncurses () {
#------------------------------------------------------
# prepare NCURSES installation
# ---
	#=============================================
	# Create Braille config if not update mode
	#---------------------------------------------
	if [ $INST_MODE = "normal" ];then
	if [ ! -z "$Braille" ];then
		log "Braille config needed, setting up braille display"
		sed -e "s#brlname=.*#brlname=$Braille#" \
			-e "s#brlport=.*#brlport=$Brailledevice#" /etc/suse-blinux.conf \
		>/tmp/suse-blinux.conf
		mv -f /tmp/suse-blinux.conf /etc
		/etc/init.d/brld start
		/etc/init.d/suse-blinux start
	fi
	fi
	#=============================================
	# Check for FbIterm
	#---------------------------------------------
	check_run_fbiterm
	log "\tCheck for FB-I-terminal: RUN_FBITERM = $RUN_FBITERM"
}

#----[ prepare_for_ssh ]----#
function prepare_for_ssh () {
#------------------------------------------------------
# prepare SSH installation
# ---
#
	:
}

#----[ prepare_for_vnc ]----#
function prepare_for_vnc () {
#------------------------------------------------------
# prepare VNC installation
# ---
#
	#=============================================
	# Setup splash screen
	#---------------------------------------------
	set_splash 100

	#=============================================
	# Setup y2base options
	#---------------------------------------------
	# xxx
	#Y2_UI_ARGS="--fullscreen --noborder --auto-fonts"
	Y2_UI_ARGS="--noborder --auto-fonts"

	#=============================================
	# Setup VNC server and start it
	#---------------------------------------------
	setupVNCAuthentication
	if [ $VNCPASS_EXCEPTION = 0 ];then
		disable_splash
		startVNCServer
		wait_for_x11
		if [ "$server_running" = 1 ];then
			log "\tXvnc-Server is ready: $xserver_pid"
		fi
	fi
}

#----[ check_x11 ]----#
function check_x11 () {
#------------------------------------------------------
# check if the prepared medium X11 (Qt/Gtk) is valid
# ---
	if [ ! -z "$NEED_XSERVER" ];then
		if [ "$server_running" = 0 ];then
			# /.../
			# X-Server couldn't be started, selecting
			# NCURSES mode as fallback ?
			# ---
			log "\tX-Server couldn't be started, falling back to ncurses"
			Y2_MODE_FLAGS='("text_fallback")'
			SELECTED_MEDIUM="NCURSES"
			prepare_for_ncurses
			Y2_MODE=ncurses
		fi
	else
		/usr/sbin/testX --fast 2>/dev/null
		if test $? = 1;then
			log "\tCannot access Display: $DISPLAY, falling back to ncurses"
			SELECTED_MEDIUM="NCURSES"
			prepare_for_ncurses
			Y2_MODE=ncurses
		fi
	fi
}

#----[ check_network ]----#
function check_network () {
#------------------------------------------------------
# check if the prepared medium SSH is valid. It is valid
# if there is a network interface accessable and we are
# able to use ncurses or X11
# ---
	if ! found_iface ; then
		# /.../
		# No network interface found for SSH or VNC installation
		# this is a fatal error here
		# ---
		log "\tNo network interface found, fatal error"
		fatalError
	fi
	if [ ! -z "$DISPLAY" ];then
		log "\tDisplay: $DISPLAY found for network install"
		Y2_MODE=qt
	fi
	if ! check_qt ; then
	    log "\tQt plugin check failed falling back to Gtk"
	    Y2_MODE=gtk
	    if ! check_gtk ; then
		log "\tGtk plugin check failed falling back to ncurses"
		Y2_MODE=ncurses
	    fi
	fi
}

#----[ check_vnc ]----#
function check_vnc () {
#------------------------------------------------------
# check if the prepared medium VNC is valid
# ---
	check_network
	if [ $VNCPASS_EXCEPTION = 1 ];then
		log "\tVNC access has been disabled due to a password exception"
		log "\tPlease make sure the password is at least 8 characters long"
		fatalError
	fi
	if [ "$server_running" = 0 ];then
		# /.../
		# XVnc server couldn't be started, what to do now, I think
		# this is a fatal error here
		# ---
		log "\tXVnc server couldn't be started, fatal error"
		fatalError
	fi
}

#----[ set background image for yast ]----#
function set_yast_background () {
	# set up a background if any needed
	if [ "${BACKGROUND_IMAGE}" != "" ]; then
	    TMPDIR="/tmp/installimg"

	    # selected image doesn't exist, usign fallback
	    if ! [ -e "${BACKGROUND_IMAGE}" ]; then
		BACKGROUND_IMAGE="/usr/lib/YaST2/startup/InstallImages/fallback.png"
		log "\tNot a supported resolution, using fallback image"
	    # convert stored JPG to PNG
	    else
		log "\tUsing background: ${BACKGROUND_IMAGE}"
		mkdir -p ${TMPDIR}
		# convert JPG to PNM
		jpegtopnm ${BACKGROUND_IMAGE} > ${TMPDIR}/img.pnm 2>${TMPDIR}/jpegtopnm.log
		# convert PNM to PNG
		pnmtopng ${TMPDIR}/img.pnm > ${TMPDIR}/img.png 2>${TMPDIR}/pnmtopng.log
		# remove PNM
		rm -rf ${TMPDIR}/img.pnm
		# set the BACKGROUND_IMAGE to the converted one
		BACKGROUND_IMAGE=${TMPDIR}/img.png
	    fi

	    # set the background
	    # FIXME

	    # remove PNG silently if exists
	    rm -rf ${TMPDIR}/img.png
	fi
}

#----[ start_yast ]----#
function start_yast () {
#------------------------------------------------------
# Start YaST2 refering to the contents of the Y2_*
# startup variables
# ---
	local overcommit
	read  overcommit < /proc/sys/vm/overcommit_memory
	echo "*** Starting YaST2 ***"
	log "\tAllow big memory allocation: overcommit_memory=1"
	echo 1 > /proc/sys/vm/overcommit_memory
	if [ "$SPLASH" = yes -a -x /sbin/splash -a -n "$SPLASHCFG" ];then
		/sbin/splash -t "YaST running"
	fi
	export QT_IM_MODULE=xim

	if [ "$RUN_FBITERM" = "1" ]; then
	    OPT_FBITERM="/usr/bin/fbiterm --"
	else
	    OPT_FBITERM=
	fi

##*	# bugzilla #208307
##*	set_yast_background # currently not used

	log "\tStarting YaST2:"
	log "\tMODULE_NAME: $Y2_MODULE_NAME"
	log "\tMODE_FLAGS:  $Y2_MODE_FLAGS"
	log "\tMODULE_ARGS: $Y2_MODULE_ARGS"
	log "\tMODE:        $Y2_MODE"
	log "\tUI_ARGS:     $Y2_UI_ARGS"
	log "\tQT_IM_MODULE:$QT_IM_MODULE"
	$OPT_FBITERM y2base \
			"$Y2_MODULE_NAME"   \
			$Y2_MODE_FLAGS      \
			$Y2_MODULE_ARGS     \
			$Y2_MODE            \
			$Y2_UI_ARGS
	Y2_EXIT_CODE=$?
	Y2_ABORT_MESSAGE="YaST seems to be aborted abnormally !"
	Y2_OK_MESSAGE="YaST procedure ended successfully"
	if [ -s /etc/yast.inf ];then
		#=============================================
		# check yast.inf contents
		#---------------------------------------------
		cat /etc/yast.inf | grep -q -i "Aborted: 1"
		if [ $? = 0 ];then
			log "\t$Y2_ABORT_MESSAGE"
		fi
	else
		#=============================================
		# YaST ended successfully
		#---------------------------------------------
		log "\t$Y2_OK_MESSAGE"
	fi
	if [ $SELECTED_MEDIUM = "SSH" ] && [ ! "$VNC" = 1 ];then
		echo "*** Preparing SSH installation for reboot ***"
		echo "*** NOTE: after reboot, you have to reconnect and call ***"
		echo "*** /usr/lib/YaST2/startup/YaST2.ssh ***"
		log "\tPreparing SSH installation for reboot"
		echo $Y2_EXIT_CODE > /tmp/YaST2_ssh_installation_finished
	fi
	if [ $Y2_EXIT_CODE -eq 0 ];then
		start_yast_and_reboot
		start_yast_again
	fi
	log "\tReset memory allocation: overcommit_memory=$overcommit"
	echo $overcommit > /proc/sys/vm/overcommit_memory
}

#----[ start_yast_and_reboot ]----#
function start_yast_and_reboot () {
#------------------------------------------------------
# This function will reboot the system and start yast
# again by touching the file /var/lib/YaST2/runme_at_boot.
# The function is triggered by the file /var/lib/YaST2/reboot
# ---
	if [ -f /var/lib/YaST2/reboot ];then
		rm -f /var/lib/YaST2/reboot
		touch /var/lib/YaST2/runme_at_boot
		/sbin/shutdown -r now
	fi
}

#----[ start_yast_again ]----#
function start_yast_again () {
#------------------------------------------------------
# This function will restart yast again with the same
# options as used before. The function is triggered by
# the file /var/lib/YaST2/restart_yast
# ---
	if [ -f /var/lib/YaST2/restart_yast ];then
		rm -f /var/lib/YaST2/restart_yast
		start_yast
	fi
}

#=============================================
# Start the Magic :-)
#=============================================
# 1) Source common script functions
#---------------------------------------------
. /usr/lib/YaST2/startup/common/functions.sh
. /usr/lib/YaST2/startup/requires
. /usr/lib/YaST2/startup/arch/ia64/x11.sh

#=============================================
# 1.1) set splash progress bar to 90%
#---------------------------------------------
set_splash 90
#=============================================
# 1.2) set root HOME directory
#---------------------------------------------
export HOME=/root
#=============================================
# 1.3) set HTTP/FTP proxy and configure syslog
#---------------------------------------------
set_syslog ; set_proxy

#=============================================
# 2) Initialize...
#---------------------------------------------
# 2.1) setup PATH
PATH=$ybindir:$PATH
[ -z Xstartpath ] || PATH=/var/X11R6/bin:$PATH
#=============================================
# 2.2) get X11 driver directory
#---------------------------------------------
X11_DRIVER_DIR=$Xdriverpath
if [ -d $Xdriver64path ];then
	X11_DRIVER_DIR=$Xdriver64path
fi
#=============================================
# 2.3) obtain RAM size in Kb
#---------------------------------------------
MEM_TOTAL=`awk '/^MemTotal:/{ print $2 }' /proc/meminfo`
if [ ${#MEM_TOTAL} -gt 9 ];then
	MEM_TOTAL=1000000000
fi
#=============================================
# 2.4) check for valid framebuffer
#---------------------------------------------
FBDEV_OK=0
if (: < /dev/fb0) 2>/dev/null ; then
	FBDEV_OK=1
fi
#=============================================
# 2.5) setup installation mode (update y/n)
#---------------------------------------------
INST_MODE="normal"
if [ -f /var/lib/YaST2/update_mode ];then
	INST_MODE="update"
fi
#=============================================
# 2.6) import install.inf
#---------------------------------------------
import_install_inf

#=============================================
# 2.7) set LOG prefix
#---------------------------------------------
LOG_PREFIX="Stage [call]"

#=============================================
# 3) Medium prequalification
#---------------------------------------------
# Check which installation mediums can be used. There are
# four mediums available: Qt(0) SSH(1), VNC(2), NCURSES(3) and Gtk(4).
# The following checks will create an array which contains
# the possible mediums. An index of 1 indicates "can be used"
# an index of 0 indicated "cannot be used"
# ---
MEDIUM=(1 1 1 1 1)

#=============================================
# 3.1) prequalification checks for Qt
#---------------------------------------------
log "Starting prequalification checks..."
log "==================================="
# 3.1.1) Qt and Gtk plugin check...
if ! check_qt ; then
	log "\tQt plugin check failed -> Medium Qt disabled"
	MEDIUM[0]=0
fi
if ! check_gtk ; then
	log "\tGtk plugin check failed -> Medium Gtk disabled"
	MEDIUM[4]=0
fi
# 3.1.2) X-Server module check...
# BEG IA64: use accelerated X11 driver
ia64_check_x11
# END IA64:
XServerAccel=$XServer
if [ "$XServer" = "vmware" ];then
	if [ ! -f "$X11_DRIVER_DIR/${XServer}_drv.so" ];then
		log "\t$XServer driver not installed -> Medium Qt and Gtk disabled"
		MEDIUM[0]=0
		MEDIUM[4]=0
	fi
	X11_CONFIG_ID=vmware
else
	XServer=fbdev
	if [ $FBDEV_OK -eq 0 ];then
		log "\tNo Framebuffer available: Using vesa driver"
		XServer=vesa
	fi
	if [ ! -f "$X11_DRIVER_DIR/${XServer}_drv.so" ];then
		log "\t$XServer driver not installed -> Medium Qt and Gtk disabled"
		MEDIUM[0]=0
		MEDIUM[4]=0
	fi
	X11_CONFIG_ID=$XServer
fi
if [ "$acceleratedx" = "1" ];then
	if [ ! -f "$X11_DRIVER_DIR/${XServerAccel}_drv.so" ];then
		log "\t$XServerAccel driver not installed -> X11 acceleration disabled"
	else
		log "\tUsing accelerated driver -> $XServerAccel"
		if [ $XServerAccel = "i810" ];then
			log "\tIntel driver requested: loading intel agp module"
			load_module intel-agp
		fi
		MEDIUM[0]=1
		MEDIUM[4]=1
		XServer=$XServerAccel
		X11_CONFIG_ID=0
	fi
fi
# 3.1.3) Memory check >= 90MB for Qt/X11...
if [ $MEM_TOTAL -lt "$MEM_NEEDED" ];then
	log "\tMemory requirement > 90MB not fulfilled -> Medium Qt and Gtk disabled"
	MEDIUM[0]=0
	MEDIUM[4]=0
fi
# 3.1.4) Check if we need to start our own X11 server...
if [ -z "$DISPLAY" ];then
	NEED_XSERVER=1
fi
# 3.1.5) Check for xorg.conf...
if [ ! -f /etc/X11/xorg.conf ];then
if [ ! -f $Xorgconftempl ];then
	log "\tNo X11 configuration template found -> Medium Qt and Gtk disabled"
	MEDIUM[0]=0
	MEDIUM[4]=0
else
	cp $Xorgconftempl /etc/X11/xorg.conf
fi
fi
# 3.1.6) Check for WindowManager configuration
if [ ! -f /etc/icewm/preferences.yast2 ];then
	log "\tNo Windowmanager configuration found -> Medium Qt and Gtk disabled"
	MEDIUM[0]=0
	MEDIUM[4]=0
fi
# 3.1.7) Check for remote display usage
if [ ! -z $Display_IP ];then
	log "\tRemote Display usage -> Medium Qt and Gtk enabled"
	log "\tExporting DISPLAY to host: $Display_IP:0.0"
	export DISPLAY="$Display_IP:0.0"
	NEED_XSERVER=""
	MEDIUM[0]=1
	MEDIUM[4]=1
fi

#=============================================
# 3.2) prequalification checks for SSH
#---------------------------------------------
# 3.2.1) Check for SSH daemon
if [ -f /var/run/sshd.*pid ];then
	ps `cat /var/run/sshd.*pid` >/dev/null || MEDIUM[2]=0
else
	log "\tNo SSH daemon running -> Medium SSH disabled"
	MEDIUM[1]=0
fi

#=============================================
# 3.3) prequalification checks for VNC
#---------------------------------------------
# 3.3.1) Check for WindowManager configuration
if [ ! -f /etc/icewm/preferences.yast2 ];then
	log "\tNo Windowmanager configuration found -> Medium VNC disabled"
	MEDIUM[2]=0
fi
# 3.3.2) Check for VNC X-Server binary
if [ ! -x $Xbindir/Xvnc ] ; then
	log "\tNo Xvnc server installed -> Medium VNC disabled"
	MEDIUM[2]=0
fi
# 3.3.3) Check for testX binary
if [ ! -x /usr/sbin/testX ] ; then
	log "\tNo testX binary installed -> Medium VNC disabled"
	MEDIUM[2]=0
fi

#=============================================
# 4) Evaluate medium selection
#---------------------------------------------
# At this point we are evaluating the variables which have
# been imported from the install.inf file into the current
# environment. The standard method of installing the system
# should be Qt based. Refering to the variables Textmode,
# Braille, UseSSH and VNC another medium could be selected
# VNC overrides UseSSH
# ---
log "Evaluate medium selection..."
log "============================"
SELECTED_MEDIUM="QT"
if [ "$Textmode" = 1 ];then
	log "\tMedium Textmode (ncurses) has been selected"
	SELECTED_MEDIUM="NCURSES"
fi
if [ ! -z "$Braille" ];then
	log "\tMedium Braille (ncurses) has been selected"
	SELECTED_MEDIUM="NCURSES"
fi
if [ "$UseSSH" = 1 ];then
	log "\tMedium SSH has been selected"
	SELECTED_MEDIUM="SSH"
fi
if [ "$VNC" = 1 ];then
	log "\tMedium VNC has been selected"
	SELECTED_MEDIUM="VNC"
fi

#=============================================
# 5) Check selected medium
#---------------------------------------------
# Refering to the prequalification check results we need to
# check if the selected medium is valid according to the
# MEDIUM flag entry. If the medium is not valid we will
# fallback to NCURSES mode
# ---
log "Check selected medium..."
log "========================"
log "\tWished medium is: $SELECTED_MEDIUM"
case $SELECTED_MEDIUM in
	QT)  {
		if [ ${MEDIUM[0]} -eq 0 ];then
			log "\tMedium Qt not available, falling back to Gtk"
			SELECTED_MEDIUM="GTK"
			if [ ${MEDIUM[4]} -eq 0 ];then
				log "\tMedium Gtk not available, falling back to ncurses"
				SELECTED_MEDIUM="NCURSES"
			fi
		fi
	} ;;
	GTK) {
		if [ ${MEDIUM[4]} -eq 0 ];then
			log "\tMedium Gtk not available, falling back to Qt"
			SELECTED_MEDIUM="QT"
			if [ ${MEDIUM[0]} -eq 0 ];then
				log "\tMedium Qt not available, falling back to ncurses"
				SELECTED_MEDIUM="NCURSES"
			fi
		fi
	} ;;
	SSH) {
		if [ ${MEDIUM[1]} -eq 0 ];then
			log "\tMedium SSH not available, falling back to ncurses"
			SELECTED_MEDIUM="NCURSES"
		fi
	} ;;
	VNC) {
		if [ ${MEDIUM[2]} -eq 0 ];then
			log "\tMedium VNC not available, falling back to ncurses"
			SELECTED_MEDIUM="NCURSES"
		fi
	} ;;
esac
log "\tSelected medium is: $SELECTED_MEDIUM"

#=============================================
# 6) Prepare selected medium
#---------------------------------------------
case $SELECTED_MEDIUM in
	QT)      prepare_for_qt      ; Y2_MODE=qt      ;;
	GTK)     prepare_for_gtk     ; Y2_MODE=gtk     ;;
	SSH)     prepare_for_ssh     ; Y2_MODE=ncurses ;;
	VNC)     prepare_for_vnc     ; Y2_MODE=qt      ;;
	NCURSES) prepare_for_ncurses ; Y2_MODE=ncurses ;;
esac

#=============================================
# 7) Check prepared medium
#---------------------------------------------
case $SELECTED_MEDIUM in
	QT)  check_x11     ;;
	GTK) check_x11     ;;
	SSH) check_network ;;
	VNC) check_vnc     ;;
esac

# The prepare_for_ncurses in step 6 is kinda useless if step 7 can
# change Y2MODE to ncurses in several ways

#running with threads (#164999, FaTE #301899)
#if [ "$Y2_MODE" = "ncurses" ]; then
#    Y2_UI_ARGS=--nothreads
#fi

#=============================================
# 8) Call YaST2
#---------------------------------------------
Y2_MODULE_NAME=${1:-installation}; shift
Y2_MODULE_ARGS=\(\"$*\"\)
start_yast

#=============================================
# 9) Clean sweep
#---------------------------------------------
# 9.1) clear Qt environment...
clr_inst_qt_env

# 9.2) kill X-Server...
if [ "$server_running" = 1 ];then
	sleep 1 && kill $xserver_pid
	while kill -0 $xserver_pid 2>/dev/null ; do
		sleep 1
	done
fi

#=============================================
# 10) exit with YaST2 exit code
#---------------------------------------------
exit $Y2_EXIT_CODE

