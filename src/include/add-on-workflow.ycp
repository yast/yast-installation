/**
 * File:
 *      include/installation/add-on-workflow.ycp
 *
 * Module:
 *      System installation
 *
 * Summary:
 *      Add-on product installation workflow
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 *
 */



{

textdomain "installation";

import "AddOnProduct";
import "Linuxrc";
import "Mode";
import "Popup";
import "Report";
import "Sequencer";
import "SourceManager";
import "PackageSystem";
import "SuSEFirewall";
import "Stage";
import "Wizard";

include "packager/inst_source_dialogs.ycp";

/**
 * Initialize current inst. sources
 */
symbol Read () {
    Pkg::SourceStartManager(true);
    return `next;
}

/**
 * Write (changed) inst. sources
 */
symbol Write () {
    Pkg::SourceFinishAll();
    return `next;
}

// Used for adding sources
symbol createResult = `again;

/**
 * Checks whether some network is available in the current moment,
 * see the bug #170147 for more information.
 */
boolean IsAnyNetworkAvailable () {
        boolean ret = false;
        
        string command = "TERM=dumb /sbin/ip -o address show | grep inet | grep -v scope.host";
        y2milestone("Running %1", command);
        map cmd_run = (map) SCR::Execute(.target.bash_output, command);
        y2milestone("Command returned: %1", cmd_run);

        // command failed
        if (cmd_run["exit"]:-1 != 0) {
            // some errors were there, we don't know the status, rather return that it's available
            // `grep` also returns non zero exit code when there is nothing to do...
            if (cmd_run["stdout"]:"" != "") {
                y2error("Checking the network failed");
                ret = true;
            }
        // some devices are listed
        } else if (cmd_run["stdout"]:"" != nil && cmd_run["stdout"]:"" != "" && cmd_run["stdout"]:"" != "\n") {
            ret = true;
        }
        
        return ret;    
}

/**
 * Creates dialog content for MediaSelect
 */
void CreateMediaSelectDialog () {
    term contents = `HBox (`HStretch (), `VBox (
	`RadioButtonGroup (`id (`type), `VBox (
	    `VStretch (),
	    // radio button
	    `Left (`RadioButton(`id(`slp),       _("&Scan Using SLP..."))),
	    // radio button
	    `Left (`RadioButton(`id(`ftp),       _("&FTP..."))),
	    // radio button
	    `Left (`RadioButton(`id(`http),      _("&HTTP..."))),
	    // radio button
	    `Left (`RadioButton(`id(`https),      _("HTT&PS..."))),
	    // radio button
	    `Left (`RadioButton(`id(`samba),     _("&SMB/CIFS"))),
	    // radio button
	    `Left (`RadioButton(`id(`nfs),       _("&NFS..."))),
	    // radio button
	    `Left (`RadioButton(`id(`cd),        _("&CD..."))),
	    // radio button
	    `Left (`RadioButton(`id(`dvd),       _("&DVD..."))),
	    // radio button
	    `Left (`RadioButton(`id(`local_dir), _("&Local Directory..."))),
	    // radio button
	    `Left (`RadioButton (`id (`specify_url),_("Specify &URL..."))),
	    `VStretch ()
	))), `HStretch ()
    );
    if (! IsAnyNetworkAvailable()) {
	y2milestone ("Network is not available, skipping all Network-related options...");

	contents = `HBox (`HStretch (), `VBox (
	    `RadioButtonGroup (`id (`type), `VBox (
		`VStretch (),
		// radio button
		`Left (`RadioButton(`id(`cd),        _("&CD..."))),
		// radio button
		`Left (`RadioButton(`id(`dvd),       _("&DVD..."))),
		// radio button
		`Left (`RadioButton(`id(`local_dir), _("&Local Directory..."))),
		// radio button
		`Left (`RadioButton (`id (`specify_url),_("Specify &URL..."))),
		`VStretch ()
	    ))), `HStretch ()
	);
    } else {
	y2milestone("Network is available, allowing Network-related options...");
    }

    // dialog caption
    string title = _("Add-On Product Media");
    // help
    string help_text = _("<p><big><b>Catalog Media</b></big><br>
Add-on products can be installed from CD, over a
network, or from the hard disk.</p>
");

    // help, continued
    help_text = help_text + _("<p>
To install add-on product from <b>CD</b>,
have the product CD set or the DVD available.</p>");

    // help, continued
    help_text = help_text + _("<p>
The product CDs can be copied to the hard disk.
Insert the path where the first
CD is located, for example, /data1/<b>CD1</b>.
Only the base path is required if all CDs are copied
into one directory.</p>
");

    // help, continued
    help_text = help_text + _("<p>
Network installation requires a working network connection.
Specify the directory where the packages from
the first CD are located, such as /data1/CD1.</p>
");

    Wizard::SetContents (title, contents, help_text, Stage::initial(), true);
}

/**
 * Returns begining string for source type
 *
 * @param symbol source_type
 * @return string url begins with...
 */
string GetURLBeginsWith (symbol source_type) {
    string url = "";

    if      ( source_type == `ftp ) url = "ftp://";
    else if ( source_type == `http ) url = "http://";
    else if ( source_type == `https ) url = "https://";
    else if ( source_type == `samba ) url = "smb://";
    else if ( source_type == `nfs ) url = "nfs://";
    else if ( source_type == `cd ) url = "cd:///";
    else if ( source_type == `dvd ) url = "dvd:///";
    else if ( source_type == `local_dir ) url = "dir://";

    return url;
}

/**
 * Run dialog for selecting the media
 * @return symbol for wizard sequencer
 */
symbol MediaSelect () {
    // FIXME: this function is ugly
    //        rewrite especially handling `back (see #216910)
    y2milestone ("Running media select dialog");
    CreateMediaSelectDialog();

    symbol ret = nil;
    string url = "";
    while (ret == nil) {
	ret = (symbol) UI::UserInput ();
	if (ret == `back) {
	    // bugzilla #216910
	    // `back means - return to the previous dialog
	    // in Mode::normal, there is no previous dialog
	    if (Mode::normal()) {
		ret = nil;
		continue;
	    } else {
		break;
	    }
	}
	else if (ret == `abort || ret == `cancel)
	{
	    ret = `abort;
	    // yes-no popup
	    if (Popup::YesNo (_("Really abort add-on product installation?")))
		break;

	    ret = nil;
	    continue;
	}
	else if (ret != `next)
	    continue;


	createResult = nil;
	symbol input = (symbol)UI::QueryWidget (`id (`type), `CurrentButton);
	y2milestone ("Current: %1", input);
	if ( input == `slp )
	{
	    string required_package = "yast2-slp";
	    boolean installed_before = PackageSystem::Installed (required_package);

	    if (! Mode::installation () && ! installed_before) {
		// Tries to Check and Install packages
		if (
		    ! PackageSystem::CheckAndInstallPackagesInteractive ([required_package]) ||
		    ! PackageSystem::Installed (required_package)
		) {
		    Report::Error (sformat (
			// popup error message, %1 is the package name
			_("Cannot search for SLP installation sources
without having %1 package installed"),
			required_package
		    ));
		    y2warning ("Not searching for SLP sources");
		    ret = nil;
		    continue;
		// New .slp agent has been added
		// FIXME: lazy loading of agents will make this obsolete
		} else {
		    SCR::RegisterAgent(.slp, `ag_slp(`SlpAgent()));
		}
	    }

	    // moved to another function
	    ret = (symbol) WFM::call("add_inst_source_slptype");
	    y2milestone("SLP-Add returned: %1", ret);
	    if (ret == `next)
		createResult = `ok;
	    else
		ret = nil;
		continue;
	}
	else if (contains ([`ftp, `http, `https, `samba, `nfs, `cd, `dvd,
	    `local_dir, `specify_url], input))
	{
	    url = GetURLBeginsWith (input);

	    if (input == `cd || input == `dvd)
	    {
		Pkg::SourceReleaseAll();
		string msg = input == `cd
		    ? _("Insert the add-on product CD")
		    : _("Insert the add-on product DVD");

		// bugzilla #237264
		boolean ask_for_media = SourceManager::AskForCD (msg);
		y2milestone ("SourceManager::AskForCD returned: %1", ask_for_media);
		if (ask_for_media == true) {
		    createResult = SourceManager::createSource( url);
		} else {
		    createResult = nil;
		    ret = nil;
		    continue;
		}
	    }
	    else
	    {
	      do {
		url = editUrl( url );
		y2milestone ("New url: '%1'", url);
		if (url == nil || url == "") {
		    break;
		} else {
		    y2milestone ("Adding source");
		    createResult = SourceManager::createSource( url);
		}
              } while ( createResult == `again );
	      y2milestone ("New Add-On: finished");
	    }
        }
	if (createResult != `ok)
	{
	    ret = nil;
	    continue;
	}
    }

    AddOnProduct::last_ret = ret;
    y2milestone ("Media Select Dialog ret: %1", ret);
    return ret;
}

/**
 * Run dialog for selecting the catalog on the media (if more than one present)
 * @return symbol for wizard sequencer
 */
symbol CatalogSelect () {
    list<integer> sources = SourceManager::newSources;
    y2milestone("New sources: %1", sources);

    if (size (sources) == 0)
    {
	// error report
	Report::Error (_("No catalog found on medium."));
	return `back;
    }

    if (size (sources) == 1)
    {
	if (AddOnProduct::last_ret != `next)
	{
	    y2milestone ("Deleting source %1", sources[0]:0);
	    Pkg::SourceDelete(sources[0]:0);
	    return AddOnProduct::last_ret;
	}

	// busy message
	UI::OpenDialog(`Label(_("Initializing new source...")));
	integer src_id = SourceManager::newSources[0]:0;
	map data = Pkg::SourceGeneralData (src_id);
	y2milestone("Adding product: %1", data);
	string url = data["url"]:"";
	string product_dir = data["product_dir"]:"";
	y2milestone ("Deleting source %1", src_id);
	Pkg::SourceDelete (src_id);
	src_id = Pkg::SourceCreate (url, product_dir);
	SourceManager::newSources = [src_id];
	UI::CloseDialog();

	if (src_id == -1)
	{
	    // error report
	    Report::Error (_("Failed to initialize the catalog."));
	    AddOnProduct::ClearRegistrationRequest (src_id);
	    return `finish;
	}
/*
// moved below, in order to check whether the product has been installed first
	// Display /media.1/info.txt if such file exists
	// Display license and wait for agreement
	boolean license_ret = AddOnProduct::AcceptedLicenseAndInfoFile(src_id);
	if (license_ret != true) {
	    y2milestone("Removing the current source ID %1", src_id);
	    Pkg::SourceDelete(src_id);
	    return `finish;
	}
*/
	AddOnProduct::src_id = src_id;
	SourceManager::newSources = [src_id];
	y2milestone ("Only one source available - skipping dialog");
	return AddOnProduct::last_ret;
    }
    y2milestone ("Running catalog select dialog");
    list catalogs = maplist (integer src, sources, {
	map data = Pkg::SourceGeneralData (src);
	// placeholder for unknown directory
	string dir = data["product_dir"]:_("Unknown");
	if (dir == "")
	    dir = "/";
	return `item (`id (src), sformat (_("URL: %1, Directory: %2"),
	    // place holder for unknown URL
	    data["url"]:_("Unknown"), dir));
    });

    // dialog caption
    string title = _("Catalog Selection");
    // help text
    string help_text = _("<p><big><b>Catalog Selection</b></big><br>
There were multiple catalogs found on the selected medium.
Select the catalog to use.</p>
");

    term contents = `HBox (`HSpacing(4), `VBox (
	`VSpacing (2),
	`SelectionBox (`id (`catalogs), _("&Found Catalogs"), catalogs),
	`VSpacing (2)
    ), `HSpacing (4));
    Wizard::SetContents (title, contents, help_text, true, true);
    symbol ret = nil;
    integer selected = nil;
    while (ret == nil)
    {
	ret = (symbol)UI::UserInput ();
	if (ret == `abort || ret == `cancel)
	{
	    ret = `abort;
/*	    if (Stage::initial())
	    {
	        if (Popup::ConfirmAbort (`painless))
		    break;
	    }
	    else
	    {*/
		// yes-no popup
		if (Popup::YesNo (_("Really abort add-on product installation?")))
		    break;
//	    }
	    continue;
	}
	else if (ret == `back)
	{
	    break;
	}
	else if (ret == `next)
	{
	    selected = (integer)UI::QueryWidget (`id (`catalogs), `CurrentItem);
	    if (selected == nil)
	    {
		ret = nil;
		// popup message
		Popup::Message (_("Select a catalog."));
	    }
	}
    }

    if (ret != `next)
    {
	foreach (integer src, SourceManager::newSources, {
	    y2milestone ("Deleting source %1", src);
	    Pkg::SourceDelete (src);
	});
    }
    else
    {
	foreach (integer src, SourceManager::newSources, {
	    if (src != selected)
	    {
		y2milestone ("Deleting source %1", src);
		Pkg::SourceDelete (src);
	    }
	});
	map data = Pkg::SourceGeneralData (selected);
	string url = data["url"]:"";
	string product_dir = data["product_dir"]:"";
	y2milestone ("Deleting source %1", selected);
	Pkg::SourceDelete (selected);
	selected = Pkg::SourceCreate (url, product_dir);
	SourceManager::newSources = [selected];
	if (selected == -1)
	{
	    // error report
	    Report::Error (_("Failed to initialize the catalog."));
	    AddOnProduct::ClearRegistrationRequest (selected);
	    return `finish;
	}

	AddOnProduct::src_id = selected;
	SourceManager::newSources = [selected];
    }
    AddOnProduct::last_ret = ret;
    return ret;
}

symbol ProductSelect () {
    list<map<string,any> > all_products = Pkg::ResolvableProperties ("", `product, "");

    map <string, string> already_used_urls = $[];
    // getting all source urls and product_dirs
    foreach (map<string,any> p, all_products, {
	integer one_src_id = tointeger(p["source"]:nil);
	if (one_src_id == nil) return;
	// the last source (just added)
	if (one_src_id == AddOnProduct::src_id) return;

	map <string, any> src_general_data = Pkg::SourceGeneralData (one_src_id);
	string source_url = src_general_data["url"]:"";
	if (source_url != "" && source_url != nil) {
	    already_used_urls[source_url] = src_general_data["product_dir"]:"";
	}
    });
    y2milestone ("Already used urls with product_dirs: %1", already_used_urls);
    
    list<map<string,any> > installed_products = filter (map<string,any> p, all_products, {
	return p["status"]:nil == `selected || p["status"]:nil == `installed;
    });
    y2milestone ("Already installed/selected products: %1", installed_products);
    list<map<string,any> > products = filter (map<string,any> p, all_products, {
	return p["source"]:-1 == AddOnProduct::src_id;
    });
    y2milestone ("Products on the media: %1", products);

    // there are no product on the given url
    if (size (products) == 0)
    {
	y2milestone ("No poduct found on the media, but anyway, using it :-)");
	// Display /media.1/info.txt if such file exists
	// Display license and wait for agreement
	// FIXME the same code is below
	boolean license_ret = AddOnProduct::AcceptedLicenseAndInfoFile(AddOnProduct::src_id);
	if (license_ret != true) {
	    y2milestone("Removing the current source ID %1", AddOnProduct::src_id);
	    Pkg::SourceDelete(AddOnProduct::src_id);
	    return `abort;
	}

        map data = Pkg::SourceGeneralData (AddOnProduct::src_id);
        string url = data["url"]:"";
        string product_dir = data["product_dir"]:"";
	AddOnProduct::add_on_products = add (AddOnProduct::add_on_products, $[
	    "media" : AddOnProduct::src_id,
	    // table cell
	    "product" : _("No product found in the catalog"),
	    "media_url" : url,
	    "product_dir" : product_dir,
	]);
	if (Mode::config ())
	{
	    AddOnProduct::mode_config_sources
		= add (AddOnProduct::mode_config_sources, AddOnProduct::src_id);
	}
	return `next;
    }

// disabling functionality (partly bugzilla #227605)
// we know whether this product is already installed
// but we can't know whether the source hasn't been already removed
// 
//    products = filter (map<string,any> prod, products, {
//	boolean installed = false;
//	find (map<string,any> p, installed_products, {
//	    if (p["name"]:"" == prod["name"]:"" && p["version"]:"" == prod["version"]:"")
//	    {
//		installed = true;
//		y2milestone ("Product %1 installed", p);
//		return true;
//	    }
//	    return false;
//	});
//	if (installed)
//	{
//	    y2milestone ("Removing %1 from the list of available products", prod);
//	    return false;
//	}
//	return true;
//    });
//    if (size (products) == 0)
//    {
//	// message popup
//	Popup::Message (_("The product on the media is already installed
//or selected for installation."));
//	y2milestone ("Deleting installatino source %1", AddOnProduct::src_id);
//	Pkg::SourceDelete (AddOnProduct::src_id);
//	AddOnProduct::ClearRegistrationRequest (AddOnProduct::src_id);
//	return `finish;
//    }
    // Display /media.1/info.txt if such file exists
    // Display license and wait for agreement
    // FIXME the same code is above
    boolean license_ret = AddOnProduct::AcceptedLicenseAndInfoFile(AddOnProduct::src_id);
    if (license_ret != true) {
	    y2milestone("Removing the current source ID %1", AddOnProduct::src_id);
	    Pkg::SourceDelete(AddOnProduct::src_id);
	    return `abort;
    }

    // there is only one product on the given url
    if (size (products) == 1)
    {
	// bugzilla #227605
	// this product with this url has been already installed or selected for installation
	map <string, any> src_general_data = Pkg::SourceGeneralData (AddOnProduct::src_id);
	string current_url = src_general_data["url"]:"";
	if (current_url != "" && current_url != nil) {
	    y2milestone ("%1", already_used_urls);
	    if (already_used_urls[current_url]:"" == src_general_data["product_dir"]:"") {
		// error pop-up
		Popup::Message (_("The product on the media is already installed
or selected for installation."));
		y2milestone ("Deleting installation source %1 %2 (%3)",
		    AddOnProduct::src_id, current_url, src_general_data["product_dir"]:"");
		Pkg::SourceDelete (AddOnProduct::src_id);
		AddOnProduct::ClearRegistrationRequest (AddOnProduct::src_id);
		return `finish;
	    }
	}

	y2milestone ("Only one product available - skipping dialog");
	map<string,any> prod = products[0]:$[];
	if (! AddOnProduct::CheckProductDependencies ([prod["name"]:""]))
	{
	    Pkg::ResolvableRemove (prod["name"]:"", `product);
	    // message popup
	    Popup::Message (_("Dependencies of the add-on product cannot be fulfilled."));
	    AddOnProduct::last_ret = `back;
	    return `back;
	}
	// check whether the product is already available on some media - it is similar as below
	integer found_source = -1;
	foreach (map<string,any> p, all_products, {
	    if (p["name"]:"" == prod["name"]:"" && p["version"]:"" == prod["version"]:""
		&& p["media"]:-2 != prod["media"]:-3)
	    {
		y2milestone ("Product %1 already available on media %2", p, p["media"]:-1);
		found_source = p["media"]:-1;
		break;
	    }
	});
	if (found_source != -1)
	{
	    y2milestone ("Deleting source %1", AddOnProduct::src_id);
	    Pkg::SourceDelete (AddOnProduct::src_id);
	    AddOnProduct::src_id = found_source;
	}
	Pkg::ResolvableInstall (prod["name"]:"", `product);
        map data = Pkg::SourceGeneralData (AddOnProduct::src_id);
        string url = data["url"]:"";
        string product_dir = data["product_dir"]:"";
	AddOnProduct::add_on_products = add (AddOnProduct::add_on_products, $[
	    "media" : AddOnProduct::src_id,
	    "product" : prod["display_name"]:prod["short_name"]:prod["name"]:"",
	    "media_url" : url,
	    "product_dir" : product_dir,
	]);
	if (found_source == -1 && Mode::config ())
	{
	    AddOnProduct::mode_config_sources =
		add (AddOnProduct::mode_config_sources, AddOnProduct::src_id);
	}
	return `next;
    }

    // there are more than one products on the given url
    y2milestone ("Running product selection dialog");
    symbol ret = nil;
    list items = maplist (map<string,any> product, products, {
	return `item (`id (product["name"]:""), product["name"]:"");
    });
    // dialog caption
    string title = _("Product Selection");
    term contents = `HBox (`HStretch(), `VBox (
	`VStretch (),
	// multi selection list
	`MultiSelectionBox (`id (`products), _("Available Products"), items),
	`VStretch ()
    ), `HStretch ());
    // help text
    string help_text = _("<p><b><big>Product Selection</big></b><br>
There were multiple products found in the catalog. Select the products
to install.</p>
");
    Wizard::SetContents (title, contents, help_text, true, true);
    while (ret == nil)
    {
	ret = (symbol)UI::UserInput();
	if (ret == `cancel || ret == `abort)
	{
	    ret = `abort;
/*	    if (Stage::initial())
	    {
	        if (Popup::ConfirmAbort (`painless))
		    break;
	    }
	    else
	    {*/
		// yes-no popup
		if (Popup::YesNo (_("Really abort add-on product installation?")))
		    break;
//	    }
	    continue;
	}
	if (ret == `next)
	{
	    list<string> selected = (list<string>)UI::QueryWidget (`id (`products), `SelectedItems);
	    // check whether the product is already available on some media - it is similar as above
	    list<map<string,any> > prods = filter (map<string,any> p, products, {
		return contains (selected, p["name"]:"");
	    });
	    boolean all_found = true;
	    map<string,integer> prod2src = $[];
	    foreach (map<string,any> prod, prods, {
	      boolean product_found = false;
	      foreach (map<string,any> p, all_products, {
		if (p["name"]:"" == prod["name"]:"" && p["version"]:"" == prod["version"]:""
		    && p["media"]:-2 != prod["media"]:-3)
		{
		    product_found = true;
		    prod2src[prod["name"]:""] = p["media"]:-3;
		    break;
		}
	      });
	      all_found = all_found && product_found;
	    });
	    if (all_found)
	    {
	        y2milestone ("Deleting source %1", AddOnProduct::src_id);
		Pkg::SourceDelete (AddOnProduct::src_id);
		AddOnProduct::src_id = -1;
	    }
	    foreach (string product, selected, {
		Pkg::ResolvableInstall (product, `product);
	    });
	    if (! AddOnProduct::CheckProductDependencies (selected))
	    {
		foreach (string product, selected, {
		    Pkg::ResolvableRemove (product, `product);
		});
		// message popup
		Popup::Message (_("Dependencies of the selected add-on products cannot be fulfilled."));
		ret = nil;
		continue;
	    }
	    map data = Pkg::SourceGeneralData (AddOnProduct::src_id);
	    string url = data["url"]:"";
	    string product_dir = data["product_dir"]:"";

	    // bugzilla #227605
	    // this product with this url has been already installed or selected for installation
	    if (url != "" && url != nil) {
		if (already_used_urls[url]:"" == product_dir) {
		    // error pop-up
		    Popup::Message (_("The product on the media is already installed
or selected for installation."));
		    y2milestone ("Deleting installation source %1 %2 (%3)",
			AddOnProduct::src_id, url, product_dir);
		    Pkg::SourceDelete (AddOnProduct::src_id);
		    AddOnProduct::ClearRegistrationRequest (AddOnProduct::src_id);
		    return `finish;
		}
	    }

	    foreach (string product, selected, {
		AddOnProduct::add_on_products = add (AddOnProduct::add_on_products, $[
		    "media" : AddOnProduct::src_id == -1
			? prod2src[product]:-1
			: AddOnProduct::src_id,
		    "product" : product,
		    "media_url" : url,
		    "product_dir" : product_dir,
		]);
	    });
	    if ( AddOnProduct::src_id != -1 && Mode::config ())
	    {
		AddOnProduct::mode_config_sources =
		    add (AddOnProduct::mode_config_sources, AddOnProduct::src_id);
	    }
	}
	else if (ret != `back)
	{
	    ret = nil;
	}
    }

    if (ret == `abort)
    {
	y2milestone ("Deleting source %1", AddOnProduct::src_id);
	Pkg::SourceDelete (AddOnProduct::src_id);
    }

    AddOnProduct::last_ret = ret;
    return ret;
}

symbol RunWizard() {
    map aliases = $[
	"media" : ``(MediaSelect ()),
	"catalog" : ``(CatalogSelect ()),
	"product" : ``(ProductSelect ()),
    ];

    map sequence = $[
	"ws_start" : "media",
	"media" : $[
	    `abort : `abort,
	    `next : "catalog",
	    `finish : `next,
	],
	"catalog" : $[
	    `abort : `abort,
	    `next : "product",
	    `finish : `next,
	],
	"product" : $[
	    `abort : `abort,
	    `next : `next,
	    `finish : `next,
	],
    ];
    return Sequencer::Run(aliases, sequence);
}

symbol RunAutorunWizard() {
    map aliases = $[
	"catalog" : ``(CatalogSelect ()),
	"product" : ``(ProductSelect ()),
    ];

    map sequence = $[
	"ws_start" : "catalog",
	"catalog" : $[
	    `abort : `abort,
	    `next : "product",
	    `finish : `next,
	],
	"product" : $[
	    `abort : `abort,
	    `next : `next,
	    `finish : `next,
	],
    ];
    return Sequencer::Run(aliases, sequence);

}


void Redraw (boolean enable_back, boolean enable_next, string back_button, string next_button) {
    y2milestone ("Called Redraw()");
    // main screen heading
    string title = _("Add-On Product Installation");

    // Help for add-on products
    string help = _("<p><big><b>Add-On Product Installation</b></big></br>
Here see all add-on products that are selected for installation.
To add a new product, click <b>Add</b>. To remove an already added one,
select it and click <b>Delete</b>.</p>");

    integer index = -1;
    list items = maplist (map<string,any> product, AddOnProduct::add_on_products, {
	index = index + 1;
	map data = Pkg::SourceGeneralData (product["media"]:-1);
	// placeholder for unknown path
	string dir = data["product_dir"]:_("Unknown");
	if (dir == "")
	    dir = "/";
	// table cell, %1 is URL, %2 is directory name
	string media = sformat (_("URL: %1, Directory: %2"),
	    // placeholder for unknown URL
	    data["url"]:_("Unknown"), dir);
	return `item (`id (index),
	    media,
	    // sformat (_("Product %1"), product["product"]:"")
	    product["product"]:""
	);
    });
    term contents = `VBox (
	`Table (`id (`summary), `header (
		// table header
		_("Media"),
		// table header
		_("Product")),
	    items),
	`Left(
	    `HBox (
		`PushButton (`id (`add), Label::AddButton ()),
		`PushButton (`id (`delete), Label::DeleteButton ()),
		`HStretch ()
	    )
	)
    );

    Wizard::SetContentsButtons (title, contents, help, back_button, next_button);
    if (! enable_back) Wizard::DisableBackButton();
    if (! enable_next) Wizard::DisableNextButton();

    Wizard::SetDesktopIcon("vendor");

    // disable delete button if no items listed
    // bug #203809
    if (size(items) == 0) {
	UI::ChangeWidget(`id (`delete), `Enabled, false);
    }
}

// bugzilla #221377
// the original control file is stored as /control.xml
// the other (added) control files are under the
// /tmp/$yast_tmp/control_files/ directory
// as $srcid.xml files
//
// bugzilla #237297
// in the installation workflow - back/ next buttons
// in the installation proposal - cancel / accept buttons
//
symbol RunAddOnMainDialog (boolean enable_back, boolean enable_next, string back_button, string next_button) {
    Redraw (enable_back, enable_next, back_button, next_button);
    symbol ret = nil;

    // added / removed
    boolean some_addon_changed = false;

    // store the initial settings, only once
    AddOnProduct::StoreInitialSettings();

    repeat {
        ret = (symbol) Wizard::UserInput();

	// aborting
        if (ret == `abort || ret == `cancel) {
            if (Popup::ConfirmAbort (`incomplete))
                break;

	// removing add-on
        } else if (ret == `delete) {
            integer selected = (integer) UI::QueryWidget (`id (`summary), `CurrentItem);
            if (selected == nil) {
                // message report
                Report::Message (_("Select a product to delete."));
                continue;
            }

            // remove whole media if the product is the only one on the media
            integer media = AddOnProduct::add_on_products[selected, "media"]:-1;
            integer med_count = size (filter (map<string,any> prod,
                AddOnProduct::add_on_products,
            {
                return prod["media"]:-1 == media;
            }));
            if (med_count == 1) {
		y2milestone ("Deleting source %1", media);
                Pkg::SourceDelete (media);
	    }

            // remove the selected record
            AddOnProduct::add_on_products[selected] = nil;
            AddOnProduct::add_on_products = filter (map<string,any> prod,
		AddOnProduct::add_on_products,
	    {
                return prod != nil;
            });
	    
	    // remove a temporary file, not needed anymore
	    // bugzilla #238307
	    AddOnProduct::RemoveAddOnControlFile (media);
	    some_addon_changed = true;
	    // remove product from list of product to register (FATE #301312)
	    AddOnProduct::RemoveRegistrationFlag (media);
	    
            Redraw (enable_back, enable_next, back_button, next_button);

	// adding new add-on
        } else if (ret == `add) {
            symbol ret = RunWizard ();
	    if (ret == `next) {
		// check whether it requests registration (FATE #301312)
		AddOnProduct::PrepareForRegistration (AddOnProduct::src_id);
		some_addon_changed = true;
	    }
            Redraw (enable_back, enable_next, back_button, next_button);
        }

    } until ( ret == `next || ret == `back );
    y2milestone ("Ret: %1, Some Add-on Added/Removed: %2", ret, some_addon_changed);
    y2milestone ("Registration will be requested: %1", AddOnProduct::ProcessRegistration());

    if (Mode::installation() && Stage::initial()) {
	// bugzilla #221377
	if (some_addon_changed) {
	    AddOnProduct::ReIntegrateFromScratch();
	}
    }
    
    return ret;
}


} //end of include
