/**
 * File:	clients/inst_finish.ycp
 * Package:	installation
 * Summary:	Finish installation
 * Authors:	Klaus KÃ¤mpf <kkaempf@suse.de>
 *		Arvin Schnell <arvin@suse.de>
 *              Jiri Srain <jsrain@suse.de>
 *
 * $Id$
 *
 * Writes:
 * [target] /var/lib/YaST2/runme_at_boot	run yast2 after initial boot
 * SCR::Write (.etc.shadow.root,
 */

{
    textdomain "installation";

    import "AddOnProduct";
    import "WorkflowManager";
    import "Installation";
    import "Linuxrc";
    import "Misc";
    import "Mode";
    import "Stage";
    import "Popup";
    import "ProductControl";
    import "Progress";
    import "Report";
    import "Wizard";



// Help text for last dialog of base installation
string help_text = _("<p>
Please wait while the base system is being installed.
</p>");

list<map<string,any> > stages = [
    $[
	// progress stage
	"label" : _("Copy files to installed system"),
	"steps" : [
	    "autoinst_scripts1",
	    "mouse",
	    "copy_files",
	    "copy_systemfiles",
	    "switch_scr",
	],
    ],
    $[
	// progress stage
	"label" : _("Save configuration"),
	"steps" : [
	    "ldconfig",
	    "save_config",
	    "runlevel",
	    "desktop",
	    "fonts",
	    "storage",
	    "iscsi-client",
	    "kernel",
	    "x11",
	    "proxy",
	    "pkg",
	    "driver_update1",
	    "yast_inf",
	],
    ],
    $[
	// progress stage
	"label" : _("Install boot manager"),
	"steps" : [
	    "bootloader",
	],
    ],
    $[
	// progress stage
	"label" : _("Save installation settings"),
	"steps" : [
	    "network",
	    "ntp-client",
	    "ssh_settings",
	    "save_hw_status",
	    "users",
	    "autoinst_scripts2",
	],
    ],
    $[
	// progress stage
	"label" : _("Prepare system for initial boot"),
	"steps" : [
	    "vm",
	    "driver_update2",
	    "pre_umount",
	    // copy logs just before 'umount'
	    // keeps maximum logs available after reboot
	    "copy_logs",
	    "umount",
	],
    ],
];

if (size (ProductControl::inst_finish) > 0)
{
    y2milestone ("Using inst_finish steps definition from control file");
    stages = ProductControl::inst_finish;

    // Inst-finish need to be translated (#343783)
    string textdom = ProductControl::productControl["textdomain"]:"control";
    list <map<string,any> > stages_copy = stages;

    y2milestone ("Inst finish stages before: %1", stages);

    integer counter = -1;
    // going through copy, the original is going to be changed in the loop
    foreach (map<string,any> one_stage, stages_copy, {
	counter = counter + 1;
	string label = one_stage["label"]:"";

	if (label == nil || label == "") return;

	string loc_label = dgettext (textdom, label);
	// if translated
	if (loc_label != nil && loc_label != "" && loc_label != label) {
	    stages[counter, "label"] = loc_label;
	}
    });

    y2milestone ("Inst finish stages after: %1", stages);
}
else
{
    y2milestone ("inst_finish steps definition not found in control file");
}

// merge steps from add-on products
stages[0, "steps"] = merge (
    WorkflowManager::GetAdditionalFinishSteps("before_chroot"),
    stages[0, "steps"]:[]
);
stages[1, "steps"] = merge (
    WorkflowManager::GetAdditionalFinishSteps("after_chroot"),
    stages[1, "steps"]:[]
);
stages[3, "steps"] = merge (
    stages[3, "steps"]:[],
    WorkflowManager::GetAdditionalFinishSteps("before_umount")
);

symbol run_type = `installation;
if (Mode::update ())
    run_type = `update;
else if (Mode::autoinst ())
    run_type = `autoinst;

integer steps_count = 0;

stages = maplist (map<string,any> stage, stages, {
    list<map> steps = maplist (string s, stage["steps"]:[], {
	s = s + "_finish";
	map info = (map)WFM::CallFunction (s, ["Info"]);
	if (info == nil)
	{
	    y2error ("Client %1 returned invalid data", s);
	    return nil;
	}
	if (info["when"]:nil != nil && ! contains (info["when"]:[], run_type))
	    return nil;
	info["client"] = s;
	steps_count = steps_count + info["steps"]:1;
	return info;
    });
    stage["steps"] = filter (map s, steps, {
	return s != nil;
    });
    return stage;
});

stages = filter (map<string,any> s, stages, {
    return size (s["steps"]:[]) > 0;
});

list<string> stage_names = maplist (map<string,any> s, stages, {
    return s["label"]:"";
});

Progress::New(
    // Headline for last dialog of base installation: Install LILO etc.
    _("Finishing Basic Installation"),
    "",	// Initial progress bar label - not empty (reserve space!)
    steps_count,
    stage_names,
    [],
    help_text);

Wizard::DisableBackButton ();
Wizard::DisableNextButton ();

Wizard::SetTitleIcon ("yast-sysconfig");

boolean aborted = false;

foreach (map<string,any> stage, stages, {
    Progress::NextStage ();
    boolean first = true;
    foreach (map step, stage["steps"]:[], {
	integer scount = step["steps"]:1;
	if (scount != 0)
	{
	    if (first)
		first = false;
	    else
		Progress::NextStep ();
	}
	if (haskey (step, "title"))
	    Progress::Title (step["title"]:"");
	WFM::CallFunction (step["client"]:"", ["Write"]);
	if (UI::PollInput () == `abort && Popup::ConfirmAbort (`incomplete))
	{
	    aborted = true;
	    break;
	}
    });
    if (aborted)
	break;
});

if (aborted)
{
    y2milestone ("inst_finish aborted");
    return `abort;
}

Progress::Finish();
Progress::Title (_("Finished."));

// --------------------------------------------------------------
// Check if there is a message left to display
// and display it, if necessary

// Do not call any SCR, it's already closed!
if (size (Misc::boot_msg) > 0 && !Mode::autoinst ())
{
    // bugzilla #245742, #160301
    if ((Linuxrc::usessh () && !Linuxrc::vnc())
	// also live installation - bzilla #297691
	|| Mode::live_installation ())
    {
	// Display the message and wait for user to accept it
	Report::DisplayMessages (true, 0);
    }
    else
	Report::DisplayMessages (true, 10);
    Report::Message (Misc::boot_msg);
    Misc::boot_msg = "";
}

return `next;

} // EOF
