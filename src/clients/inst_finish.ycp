/**
 * File:	clients/inst_finish.ycp
 * Package:	installation
 * Summary:	Finish installation
 * Authors:	Klaus KÃ¤mpf <kkaempf@suse.de>
 *		Arvin Schnell <arvin@suse.de>
 *              Jiri Srain <jsrain@suse.de>
 *
 * $Id$
 *
 * Writes:
 * [target] /var/lib/YaST2/runme_at_boot	run yast2 after initial boot
 * SCR::Write (.etc.shadow.root,
 */

{
    textdomain "installation";

    import "AddOnProduct";
    import "WorkflowManager";
    import "Installation";
    import "Linuxrc";
    import "Misc";
    import "Mode";
    import "Stage";
    import "Popup";
    import "ProductControl";
    import "Progress";
    import "Report";
    import "Wizard";

    // added for fate# 303395
    import "Directory";



// Help text for last dialog of base installation
string help_text = _("<p>
Please wait while the base system is being installed.
</p>");

list<map<string,any> > stages = [
    $[
	// progress stage
	"label" : _("Copy files to installed system"),
	"steps" : [
	    "autoinst_scripts1",
	    "mouse",
	    "copy_files",
	    "copy_systemfiles",
	    "live_copy_files",
	    "switch_scr",
	],
    ],
    $[
	// progress stage
	"label" : _("Save configuration"),
	"steps" : [
	    "ldconfig",
	    "save_config",
	    "live_save_config",
	    "runlevel",
	    "desktop",
	    "fonts",
	    "storage",
	    "iscsi-client",
	    "kernel",
	    "x11",
	    "proxy",
	    "pkg",
	    "driver_update1",
	    "yast_inf",
	    // bnc #340733
	    "system_settings",
	],
    ],
    $[
	// progress stage
	"label" : _("Install boot manager"),
	"steps" : [
	    "bootloader",
	],
    ],
    $[
	// progress stage
	"label" : _("Save installation settings"),
	"steps" : [
	    "network",
	    "ntp-client",
	    "ssh_settings",
	    "save_hw_status",
	    "users",
	    "autoinst_scripts2",
	    "installation_settings",
	],
    ],
    $[
	// progress stage
	"label" : _("Prepare system for initial boot"),
	"steps" : [
	    "live_runme_at_boot",
	    "vm",
	    "driver_update2",
	    // no second stage if possible
	    "pre_umount",
	    // copy logs just before 'umount'
	    // keeps maximum logs available after reboot
	    "copy_logs",
	    "umount",
	],
    ],
];

if (size (ProductControl::inst_finish) > 0)
{
    y2milestone ("Using inst_finish steps definition from control file");
    stages = ProductControl::inst_finish;

    // Inst-finish need to be translated (#343783)
    string textdom = ProductControl::productControl["textdomain"]:"control";
    list <map<string,any> > stages_copy = stages;

    y2milestone ("Inst finish stages before: %1", stages);

    integer counter = -1;
    // going through copy, the original is going to be changed in the loop
    foreach (map<string,any> one_stage, stages_copy, {
	counter = counter + 1;
	string label = one_stage["label"]:"";

	if (label == nil || label == "") return;

	string loc_label = dgettext (textdom, label);
	// if translated
	if (loc_label != nil && loc_label != "" && loc_label != label) {
	    stages[counter, "label"] = loc_label;
	}
    });

    y2milestone ("Inst finish stages after: %1", stages);
}
else
{
    y2milestone ("inst_finish steps definition not found in control file");
}

// merge steps from add-on products
stages[0, "steps"] = merge (
    WorkflowManager::GetAdditionalFinishSteps("before_chroot"),
    stages[0, "steps"]:[]
);
stages[1, "steps"] = merge (
    WorkflowManager::GetAdditionalFinishSteps("after_chroot"),
    stages[1, "steps"]:[]
);
stages[3, "steps"] = merge (
    stages[3, "steps"]:[],
    WorkflowManager::GetAdditionalFinishSteps("before_umount")
);

symbol run_type = `installation;
if (Mode::update ())
    run_type = `update;
else if (Mode::autoinst ())
    run_type = `autoinst;
else if (Mode::live_installation ())
    run_type = `live_installation;

integer steps_count = 0;

stages = maplist (map<string,any> stage, stages, {
    list<map> steps = maplist (string s, stage["steps"]:[], {
	s = s + "_finish";

	y2milestone ("Calling inst_finish script: %1 (Info)", s);
// TODO: check if client exists
// client doesn't need to exist on purpose
	map info = (map)WFM::CallFunction (s, ["Info"]);

	if (info == nil) {
	    y2error ("Client %1 returned invalid data", s);
	    return nil;
	}

	if (info["when"]:nil != nil && ! contains (info["when"]:[], run_type))
	    return nil;

	y2milestone ("inst_finish client %1 will be called", s);
	info["client"] = s;
	steps_count = steps_count + info["steps"]:1;
	return info;
    });

    stage["steps"] = filter (map s, steps, {
	return s != nil;
    });

    return stage;
});

y2milestone ("These inst_finish stages will be called:");
foreach (map<string,any> stage, stages, {
    y2milestone ("Stage: %1", stage);
});

stages = filter (map<string,any> s, stages, {
    return size (s["steps"]:[]) > 0;
});

list<string> stage_names = maplist (map<string,any> s, stages, {
    return s["label"]:"";
});

Progress::New(
    // Headline for last dialog of base installation: Install LILO etc.
    _("Finishing Basic Installation"),
    "",	// Initial progress bar label - not empty (reserve space!)
    steps_count,
    stage_names,
    [],
    help_text);

Wizard::DisableBackButton ();
Wizard::DisableNextButton ();

Wizard::SetTitleIcon ("yast-sysconfig");

boolean aborted = false;

foreach (map<string,any> stage, stages, {
    Progress::NextStage ();
    boolean first = true;
    foreach (map step, stage["steps"]:[], {
	integer scount = step["steps"]:1;
	if (scount != 0)
	{
	    if (first)
		first = false;
	    else
		Progress::NextStep ();
	}
	if (haskey (step, "title"))
	    Progress::Title (step["title"]:"");
	WFM::CallFunction (step["client"]:"", ["Write"]);
	if (UI::PollInput () == `abort && Popup::ConfirmAbort (`incomplete))
	{
	    aborted = true;
	    break;
	}
    });
    if (aborted)
	break;
});

if (aborted)
{
    y2milestone ("inst_finish aborted");
    return `abort;
}

Progress::Finish();
Progress::Title (_("Finished."));

// --------------------------------------------------------------
// Check if there is a message left to display
// and display it, if necessary

// Do not call any SCR, it's already closed!
if (size (Misc::boot_msg) > 0 && !Mode::autoinst ())
{
    // bugzilla #245742, #160301
    if ((Linuxrc::usessh () && !Linuxrc::vnc())
	// also live installation - bzilla #297691
	|| Mode::live_installation ())
    {
	// Display the message and wait for user to accept it
	Report::DisplayMessages (true, 0);
    }
    else
	Report::DisplayMessages (true, 10);
    Report::Message (Misc::boot_msg);
    Misc::boot_msg = "";
}


// fate #303395: Use kexec to avoid booting between first and second stage
// run new kernel via kexec instead of reboot

// command for reading kernel_params
string cmd = sformat("ls %1 | grep kernel_params |tr -d '\n'", Directory::vardir);
y2milestone("Checking existing file kernel_params via command %1", cmd);

map out = (map)WFM::Execute(.local.bash_output, cmd);
// check output
if (out["stdout"]:"" != "kernel_params")
{
    y2milestone ("File kernel_params was not found, output: %1", out);
    return `next;
}

// command for reading kernel_params
cmd = sformat("cat %1/kernel_params |tr -d '\n'", Directory::vardir);
y2milestone("Reading kernel arguments via command %1", cmd);
// read data from /var/lib/YaST2/kernel_params
out = (map)WFM::Execute(.local.bash_output, cmd);
// check output
if (out["exit"]:nil != 0)
{
    y2error ("Reading kernel arguments failed, output: %1", out);
    return `next;
}

string kernel_args = out["stdout"]:"";
// check if kernel_params contains any data
if (size(kernel_args) <2)
{
    y2error ("%1/kernel_params is empty, kernel_params=%2 ", Directory::vardir, kernel_args);
    return `next;
}

// command for finding initrd file
cmd = sformat ("ls %1 |grep initrd- |tr -d '\n'", Directory::vardir);
y2milestone("Finding initrd file via command: %1", cmd);
// find inird file
out = (map)WFM::Execute(.local.bash_output, cmd);
// check output
if (out["exit"]:nil != 0)
{
    y2error ("Finding initrd file failed, output: %1", out);
    return `next;
}
 
string initrd = out["stdout"]:"";
// check if initrd (string) contains any data
if (size(initrd) <2)
{
    y2error ("initrd was not found: %1", initrd);
    return `next;
}
 
// command for finding vmlinuz file
cmd = sformat ("ls %1 |grep vmlinuz- |tr -d '\n'", Directory::vardir);
y2milestone("Finding vmlinuz file via command: %1", cmd);
// find inird file
out = (map)WFM::Execute(.local.bash_output, cmd);
// check output
if (out["exit"]:nil != 0)
{
    y2error ("Finding vmlinuz file failed, output: %1", out);
    return `next;
}
 
string vmlinuz = out["stdout"]:"";
// check if initrd (string) contains any data
if (size(vmlinuz) <2)
{
    y2error ("vmlinuz was not found: %1", vmlinuz);
    return `next;
}

// hack for using kexec switch to console 2
cmd = sformat ("chvt 2");
y2milestone("Switch to console 2 via command: %1", cmd);
// switch to console 2
out = (map)WFM::Execute(.local.bash_output, cmd);
// check output
if (out["exit"]:nil != 0)
{
    y2error ("Switching failed, output: %1", out);
    return `next;
}

// waiting 2s for switching...
sleep(2000);

// command for calling kexec
cmd = sformat("kexec -l --command-line=\"%1\" --initrd=%2/%3 %2/%4",
	kernel_args, Directory::vardir, initrd, vmlinuz);
y2milestone("Calling kexec via command: %1", cmd);

// call kexec
out = (map)WFM::Execute(.local.bash_output, cmd);
// check output
if (out["exit"]:nil != 0)
{
    y2error ("Calling kexec failed, output: %1", out);
    return `next;
}
// command for loading kernel
cmd = sformat("kexec -e");
y2milestone("Loading new kernel via command: %1", cmd);
// call loading kernel via kexec
out = (map) WFM::Execute(.local.bash_output, cmd);

return `next;

} // EOF
