/**
 * File:	clients/inst_automatic_configuration.ycp
 * Package:	installation
 * Summary:	Automatic configuration instead of the second stage
 * Authors:	Lukas Ocilka <locilka@suse.cz>
 *
 * $Id:$
 *
 * @see http://visnov.blogspot.com/2008/02/getting-rid-of-2nd-stage-of.html
 */

{
    import "Mode";
    import "Stage";
    import "FileUtils";
    import "Directory";
    import "GetInstArgs";
    import "Progress";
    import "Wizard";

    textdomain "installation";

    if (GetInstArgs::going_back()) {
	y2milestone ("Going back, nothing to do here...");
	return `auto;
    }

    y2milestone ("automatic_configuration started");

    Mode::SetMode ("installation");
    Stage::Set ("continue");

// TODO: read this from control file
// (at least the list of modules in proposals)
    list <map <string, any> > proposal_scripts_to_call = [
	// probably needed
	$[
	    "label":_("Initialization..."),
	    "type":"scripts",
	    "items":["initialization", "netprobe", "rpmcopy_secondstage"]
	],

	// network proposal
	$[
	    "label":_("Configuring network..."),
	    "type":"proposals",
	    "items":["lan", "general", "dsl", "isdn", "modem", "remote", "firewall"]
	],

	// hardware proposal
	$[
	    "label":_("Configuring hardware..."),
	    "type":"proposals",
	    "items":["x11", "printer", "sound", "tv"]
	],

	// probably needed
	$[
	    "label":_("Finishing configuration..."),
	    "type":"scripts",
	    "items":["addon_update_sources", "inst_extrasources", "suseconfig", "save_hardware_status"]
	],
    ];

    /**
     * Prepares the list of installation scripts to be executed.
     * This comes from control file where scripts are mentioned without the leading
     * "inst_" but they are actually named that way ("inst_something").
     *
     * @example ["aa", "inst_bb"] -> ["inst_aa", "inst_bb"]
     */
    list <string> NormalizeScriptNames (list <string> names) {
	list <string> ret_names = [];

	foreach (string one_name, names, {
	    if (regexpmatch (one_name, "^inst_")) {
		ret_names = add (ret_names, one_name);
	    } else {
		ret_names = add (ret_names, "inst_" + one_name);
	    }
	});

	return ret_names;
    }

    /**
     * Similar to NormalizeScriptNames but it add "_proposal" instead if "inst_".
     *
     * @example ["aa", "bb_proposal"] -> ["aa_proposal", "bb_proposal"]
     */
    list <string> NormalizeProposalNames (list <string> names) {
	list <string> ret_names = [];

	foreach (string one_name, names, {
	    if (regexpmatch (one_name, "_proposal$")) {
		ret_names = add (ret_names, one_name);
	    } else {
		ret_names = add (ret_names, one_name + "_proposal");
	    }
	});

	return ret_names;
    }

    void HandleExceptions (string proposal_name) {
	if (proposal_name == "x11_proposal" || proposal_name == "x11") {
	    if (! UI::TextMode()) {
		y2milestone ("Printing >don't panic<!");
		SCR::Write (.dev.tty.stderr,
		    _("

***********************************************************

Do not panic!

X11 Configuration must have switched to console for a while
to do detect your videocard properly...

***********************************************************
")
		);
	    }
	}
    }

    integer current_step = 0;
    integer current_sub_step = 0;
    integer nr_of_sub_steps = 0;

    void ResetSubSteps (integer substeps) {
	nr_of_sub_steps = substeps;
	current_sub_step = 0;
    }

    void NextStep (string progress_title) {
	current_step = current_step + 1;
	current_sub_step = current_sub_step + 1;

	if (nr_of_sub_steps > 0 && current_sub_step > 0 && nr_of_sub_steps >= current_sub_step) {
	    progress_title = sformat (
		// TRANSLATORS: Progress step label
		//	%1 - text defined by script, e.g., "Configuring hardware..."
		//	%2 - number of the current step
		//	%3 - number of all steps
		//	Finally, it might look like this "Configuring hardware... (2/5)"
		_("%1 (%2/%3)"),
		progress_title,
		current_sub_step,
		nr_of_sub_steps
	    );
	}

	Progress::Title (progress_title);
	Progress::Step (current_step);
    }

    void CallScripts (list <string> scripts_to_call, string progress_title) {
	y2milestone ("Scripts to call: %1", scripts_to_call);

	scripts_to_call = NormalizeScriptNames (scripts_to_call);
	// every single script has one step
	ResetSubSteps (size (scripts_to_call));

	foreach (string one_script, scripts_to_call, {
	    y2milestone ("Calling script %1", one_script);
	    NextStep (progress_title);
	    boolean progress_before = Progress::set (false);

	    any result = WFM::CallFunction (one_script, [ $["AutomaticConfiguration":true] ]);

	    Progress::set (progress_before);
	    y2milestone ("Script %1 returned %2", one_script, result);
	});
    }

    void CallProposals (list <string> proposals_to_call, string progress_title) {
	y2milestone ("Scripts to call: %1", proposals_to_call);

	proposals_to_call = NormalizeProposalNames (proposals_to_call);
	// every single proposal has two steps
	ResetSubSteps (2 * size (proposals_to_call));

	foreach (string one_proposal, proposals_to_call, {
	    y2milestone ("Calling script %1 MakeProposal", one_proposal);
	    NextStep (progress_title);
	    boolean progress_before = Progress::set (false);

	    HandleExceptions (one_proposal);
	    any result = WFM::CallFunction (one_proposal, ["MakeProposal", $[ "AutomaticConfiguration":true ]]);

	    Progress::set (progress_before);
	    y2milestone ("Script %1 returned %2", one_proposal, result);
	});

	// TODO: handle errors, warnings ...
	// foreach (string one_proposal, proposals_to_call, {
	//    y2milestone ("Calling script %1 MakeProposal", one_proposal);
	//    any result = WFM::CallFunction (one_proposal, ["Description", $[ "AutomaticConfiguration":true ]]);
	//    y2milestone ("Script %1 returned %2", one_proposal, result);
	//});

	foreach (string one_proposal, proposals_to_call, {
	    y2milestone ("Calling script %1 Write", one_proposal);
	    NextStep (progress_title);
	    boolean progress_before = Progress::set (false);

	    any result = WFM::CallFunction (one_proposal, ["Write", $[ "AutomaticConfiguration":true ]]);

	    Progress::set (progress_before);
	    y2milestone ("Script %1 returned %2", one_proposal, result);
	});
    }

    integer nr_of_steps = 0;

    foreach (map one_autoconf_call, proposal_scripts_to_call, {
	nr_of_steps = nr_of_steps +
	    // Proposals have two steps, scripts only one
	    ((one_autoconf_call["type"]:"" == "proposals" ? 2:1) * size (one_autoconf_call["items"]:[]));
    });

    Progress::Simple(
	_("Automatic Configuration"),
	"",
	nr_of_steps,
	_("<p>Installation is currently writing the automatic configuration. Please wait...</p>")
    );

    foreach (map one_autoconf_call, proposal_scripts_to_call, {
	string type = one_autoconf_call["type"]:"";

	string progress_title = one_autoconf_call["label"]:_("Automatic configuration...");

	switch (type) {
	    case "scripts":
		CallScripts (one_autoconf_call["items"]:[], progress_title);
		break;
	    case "proposals":
		CallProposals (one_autoconf_call["items"]:[], progress_title);
		break;
	    y2error ("Unknown script type '%1'", type);
	}
    });

    Progress::Finish();

    y2milestone ("automatic_configuration finished");

    Wizard::SetContents (
	_("Automatic Configuration"),
	`Label (_("Finishing configuration...")),
	"",
	false, false
    );

    return `auto;
}
