/**
 * File:        installation/general/inst_suse_register
 * Module:      Installation
 * Summary:     Perform Customer Center Configuration
 *              this includes (by calling suse_register):
 *                              machine registration
 *                              if needed, launch browser for user/customer registration
 *                              ZMD configuration
 * Authors:     J. Daniel Schmidt <jdsn@suse.de>
 *
 * Perform Customer Center Configuration
 *
 * $Id: inst_suse_register.ycp 1 2006-02-17 13:20:02Z jdsn $
 */

{
    textdomain "installation";

    import "FileUtils";
    import "URL";
    import "Wizard";
    import "Popup";
    import "GetInstArgs";
    import "CustomDialogs";
    import "Directory";
    import "Language";
    import "Mode";
    import "String";
    import "Label";
    import "Internet";
    import "Register";
    import "SourceManager";
    import "PackageSystem";
    import "Package";

    // no network - no suse_register
    if (!Mode::normal())
    {
        if (!Internet::suse_register)
        {
            Internet::do_you = false;
            return `auto;
        }
    }

    // error handling - skip if suseRegister is missing
    integer sr_exist = (integer) SCR::Execute(.target.bash, "test -x /usr/bin/suse_register");
    if (sr_exist != 0)
    {
        y2milestone("/usr/bin/suse_register does not exist - skipping registration");
        Internet::do_you = false;
        return `auto;
    }

    // Register::initialize() is mandatory - never remove it
    Register::initialize();

    map ui = UI::GetDisplayInfo();
    boolean textmode = (boolean) ui["TextMode"]:nil;
    boolean interactive = ! (textmode && Register::disable_w3m);

    map argmap = GetInstArgs::argmap();

    /* strings for main (wizard) layout  */

    // Translators: This is title/brand - verify how to translate it correctly
    string title_nccc = _("Novell Customer Center Configuration");

    // Translators: Module Title for the Box
    string title_box  = _("Online Update Configuration");  // (#165509)

    // for SLES/SLED and SL (2 months after release) use title_nccc
    string title = title_nccc;

    // Translators: limit to 2x 50 charachters - if more needed take 3x 50 chars but NOTHING more
    string nccc_top = _(
"Get technical support and product updates and
manage subscriptions with Novell Customer Center."
);

    string nccc_configure   = _("Configure Now (Recommended)");
    string nccc_noconfigure = _("Configure Later");

    string nccc_sub_comment = _("Include for Convenience");
    string nccc_sub_hwinfo  = _("Hardware Profile");
    string nccc_sub_optional= _("Optional Information");
    string nccc_forcereg= _("Registration Code");
    string nccc_sub_showbtn = _("Details...");


    /*  strings for success popup   */
    string nccc_success_msg = _("Your configuration was successful.");
    string nccc_success_server_added = _("An update server has been added to your configuration.");
    string success_detail_label =("New Update Server");

   /* strings for manual interaction popup */
    string mi_required = _("Manual Interaction Required");
    string mi_needinfo = _("Needed Information");
    string mi_browser_btn = _("Continue");
    string mi_start_browser = _(
"A Web browser will start in which to complete
the configuration on the opened Web site."
);


    /* string for show information popup */
    string transmit_info = _("Registration and Privacy Information");

    /*  strings for conflict popup */
    string conflict_need_info = _(
"The server requires additional system information. Activating 
submission of the hardware profile automatically."
);

     /*  nonroot-message strings */
     string nonroot_title = _("Update Source Issues");
     string nonroot_message = _(
"Registering as a regular user does not include the update source
in the Online Update YaST module. If you continue and later want 
to update with Online Update, the source must be added manually.
Other tools, such as Software Updater in the panel, can still be 
used.  Alternatively, cancel then register through YaST as root 
so the sources are available to all tools."
);



    /* error messages  */
    string data_invalid = _("Error: Data received is invalid.");
    string retrieve_error = _("Error: Could not retrieve data.");
    string no_browser_msg = _(
"No Web browser available.
Run the suse_register command manually."
);
    string no_w3m_msg = _(
"Your registration requires interactive input that is not
supported in text mode. Run YaST2 in the graphical mode or
run the suse_register command manually."
);

    /* help text for dialog "Novell Customer Center Configuration" */
string help_title = sformat( "<p><b>%1</b></p>", title);
string help_para1 = _(
"<p>
Configure your system to enable online updates by registering it with Novell.
To do this now, select <b>Configure Now</b>. Delay the registration with
<b>Configure Later</b>.
</p>"
);

string help_para2 = _(
"<p>
To simplify the registration process, include information from your system
with <b>Optional Information</b> and <b>Hardware Profile</b>. 
<b>Details</b> shows the maximum amount of information that can be involved
 in your registration. To obtain this information, it contacts the Novell
server to query what information is needed for your product. Only the identity
of the installed product is sent in this initial exchange.
</p>"
);

string help_para3 = _(
"<p>
If you purchased your copy of this product, enable <b>Registration Code</b>
so you are prompted for your product code. 
This registers you for the installation support included with your product.
</p>"
);

string help_para4 = _(
"<p>
No information is passed to anyone outside Novell. The data is used for
statistical purposes and to enhance your convenience regarding driver support
and your Web account. Find a detailed privacy policy in <b>Details</b>. View
the transmitted information in the log file <tt>~/.suse_register.log</tt>.
</p>"
);

string help = help_title + help_para1 + help_para2 + (Register::display_forcereg ? help_para3:"") + help_para4;



    /*  further strings   */
    string checking         = _("Checking...");
    string error            = _("Error");
    string server_error     = _("An error occurred while connecting to the server.");
    string details          = _("Details...");
    string error_msg        = _("Error");
    string starting_browser = _("Starting browser...");

    /* other string variables */
    map<string, string> information_data = nil;
    string information_text = "";


    // default is true, see statement in layout term
    boolean configure_status = true;

    /* vv   MAIN (WIZARD) LAYOUT  vv  */
    term sr_layout=nil;
    sr_layout=`HVCenter( `VBox(
                     `Left (
                             `RadioButtonGroup( `id(`sr_perform), `VBox(
                             `Left ( `Label( nccc_top ) ),
                             `VSpacing(1),
                             `Left ( `RadioButton(`id(`noconfigure), `opt(`notify), nccc_noconfigure )),
                             `Left ( `RadioButton(`id(`configure),   `opt(`notify), nccc_configure, true )),
                             `Left ( `HBox( `HSpacing( 3.0 ),
                                      `VBox (
                                             `VSpacing(0.5),
                                             `Left( `Label( nccc_sub_comment ) ),
                                             `Left( `CheckBox(`id(`hwinfo),  `opt(`notify), nccc_sub_hwinfo,  Register::submit_hwdata ) ),
                                             `Left( `CheckBox(`id(`optional), `opt(`notify), nccc_sub_optional, Register::submit_optional ) ),
                                              Register::display_forcereg ? `Left( `CheckBox(`id(`forcereg), `opt(`notify), nccc_forcereg, false ) ):`Empty() ,
                                             `VSpacing(0.5),
                                             `Right( `PushButton(`id(`showinfo), nccc_sub_showbtn ) )
                                   ) ) ) ,
                             `VSpacing(0.5)
                           )))
    ));

    term contents = `VBox ( `VSpacing (0.5), sr_layout, `VSpacing (0.5));
    /* ^^       END MAIN LAYOUT     ^^  */



    /* vv      SHOW INFO POPUP     vv  */
    term showinformation = `HBox( `HSpacing(0.5),
                                  `MinSize(  75, 22 ,`VBox(
                                     `Label( transmit_info ),
                                     `RichText(`id(`information_text), information_text ),
                                     `PushButton (`id (`info_close), Label::CloseButton () )  )
                                   ),
                                  `HSpacing(0.5)
    );
    /* ^^      END  SHOW INFO       ^^  */





    /* vv  MANUAL INTERACTION POPUP vv  */
    term manual_interaction = //`HBox(
                                   `MinSize( 70, 25, `HBox( `VBox(
                                           `Left( `Label( `opt(`boldFont), mi_required ) )  ,
                                           `VSpacing(0.5) ,
                                           `Left( `Label( mi_start_browser  ) ) ,
                                           `Left( `Label( mi_needinfo ) )  ,
                                                  `RichText(`id(`needinfo), ""  ),
                                           `HBox(
                                                  `PushButton(`id(`start_browser), mi_browser_btn )  ,
                                                  `HSpacing( 3),
                                                  `PushButton(`id(`cancel),  Label::CancelButton()  )
                                           )
                                   ))
    );
    /* ^^  END MANUAL INTERACTION  ^^  */



    /* vv      CCC CONFLICT POPUP      vv  */
    term ccc_conflict=
    `VBox(
          `Left( `Label( `opt(`boldFont), title ) ),
          `VSpacing( 0.5 ),
          `Left( `Label( conflict_need_info ) ),
          `PushButton(`id(`ok), Label::OKButton())
    );
    /* ^^       END CCC CONFLICT       ^^  */


    /* vv      CCC ERROR POPUP      vv  */
    term error_message=
    `VBox(
           `Left( `Label( `opt(`boldFont), error ) ),
           `VSpacing( 0.5 ),
           `Left( `Label( `id(`err_description), server_error ) ),
           `HBox(
                  `HWeight(1, `PushButton(`id(`ok), Label::OKButton()  ) ),
                  `HSpacing( 3 ),
                  `HWeight(1, `PushButton(`id(`err_detail), details ) )
                )
    );
    /* ^^      END CCC ERROR        ^^  */


    /* vv      CCC ERROR POPUP      vv  */
    term error_message_details=
    `MinSize( 50, 15,  `VBox(
           `Left( `Label( `opt(`boldFont), error_msg ) ),
           `VSpacing( 0.5 ),
           `RichText(`id(`errordetail), `opt(`plainText) , "" ),
           `PushButton(`id(`ok), Label::OKButton())
    ));
    /* ^^      END CCC ERROR        ^^  */



    /* vv       SUCCESS MESSAGE    vv  */
    term nccc_success=
    `VBox(
           `Left( `Label( `opt(`boldFont), title ) ),
           `VSpacing( 0.5 ),
           `Left( `Label( nccc_success_msg ) ),
           `Left( `Label( nccc_success_server_added ) ),
           `HBox(
                  `HWeight(1, `PushButton(`id(`ok), Label::OKButton()  ) ),
                  `HSpacing( 3 ),
                  `HWeight(1, `PushButton(`id(`success_detail), details ) )
           )
    );
    /* ^^   SUCCESS MESSAGE END     ^^  */



    /* vv    SUCCESS DETAILS     vv  */
    term nccc_success_detail=
    `MinSize( 60, 7,  `VBox(
           `Left( `Label( `opt(`boldFont), success_detail_label ) ),
           `VSpacing( 0.5 ),
           `RichText(`id(`success_detail_richtext), `opt(`plainText) , "" ),
           `PushButton(`id(`ok), Label::OKButton())
    ));
    /* ^^    SUCCESS DETAILS END    ^^  */


/* ---------------------------------- LOCAL FUNCTIONS ------------------------------------------------------------  */


boolean report_error()
{
    // function to display an error message
    // and offer a detailled view of the error message

    UI::OpenDialog(error_message);
    UI::SetFocus (`id (`cancel ));
    symbol retry = nil;

    repeat
    {
        retry = (symbol) UI::UserInput();

        if ( retry == `cancel ) configure_status = false;
        else if (retry == `err_detail)
        {
            UI::OpenDialog(error_message_details);
            UI::ChangeWidget( `id(`errordetail), `Value, (string)information_data["stderr"]:"no error message available");
            UI::UserInput();
            UI::CloseDialog();
        }
    } until ( retry != `err_detail );

    UI::CloseDialog();
}


string su_exec(string user, string group, string command)
{   // (#167255)
    string exec = sformat("
#!/bin/bash -x

user=%1
group=%2
cmd=\"%3\"

fakehome=/var/lib/YaST2/$user-fakehome
umask 0077

XA=/root/.xauth
mkdir -p $XA
grep ^$user$ $XA/export >/dev/null 2>&1  || echo $user >> $XA/export

mkdir -p $fakehome
chmod 700 $fakehome
tmp=$(mktemp $fakehome/.Xauthority.XXXXXX) || exit 1
tmpjail=$(mktemp $fakehome/.screenrc.jail.XXXXXX) || exit 1
chmod 600 $tmp $tmpjail
chown $user:$group $tmp $tmpjail $fakehome
trap \"rm -rf $fakehome\" EXIT INT HUP TERM

cat > $tmpjail <<EOJAIL
# screenrc.jail
#
# use in environments, where a screen session must not spawn any new processes.
# 2006-04-03, jw

escape \\377\\377
shell /bin/true
# stuff is needed for cursor keys. (bugzilla #167255)
# We can neiter exclude one command from the list nor add it back later.
# Resort to enumerate all except one. yacc.

chacl * -x acladd,aclchg,acldel,aclgrp,aclumask,activity,addacl,allpartial,altscreen,at,autodetach
chacl * -x autonuke,backtick,bell,bell_msg,bind,bindkey,blanker,blankerprg,break,breaktype,bufferfile
chacl * -x c1,caption,charset,chdir,clear,colon,command,compacthist,console,copy,crlf,debug
chacl * -x defautonuke,defbce,defbreaktype,defc1,defcharset,defencoding,defescape,defflow,defgr
chacl * -x defhstatus,defkanji,deflog,deflogin,defmode,defmonitor,defnonblock,defobuflimit
chacl * -x defscrollback,defshell,defsilence,defslowpaste,defutf8,defwrap,defwritelock,detach,digraph
chacl * -x dinfo,displays,dumptermcap,echo,encoding,escape,eval,exec,fit,flow,focus,gr,hardcopy
chacl * -x hardcopy_append,hardcopydir,hardstatus,height,help,history,hstatus,idle,ignorecase,info
chacl * -x kanji,kill,lastmsg,license,lockscreen,log,logfile,login,logtstamp,mapdefault,mapnotnext
chacl * -x maptimeout,markkeys,maxwin,meta,monitor,msgminwait,msgwait,multiuser,nethack,next,nonblock
chacl * -x number,obuflimit,only,other,partial,password,paste,pastefont,pow_break,pow_detach
chacl * -x pow_detach_msg,prev,printcmd,process,quit,readbuf,readreg,redisplay,register,remove
chacl * -x removebuf,reset,resize,screen,scrollback,select,sessionname,setenv,setsid,shell
chacl * -x shelltitle,silence,silencewait,sleep,slowpaste,sorendition,source,split,startup_message
chacl * -x su,suspend,term,termcap,termcapinfo,terminfo,time,title,umask,unsetenv,utf8,vbell
chacl * -x vbell_msg,vbellwait,verbose,version,wall,width,windowlist,windows,wrap,writebuf,writelock
chacl * -x xoff,xon,zmodem,zombie
#chacl * -x stuff
chacl * -x chacl        # must be last.

EOJAIL

", user, group, command );


    // create a script to run a system call as different user
    // thanks to werner (script) and jw (.screenrc.jail) for their help
    if (!textmode)
    {    exec = exec +
"
if test \"${DISPLAY%:*}\" = \"localhost\" ; then
    disp=$(hostname -s)/unix:${DISPLAY#*:}
else
    disp=\"${DISPLAY}\"
fi


: ${XAUTHORITY:=$HOME/.Xauthority}
if test ! -e $XAUTHORITY ; then
    su -s /bin/bash -- $user -c \"cd; $cmd\"
    exit 0
fi
exec 4< ${XAUTHORITY}
su -s /bin/bash -- $user -c \"xauth -qif <(cat 0<&4) extract - $disp | xauth -qf $tmp merge -\"
exec 4<&-

su -s /bin/bash -- $user -c \"cd; XAUTHORITY=$tmp $cmd\"

exit 0";
    }
    else
    {
        exec = exec +
"
screen -c $tmpjail su -s /bin/bash -- $user -c \"cd; $cmd\"
exit 0";
    }

    y2milestone("using su_exec to launch browser");

    return exec;
}



string browser_command(string url)
{
    // create the command string to launch a browser
    string bcmd="/bin/false";
    boolean cmd_ok = false;

    if ( textmode )
    {
        cmd_ok = (integer) SCR::Execute(.target.bash, "test -x /usr/bin/w3m") == 0 ? true:false;

        if ( Register::iamroot )
            bcmd = " w3m ";
        else
        {
            cmd_ok = cmd_ok && (integer) SCR::Execute(.target.bash, "test -x /usr/bin/screen") == 0 ? true:false;
            bcmd = " screen w3m ";
        }
    }
    else
    {

        if ( Register::iamroot )
        {
            // check for and install mozilla-xulrunner if needed (#175166)
            Package::InstallAllMsg(["mozilla-xulrunner"], nil);
            cmd_ok = (integer) SCR::Execute(.target.bash, "test -x /usr/bin/xulrunner") == 0 ? true:false;
            bcmd = " MOZ_DISABLE_PANGO=1 /usr/bin/xulrunner /usr/share/YaST2/yastbrowser/application.ini -url ";
        }
        else
        {   // this case will never happen because we will not run as non-root (#170736)
            Package::InstallAllMsg(["MozillaFirefox"], nil);  // (#175166)
            cmd_ok = (integer) SCR::Execute(.target.bash, "test -x /usr/bin/firefox") == 0 ? true:false;
            bcmd = " firefox -new-window ";
        }
    }

    if (! cmd_ok) return "nobrowser";

    // add url to browser command
    bcmd =  bcmd + "'" + url + "'";

    if (Register::use_proxy)
    {   // (#165891)
        bcmd = " http_proxy='"  + Register::http_proxy  + "' " + bcmd;
        bcmd = " https_proxy='" + Register::https_proxy + "' " + bcmd;
    }

    // in case of root add su call to not run a browser as root during installation
    if ( Register::iamroot ) bcmd = su_exec("suse-ncc", "suse-ncc", bcmd );

    return bcmd;
}


boolean launchBrowser(string url)
{
    // check for valid url
    map parsed = URL::Parse(url);
    if ( parsed == $[]) return false;
    // no rebuild of the url - parser seems to only parse one parameter in URL

    string uri = String::FirstChunk(url, "\n");  // (#167225)
    // get command to run correct browser and execute it
    string command = browser_command(uri);
    if (command == "nobrowser") return false;

    y2milestone("launching browser: %1", command);

    SCR::Execute(.target.bash, command );
    UI::RedrawScreen();

    return true;
}


/* ----------------------------------- END FUNCTIONS -------------------------------------------------------------  */


    // check if we are in installation workflow or running independently
    if (Mode::normal()) Wizard::CreateDialog();

    boolean enable_back = GetInstArgs::enable_back();
    // we always need the next button
    Wizard::SetContents (title, contents, help, enable_back, true);

    //y2debug ("%1", UI::DumpWidgetTree());


    // check if we are running as nonroot
    if ( !Register::iamroot )
    {    // do not run as non-root: #170736
        return `auto;
        // SL (box) has the following warning
        //if ( !Popup::ContinueCancelHeadline( nonroot_title, nonroot_message ) )
        //    return `cancel;
    }


    boolean loopend = false;
    any ret = nil;


/* -------------------------------- PROGRAM LOGIC START ----------------------------------------------------------- */

    if (Mode::normal ())
    {
	// #172665, make sure that the added sources have a safe home
	// It also takes care of target for keys, shows busy popup
	PackageSystem::EnsureSourceInit ();
    }

    // #170113, the lock is needed around everything that may end up in ZMD
    SourceManager::Lock ();

    repeat {
        ret = Wizard::UserInput();

        if (ret == `abort)
        {
            if (Mode::normal()) break;
            if (Popup::ConfirmAbort (`incomplete))  break;
        }
        else if (ret == `help)
        {
            Wizard::ShowHelp (help);
        }
        else if (ret == `configure || ret == `noconfigure)
        {
            configure_status = (boolean) UI::QueryWidget(`id(`configure),  `Value);
        }
        else if (ret == `hwinfo || ret == `optional || ret == `forcereg)
        {
            Register::submit_hwdata  = (boolean) UI::QueryWidget(`id(`hwinfo),  `Value);
            Register::submit_optional= (boolean) UI::QueryWidget(`id(`optional), `Value);
            Register::force_registration = (boolean) UI::QueryWidget(`id(`forcereg), `Value);
        }
        else if (ret == `showinfo)
        {
            information_data = Register::suseRegister(`p);

            if ( information_data["exit"]:"99" == "0" )
            {
                information_text = information_data["stdout"]:"";
                UI::OpenDialog( showinformation );
                UI::ChangeWidget(`id(`information_text), `Value, information_text );
                any info_ret = nil;

                repeat
                {
                    info_ret = UI::UserInput();
                    if ( is(info_ret, string) ) launchBrowser( (string) info_ret);

                } until ( info_ret == `info_close );

                UI::CloseDialog();
            }
            else
            {
                if (! ( information_data["exit"]:"99"        == "199"     &&
                        information_data["stdout"]:"aborted" == "aborted" &&
                        information_data["stderr"]:"aborted" == "aborted"    ) )
                report_error();
            }

        }
        else if (ret == `next)
        {
            if ( configure_status == true )
            {
                // remove the zmd flag file (requested by mvidner)
                SCR::Execute(.target.bash, " rm -f /var/lib/zypp/zmd_updated_the_sources " );

                /* run suse_register to see if we need manual interaction */
                information_data = Register::suseRegister(nil);

                // error code 1: needinfo
                // manual interaction is requiered
                // this case MUST be first
                //  ... because during manual interaction further suse_register calls change the error code
                if (information_data["exit"]:"99" == "1" && interactive)
                {
                    UI::OpenDialog( manual_interaction );
                    UI::SetFocus (`id (`start_browser ));
                    UI::ChangeWidget( `id(`needinfo), `Value, information_data["stderr"]:data_invalid );
                    any mi_ret =nil;
                    boolean mi_loopend = false;
                    boolean recheck = true;
                    boolean browserrun = true;

                    repeat
                    {
                        recheck = true;
                        mi_ret = UI::UserInput();
                        if ( mi_ret == `start_browser  )
                        {
                            // now we launch the browser
                            UI::ChangeWidget( `id(`needinfo), `Value, starting_browser );
                            browserrun = launchBrowser(information_data["stdout"]:"http://www.opensuse.org");
                            // deactivate force_registration after each suse_register call (#bugNo.)
                            Register::force_registration = false;

                        }
                        else if ( mi_ret == `cancel  )
                        {
                            recheck = false;
                            mi_loopend = true;
                        }
                        else if ( is(mi_ret, string) )
                        {
                            // launch browser
                            browserrun = launchBrowser( (string) mi_ret);
                            recheck = false;
                        }


                        if ( recheck  && browserrun )
                        {
                            // show the user, that we are doing something
                            UI::ChangeWidget( `id(`needinfo), `Value, checking );

                            information_data = Register::suseRegister(nil);

                            if (information_data["exit"]:"99" == "0" || information_data["exit"]:"99" == "3" )
                            {
                                // error 0: everything is done, quit
                                // error 3: madatory data conflict - handle outside of manual interaction
                                mi_loopend = true;
                            }
                            else if (information_data["exit"]:"99" == "1")
                            {
                                // still needinfo, change displayed information and stay in manual interaction
                                UI::ChangeWidget( `id(`needinfo), `Value, information_data["stderr"]:retrieve_error );
                            }
                            else
                            {
                                // unknown error, let the user find an exit :)
                                mi_loopend = true;
                            }
                        }


                        if (! browserrun )
                        {
                            information_data = $["exit":"198", "stdout":"", "stderr":""  ];
                            mi_loopend = true;
                        }

                    } until ( mi_loopend );

                    // we are done with manual interaction
                    UI::CloseDialog();

                    if (mi_ret == `cancel) configure_status = false;
                }
                else if (information_data["exit"]:"99" == "1" && ! interactive)
                {
                    // w3m disabled - show message
                    Popup::Message(no_w3m_msg);
                    loopend = true;
                    ret = `skip;
                }

                // during error code 1 information_data may be changed by a suse_register call
                // no NO MORE suse_register calls below this line !!


                /*  handle error codes from FIRST suse_register call AND from manual interaction  */
                if (information_data["exit"]:"99" == "3")
                {
                    // error code 3 means:
                    // conflict between transmitted data and data to be transmit according to customer contract
                    // hwconfig is needed
                    UI::OpenDialog(ccc_conflict);
                    UI::SetFocus (`id (`ok));
                    UI::UserInput();
                    UI::CloseDialog();
                    Register::submit_hwdata = true;
                }

                // error code 0 means: everything is OK
                // no more interaction requiered - ZMD is configuered by suse_register
                if (information_data["exit"]:"99" == "0")
                {
                    // add update source
                    UI::OpenDialog(`VBox(`Label(_("Setting up online update source..."))));
                    Register::add_update_sources();
                    UI::CloseDialog();

                    // and then show success message
                    symbol sret=nil;
                    UI::OpenDialog( nccc_success );
                    repeat
                    {
                        sret = (symbol) UI::UserInput();
                        if (sret == `success_detail)
                        {
                            // show the URL that was added as update source (URL is in STDERR of suse_register output)
                            UI::OpenDialog( nccc_success_detail );
                            UI::SetFocus(`id(`ok));
                            UI::ChangeWidget(`id(`success_detail_richtext), `Value, information_data["stderr"]:"unknown" );
                            UI::UserInput();
                            UI::CloseDialog();
                        }
                    } until (sret == `ok );
                    UI::CloseDialog();

                    // we are done, end of loop
                    loopend = true;
                }


                // error handling - no browser available for interactive mode
                if (information_data["exit"]:"99" == "198")
                {
                    Popup::Message(no_browser_msg);
                    loopend = true;
                }


                // handle any other error codes
                if (
                     (
                       information_data["exit"]:"" != "0" &&
                       information_data["exit"]:"" != "1" &&
                       information_data["exit"]:"" != "3" &&
                       information_data["exit"]:"" != "198"
                     ) &&
                    !(
                       // if return value says that suse_register was aborted by user
                       information_data["exit"]:"99"        == "199"     &&
                       information_data["stdout"]:"aborted" == "aborted" &&
                       information_data["stderr"]:"aborted" == "aborted"
                     )
                   )
                {
                    // display error message
                    report_error();
                }

            }
            else
            {
                // skipping - no online update!!
                loopend = true;
                ret = `skip;
            }
        }

        // update main widget settings - they may have changed
        if (configure_status) UI::ChangeWidget(`id(`configure), `Value, true);
        else UI::ChangeWidget(`id(`noconfigure), `Value, true);

        UI::ChangeWidget(`id(`hwinfo), `Value, Register::submit_hwdata);
        // (#165841)
        if (Register::display_forcereg) UI::ChangeWidget( `id(`forcereg ), `Value, Register::force_registration );

    } until ( loopend || ret == `back );

    SourceManager::Unlock ();

    // Register::finish mandatory as well - do not remove
    Register::finish();

    if (Mode::normal())
    {
	// #172665
	Pkg::SourceFinishAll ();
	Pkg::TargetFinish ();
	Wizard::CloseDialog();
    }
    else
    {
        if (ret == `skip)
        {
            // skipping suse register - no online update
            Internet::do_you = false;
            ret = `next;
        }
        else
        {
            // ok we can do online update
            Internet::do_you = true;
        }
    }

    return (symbol)ret;
}
