/**
 * File:		inst_worker_continue.ycp
 *
 * Authors:		Klaus Kaempf <kkaempf@suse.de>
 *			Mathias Kettner <kettner@suse.de>
 *			Michael Hager <mike@suse.de>
 *			Stefan Hundhammer <sh@suse.de>
 *			Arvin Schnell <arvin@suse.de>
 *			Jiri Srain <jsrain@suse.cz>
 *			Lukas Ocilka <locilka@suse.cz>
 *
 * Purpose:		Set up the UI and define macros for the
 *			installation dialog, general framework, ...
 *			Describing and calling all submodules.
 *			(For continuing installation only).
 *
 * $Id:$
 */
{
    textdomain "installation";

    import "Installation";
    import "Linuxrc";
    import "Mode";
    import "ProductControl";
    import "Stage";

    // General installation functions
    include "installation/misc.ycp";
    // Both First & Second stage-related functions
    include "installation/inst_inc_all.ycp";
    // Second-stage-related functions only
    include "installation/inst_inc_second.ycp";

    /* --- First, connect to the system via SCR --- */

    // this is installation, so start SCR always locally (as plugin) !
    integer scr_handle = WFM::SCROpen ("scr", false);
    WFM::SCRSetDefault (scr_handle);

    Installation::scr_handle = scr_handle;

    /* --- Global settings --- */

    // All stages
    SetAutoinstHandling ();

    // FATE #300422
    symbol ret = RerunInstallationIfAborted ();
    if (ret != `next) return ret;

    SetSecondStageInstallation();

    // All stages
    SetUIContent();

    SetDiskActivationModule();

    UpdateWizardSteps ();

    // Adjusts network services to the state in which they were
    // before rebooting the installation (e.g., inst_you)
    // bugzilla #258742
    InitNetworkServices();
    // Set "Initializing..." UI again
    SetInitializingUI();

    // Second stage
    SetLanguageAndEncoding();
    retranslateWizardDialog();

    // All stages
    // Shows fallback message if running in textmode (if used as fallback)
    ShowTextFallbackMessage();

    ret = nil;

    /* --- Runing the installation workflow --- */

    // Continue the second stage installation
    if (FileUtils::Exists (Installation::restart_data_file)) {
	string contents = (string)
	    SCR::Read (.target.string, Installation::restart_data_file);
	// file will be created if it is needed
	y2milestone ("Removing %1 file containing %2", Installation::restart_data_file, contents);
	SCR::Execute(.target.remove, Installation::restart_data_file);

	list<string> contents_lines = splitstring (contents, "\n");
	integer next_step = tointeger ((string)(contents_lines[0]:nil));
	integer restarting_step = tointeger ((string)(contents_lines[1]:nil));

	if (next_step == nil)
	{
	    y2error ("Data file specifying step to continue corrupted");
	    ProductControl::first_step = 0;
	    ProductControl::restarting_step = nil;
	    ret = ProductControl::Run();
	    y2milestone ("ProductControl::Run() returned %1", ret);
	}
	else
	{
	    ProductControl::first_step = next_step;
	    ProductControl::restarting_step = restarting_step;
	    ret = ProductControl::RunFrom (next_step, false);
	    y2milestone ("ProductControl::RunFrom(%1) returned %2", next_step, ret);
	}

	CleanUpRestartFiles();
    // Starting the second stage installation
    } else {
	// Run the installation workflow
	ret = ProductControl::Run();
	y2milestone ("ProductControl::Run() returned %1", ret);
    }

    /* --- Handling finished installation workflow --- */

    y2milestone("Evaluating ret: %1", ret);

    if (ret == `reboot || ret == `restart_yast || ret == `restart_same_step) {
	ret = PrepareYaSTforRestart (ret);
    // Installation has been aborted
    } else if (ret == `abort) {
	// tell linuxrc that we aborted
	Linuxrc::WriteYaSTInf($["Aborted" : "1"]);
    }
    
    // Store network services to the state in which they are
    // before rebooting the installation (e.g., inst_you)
    // bugzilla #258742
    StoreNetworkServices (ret);

    // when the installation is not aborted or YaST is not restarted on purpose
    // ret == `next -> (ret != `reboot && ret != `restart_yast && ret != `restart_same_step && ret != `abort)
    if (ret == `next) {
	HandleSecondStageFinishedCorrectly();
    // installation (second stage) has been aborted
    // FATE #300422
    } else if (ret == `abort || ret == `cancel) {
	HandleSecondStageAborted();
    }

    if (ret == `next || ret == `abort || ret == `cancel) {
	EnableAutomaticModuleProbing();
    }

    // All Sources and Target need to be released...
    FinishInstallation (ret);

    return ret;
}
