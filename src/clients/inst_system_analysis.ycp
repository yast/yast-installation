/**
 * File:	clients/inst_system_analysis.ycp
 * Package:	Installation
 * Summary:	Installation mode selection, system analysis
 * Authors:	Jiri Srain <jsrain@suse.cz>
 *		Lukas Ocilka <locilka@suse.cz>
 *
 * $Id$
 *
 */

{

textdomain "installation";

import "AddOnProduct";
import "Arch";
import "GetInstArgs";
import "Hotplug";
import "Installation";
import "Kernel";
import "Label";
import "Linuxrc";
import "Mode";
import "PackageCallbacksInit";
import "Packages";
import "Popup";
import "Product";
import "ProductControl";
import "Progress";
import "Report";
import "RootPart";
import "Stage";
import "Storage";
import "StorageControllers";
import "StorageDevices";
import "Update";
import "Wizard";

include "installation/misc.ycp";
include "packager/storage_include.ycp";

string start_mode = Mode::mode ();

    // Function definitions -->

    // --------------------------------------------------------------
    //				      USB
    // --------------------------------------------------------------
    boolean ActionUSB () {
	Hotplug::StartUSB ();

	return true;
    }
    
    // --------------------------------------------------------------
    //				FireWire (ieee1394)
    // --------------------------------------------------------------
    boolean ActionFireWire () {
	Hotplug::StartFireWire ();

	return true;
    }
    
    // --------------------------------------------------------------
    //				    Floppy
    // --------------------------------------------------------------
    boolean ActionFloppyDisks () {
	StorageDevices::FloppyReady ();

	return true;
    }

    boolean found_controllers = true;
    
    // --------------------------------------------------------------
    //			     Hard disk controllers
    // 1. Probe
    // 2. Initialize (module loading)
    // --------------------------------------------------------------
    // In live_eval mode, all modules have been loaded by linuxrc. But
    // they are loaded by StorageControllers::Initialize(). Well, there
    // also was another reason for skipping StorageControllers::Probe ()
    // but nobody seems to remember more.
    // --------------------------------------------------------------
    boolean ActionHHDControllers () {
	found_controllers = (StorageControllers::Probe () > 0);

	return true;
    }
    
    // --------------------------------------------------------------
    // Don't abort or even warn if no storage controllers can be
    // found.  Disks might be detected even without proper knowledge
    // about the controller.  There's a warning below if no disks were
    // found.
    // --------------------------------------------------------------
    boolean ActionLoadModules () {
	StorageControllers::Initialize ();
	
	return true;
    }
    
    // --------------------------------------------------------------
    //				  Hard disks
    // --------------------------------------------------------------
    boolean ActionHDDProbe () {
	map targetMap = StorageDevices::Probe (true);

	if (size (targetMap) == 0) {
	    if (found_controllers) {
		// pop-up error report
		Report::Error(_("No hard disks were found for the installation.
Please check your hardware!
"));
	    } else {
		// pop-up error report
		Report::Error(_("No hard disks and no hard disk controllers were
found for the installation.
Check your hardware.
"));
	    }

	    return false;
	}
	
	return true;
    }

    boolean offer_update = false;

    boolean EvaluateUpdatePossibilities () {
	y2milestone ("Product flags: %1", Product::flags);
	if (contains (Product::flags, "update") || Kernel::GetSuSEUpdate ()) {
	    offer_update = true;
	}

	return true;
    }

    boolean have_linux = false;

    boolean SearchForLinuxPartitions () {
	if (Storage::HaveLinuxPartitions ()) {
	    have_linux = true;
	}
	
	return true;
    }

    // <-- Function definitions

// FIXME copy-paste from inst_mode
    define symbol handle_boot ()
    {
	y2milestone( "User wishes to boot installed system" );

	if (!RootPart::didSearchForRootPartitions)
	{
	    UI::OpenDialog (`opt(`decorated ),
			    // label
			    `Label(_("Evaluating root partition. One moment please...")));
	    RootPart::FindRootPartitions ();
	    UI::CloseDialog ();
	}

	if (RootPart::numberOfValidRootPartitions == 0)
	{
	    // a popup
	    Popup::Message(_("No Linux root partition found."));
	    return `cancel;
	}

	// We must only change RootPart::selectedRootPartition if booting
	// is inevitable.

	if (RootPart::numberOfValidRootPartitions == 1)
	{
	    y2milestone ("Only one partition with system...");
	    RootPart::SetSelectedToValid ();
	}
	else
	{
	    y2milestone ("More partitions with system...");
	    if (WFM::CallFunction ("inst_rootpart", [true, true, `boot_popup]) != `next)
		return `cancel;
	}

	string root_part = RootPart::selectedRootPartition;
	y2milestone ("Trying to boot from %1 partitions", root_part);

	UI::OpenDialog( `opt(`decorated),
			// Information popup: Inform user what partition
			// will be booted from after user selected
			// "Boot installed system"
			`Label( sformat(_("Booting from %1"), root_part ) ) );

	Update::Detach ();
	RootPart::UnmountPartitions (false);

	sleep (1000);

	if ( ! Mode::test () )
	{
	    Linuxrc::WriteYaSTInf ($["Root" : root_part]);
	    Storage::ActivateHld(true);
	}

	UI::CloseDialog ();

	return `finish;
    }

symbol current_expert_mode = `repair;

string InstModeDialogHelp () {
    // help text for installation method
    return _("<p><big><b>Installation Mode</b></big><br>
Select what to do:</p>") +

    // help text for installation method
    _("<p>
Select <b>New Installation</b> if there is no existing Linux system on your
machine or if you want to replace an existing Linux system completely,
abandoning all its configuration data.
</p>") +

    // help text for installation method
    _("<p>
Select <b>Update an Existing System</b> to update a Linux system already
installed on your machine. This option preserves configuration settings
from your existing system whenever possible.
</p>") +

    // help text for installation option
    _("<p>
To use suggested remote repositories during installation or update, select
<b>Add Online Repositories Before Installation</b>.</p>
") +

    // help text for installation method
    _("<p>
To install an add-on product from separate media together with &product;, select
<b>Include Add-On Products from Separate Media</b>.</p>
") +

    // help text for installation method
    _("<p>Select <b>Other Options</b> then
select <b>Repair Installed System</b> if you have a damaged Linux system on
your hard disk. This option can try to fix problems automatically.
</p>") +



    // help text for installation method
    _("<p>Select <b>Other Options</b> then
select <b>Boot Installed System</b> if you have a Linux system on your hard
disk that will not boot. With this option, try to fix problems manually.
</p>");
}

// see bugzilla #156529
term InstModeDialogContent (symbol pre_selected) {
    term other_options_layout_fix = `Empty();
    term other_options            = `Empty();

    if (pre_selected == `expert) {
	other_options_layout_fix = `VSpacing(2.1);
	other_options = `RadioButtonGroup (
	    `id (`expert_options),
	    `HBox (
		`HSpacing (6),
		`VBox (
		    `Left (`RadioButton (`id (`repair), `opt (`notify),
			// radio button
			_("Re&pair Installed System"), (current_expert_mode == `repair))),
		    `Left (`RadioButton (`id (`boot), `opt (`notify),
			// radio button
			_("Boot Installed &System"), (current_expert_mode == `boot)))
		)
	    )
	);
    }

    return `VBox (
	`VWeight (60, `HVCenter (
	    `MarginBox (
	    `leftMargin (1),
	    `rightMargin (1.5),
	    `topMargin (0.5),
	    `bottomMargin (0.5),
	    `VBox (
		other_options_layout_fix,
		`Frame (
		    // frame
		    _("Select Mode"),
		    `VBox (
			// Basis RadioButtonGroup
			`RadioButtonGroup (
			    `id (`inst_mode),
			    `VBox (
				// radio button
				`Left (`RadioButton (`id (`install), `opt(`notify), _("New &Installation"),
				    ! Mode::update ())),
				`VSpacing( 0.3 ),
				// radio button
				`Left (`RadioButton (`id (`update), `opt(`notify), _("&Update"),
				    Mode::update ())),
				`VSpacing( 1.3 ),
				`Left (`RadioButton (`id (`expert), `opt(`notify), _("&Other Options")))
			    )
			),
			// Other RadioButtonGroup
			other_options
		    )
		),
		`VSpacing (2),
		`Left (`CheckBox (
		    `id (`productsources), `opt(`notify),
		    // check box
		    _("&Add Online Repositories Before Installation"),
		    Installation::productsources_selected
		)),
		`Left (`CheckBox (
		    `id (`add_on), `opt(`notify),
		    // check box
		    _("In&clude Add-On Products from Separate Media"),
		    Installation::add_on_selected
		))
	    )
	)
	)),
	`VWeight (20, `Empty ())
    );
}

Wizard::SetContents (_("Analyzing the Computer"), `Empty (), "", false, false);
Wizard::SetTitleIcon ("yast-inst-mode");

// Do hardware probing
//
// This must happen before submodule descriptions are initialized; module
// constructors might depend on it.
// In autoinst mode, this has been called already.

list <string> actions_todo      = [];
list <string> actions_doing     = [];
list          actions_functions = [];

y2milestone ("Probing done: %1", Installation::probing_done);
if (! Installation::probing_done)
{
//    if (!Mode::autoinst ()) {
	if (!(Arch::s390 () || Arch::board_iseries ())) {
	    // TRANSLATORS: progress step
	    actions_todo = add (actions_todo, _("Probe USB devices"));
	    // TRANSLATORS: progress step
	    actions_doing = add (actions_doing, _("Probing USB devices..."));
	    actions_functions = add (actions_functions, ActionUSB);

	    // TRANSLATORS: progress step
	    actions_todo = add (actions_todo, _("Probe FireWire devices"));
	    // TRANSLATORS: progress step
	    actions_doing = add (actions_doing, _("Probing FireWire devices..."));
	    actions_functions = add (actions_functions, ActionFireWire);

	    // TRANSLATORS: progress step
	    actions_todo = add (actions_todo, _("Probe floppy disks devices"));
	    // TRANSLATORS: progress step
	    actions_doing = add (actions_doing, _("Probing floppy disks devices..."));
	    actions_functions = add (actions_functions, ActionFloppyDisks);
        }

        // TRANSLATORS: progress step
        actions_todo = add (actions_todo, _("Probe hard disk controllers"));
        // TRANSLATORS: progress step
        actions_doing = add (actions_doing, _("Probing hard disk controllers..."));
        actions_functions = add (actions_functions, ActionHHDControllers);

        // TRANSLATORS: progress step
        actions_todo = add (actions_todo, _("Load kernel modules for hard disk controllers"));
        // TRANSLATORS: progress step
        actions_doing = add (actions_doing, _("Loading kernel modules for hard disk controllers..."));
        actions_functions = add (actions_functions, ActionLoadModules);

        // TRANSLATORS: progress step
        actions_todo = add (actions_todo, _("Probe hard disks"));
        // TRANSLATORS: progress step
        actions_doing = add (actions_doing, _("Probing hard disks..."));
	actions_functions = add (actions_functions, ActionHDDProbe);

	WFM::CallFunction("inst_features", []);
	Installation::probing_done = true;
//    }
}

// TRANSLATORS: progress step
actions_todo = add (actions_todo, _("Search for Linux partitions"));
// TRANSLATORS: progress step
actions_doing = add (actions_doing, _("Searching for Linux partitions..."));
actions_functions = add (actions_functions, SearchForLinuxPartitions);

// TRANSLATORS: progress step
actions_todo = add (actions_todo, _("Evaluate update possibility"));
// TRANSLATORS: progress step
actions_doing = add (actions_doing, _("Evaluating update possibility..."));
actions_functions = add (actions_functions, EvaluateUpdatePossibilities);

Wizard::SetTitleIcon ("yast-controller");

Progress::New (
    // TRANSLATORS: dialog caption
    _("System Probing"),
    " ",
    size (actions_todo),
    actions_todo,
    actions_doing,
    // TRANSLATORS: dialog help
    _("Please wait while computer hardware and installed systems are being probed...")
);

foreach (any run_function, actions_functions, {
    Progress::NextStage();

    // Bugzilla #298049
    // Allow to abort the probing
    any ui_ret = UI::PollInput();

    if (ui_ret == `abort) {
	y2milestone ("Abort pressed");

	if (Popup::ConfirmAbort (`painless)) {
	    y2warning ("User decided to abort the installation");
	    return `abort;
	}
    }

    y2milestone ("Running function: %1", run_function);

    boolean () run_this = (boolean()) (run_function);
    boolean ret = run_this();

    y2milestone ("Function %1 returned %2", run_function, ret);
});
    
Progress::Finish();
sleep (500);

y2milestone ("Have Linux: %1, Offer Update: %2", have_linux, offer_update);

boolean other_options_disabled = false;

if (! (have_linux && offer_update))
{
    // to offer add-on products
    // Mode::SetMode ("installation");
    // return `auto;
    other_options_disabled = true;
}

// bugzilla #208222
// Release disk used as the installation source
ReleaseHDDUsedAsInstallationSource();

// In case of going back from Update/New Installation
Pkg::TargetFinish();

if (Mode::autoinst ()) {
    y2milestone ("Autoinst -> returning `auto");
    return `auto;
}



Wizard::SetContents (
    // dialog caption
    _("Installation Mode"), InstModeDialogContent(`install), InstModeDialogHelp(), true, true
);
Wizard::SetTitleIcon ("yast-software");

symbol ret = nil;
symbol new_mode = Mode::update () ? `update : `install;

string umount_result = Linuxrc::InstallInf ("umount_result");
string media = Linuxrc::InstallInf ("InstMode");
y2milestone ("Umont result: %1, inst mode: %2", umount_result, media);

// there are not only CD and DVD Add-On sources
//if (umount_result != "0" && (media == "cd" || media == "dvd"))
//    UI::ChangeWidget (`id (`add_on), `Enabled, false);

// only installation (and addon products) enabled
if (other_options_disabled) {
    UI::ChangeWidget (`id (`update), `Enabled, false);
    UI::ChangeWidget (`id (`expert), `Enabled, false);
}

// --> Handling User Input in Installation Mode

ProductControl::DisabledModules = add (ProductControl::DisabledModules, "add-on");
ProductControl::DisabledModules = add (ProductControl::DisabledModules, "inst_add-on");
ProductControl::DisabledModules = add (ProductControl::DisabledModules, "productsources");
ProductControl::DisabledModules = add (ProductControl::DisabledModules, "inst_productsources");
UpdateWizardSteps();

// Probably buggy UI, in case of two radio button groups, the second one
// doesn't work (RadioButtonGroup (`id (`expert_options)))
repeat {
    ret = (symbol) UI::UserInput();
    y2milestone("ret: %1", ret);

    // Use-Add-On-Product status changed
    if (ret == `add_on) {
	Installation::add_on_selected = (boolean) UI::QueryWidget (`id (`add_on), `Value);
	ret = nil;
	continue;
    }
    // Use Sources defined by product
    else if (ret == `productsources) {
	Installation::productsources_selected = (boolean) UI::QueryWidget (`id (`productsources), `Value);
	ret = nil;
	continue;
    }
    // Other Options - Boot
    else if (ret == `boot) {
	current_expert_mode = `boot;

	ret = nil;
	continue;
    // Other Options - Repair
    } else if (ret == `repair) {
	current_expert_mode = `repair;

	ret = nil;
	continue;
    }
    // Adjusting current UI - Other Options
    else if (ret == `expert) {
	// Remembering add-on state, switching off and disabling
	Installation::add_on_selected = (boolean) UI::QueryWidget (`id (`add_on), `Value);

	// Show other options
	Wizard::SetContents (
	    // dialog caption
	    _("Installation Mode"), InstModeDialogContent(`expert), InstModeDialogHelp(), true, true
	);
	
	UI::ChangeWidget (`id(`add_on), `Value, false);
	UI::ChangeWidget (`id(`add_on), `Enabled, false);
	UI::ChangeWidget (`id(`productsources), `Value, false);
	UI::ChangeWidget (`id(`productsources), `Enabled, false);

	UI::ChangeWidget (`id(`inst_mode), `CurrentButton, `expert);
	
	ret = nil;
	continue;
    }
    // Adjusting current UI - Hide Other Options
    // in case of `install or `update clicked
    else if (contains([`install, `update], ret)) {
	symbol selected_mode = (symbol)  UI::QueryWidget (`id (`inst_mode), `CurrentButton);

	// Hide other options
	Wizard::SetContents (
	    // dialog caption
	    _("Installation Mode"), InstModeDialogContent(`install), InstModeDialogHelp(), true, true
	);

	// Enabling add-on, adjusting previous state (selected)
	UI::ChangeWidget  (`id(`add_on), `Enabled, true);
	UI::ChangeWidget  (`id(`add_on), `Value, Installation::add_on_selected);
	UI::ChangeWidget  (`id(`productsources), `Enabled, true);
	UI::ChangeWidget  (`id(`productsources), `Value, Installation::productsources_selected);

	// Can be either `install or `update
	UI::ChangeWidget  (`id(`inst_mode), `CurrentButton, selected_mode);
    }

    // Next button
    if (ret == `next)
    {
	new_mode = (symbol) UI::QueryWidget (`id (`inst_mode), `CurrentButton);
	if (new_mode == nil)
	{
	    // this is a label of a message box
	    Popup::Message(_("Choose one of the\noptions to continue."));
	    ret = nil;
	    continue;
	}
	
	// Repair or Boot
	if (new_mode == `expert) {
	    if (! contains([`boot, `repair], current_expert_mode)) {
		y2error("Internal error: Widget `expert_mode selected item: %1", current_expert_mode);
		ret = nil;
		continue;
	    }
	    new_mode = current_expert_mode;
	    
	    // Boot was selected
	    if (new_mode == `boot) {
		symbol hb_ret = handle_boot();
		y2milestone ("handle_boot() returned '%1'", ret);

		if (hb_ret != `finish) {
		    y2milestone("Not booting any OS");
		    ret = nil;
		    continue;
		} else {
		    y2milestone ("Booting...");
		}
	    }
	}
    }
    else if (ret == `abort)
    {
	if (Popup::ConfirmAbort (Stage::initial () ? `painless : `incomplete))
	    return `abort;
	ret = nil;
	continue;
    }
} until (ret == `back || ret == `next);

// <-- Handling User Input in Installation Mode

y2milestone("Selected mode: %1, Return: %2", new_mode, ret);
if (ret == `next)
{
    if (new_mode == `install)
    {
	Mode::SetMode ("installation");
    }

    if (new_mode == `update)
    {
	Mode::SetMode ("update");
    }

    if (new_mode == `repair)
    {
	Mode::SetMode ("repair");
    }

    if (new_mode == `boot)
    {
	Mode::SetMode ("");
	ret = `finish;
    }

    if (new_mode == `install || new_mode == `update)
    {
	Installation::add_on_selected = (boolean) UI::QueryWidget (`id (`add_on), `Value);
	ProductControl::DisabledModules = filter (string m, ProductControl::DisabledModules, {
	    return m != "add-on" && m != "inst_add-on";
	});
	if (! Installation::add_on_selected)
	{
	    ProductControl::DisabledModules = add (ProductControl::DisabledModules, "add-on");
	    ProductControl::DisabledModules = add (ProductControl::DisabledModules, "inst_add-on");
	}

	Installation::productsources_selected = (boolean) UI::QueryWidget (`id (`productsources), `Value);
	ProductControl::DisabledModules = filter (string m, ProductControl::DisabledModules, {
	    return m != "productsources" && m != "inst_productsources";
	});
	if (! Installation::productsources_selected)
	{
	    ProductControl::DisabledModules = add (ProductControl::DisabledModules, "productsources");
	    ProductControl::DisabledModules = add (ProductControl::DisabledModules, "inst_productsources");
	}

	y2milestone ("Disabled: %1", ProductControl::DisabledModules);
    }
}

if (ret == `back || ret == `finish) {
    y2milestone("Returning: %1", ret);
    return ret;
}

if (Mode::repair ())
{
    y2milestone("Calling inst_repair");
    WFM::CallFunction ("inst_repair");
    return `finish;
}

// bugzilla #293808
// Check (and setup) the network only when needed
if (Installation::add_on_selected || Installation::productsources_selected) {
    // Check and setup network
    symbol inc_ret = (symbol) WFM::CallFunction ("inst_network_check", []);
    y2milestone ("inst_network_check ret: %1", inc_ret);
    if (contains ([`back, `abort], inc_ret)) {
	return inc_ret;
    }
}

Wizard::SetContents (
    _("Initializing Installation Catalogs"),
    // TRANSLATORS: progress message
    `Label (_("Initializing installation catalogs...")),
    "",
    false, false
);
Wizard::SetTitleIcon ("yast-software");

Packages::InitializeCatalogs ();
if (Packages::InitFailed ())
{
    // popup message
    Popup::Message (_("Failed to initialize catalogs.
Aborting the installation."));
    return `abort;
}
Packages::InitializeAddOnProducts ();

if (Mode::mode () != start_mode)
{
    y2milestone ("Switching Steps from %1 to %2 ", start_mode, Mode::mode ());
    UpdateWizardSteps ();
    y2milestone ("Resetting disk target to read values");
    Storage::ResetOndiskTarget ();
    y2debug ("Original target map (from disk): %1", Storage::GetTargetMap ());
    y2milestone ("Resetting package manager");
    Kernel::ProbeKernel();
    Pkg::TargetFinish ();
    Pkg::PkgReset ();
    Packages::Init( true );

    if (! Mode::repair ())
    {
	ret = ProductControl::RunFrom (
	    ProductControl::CurrentStep () + 1,
	    false);
	if (ret == `next)
	    ret = `finish;
    }
}
else if (! Mode::repair())
{
    UpdateWizardSteps ();
    ret = ProductControl::RunFrom (
	ProductControl::CurrentStep () + 1,
	false);
    if (ret == `next)
	ret = `finish;

}

return ret;

/* EOF */
}
