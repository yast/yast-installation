/**
 * File:	clients/inst_system_analysis.ycp
 * Package:	Installation
 * Summary:	Installation mode selection, system analysis
 * Authors:	Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */

{

textdomain "installation";

import "AddOnProduct";
import "GetInstArgs";
import "Installation";
import "Kernel";
import "Label";
import "Linuxrc";
import "Mode";
import "Packages";
import "Popup";
import "PackageCallbacksInit";
import "Product";
import "ProductControl";
import "RootPart";
import "Stage";
import "Storage";
import "Update";
import "Wizard";

include "installation/misc.ycp";
include "packager/storage_include.ycp";

string start_mode = Mode::mode ();


// FIXME copy-paste from inst_mode
    define symbol handle_boot ()
    {
	y2milestone( "User wishes to boot installed system" );

	if (!RootPart::didSearchForRootPartitions)
	{
	    UI::OpenDialog (`opt(`decorated ),
			    // label
			    `Label(_("Evaluating root partition. One moment please...")));
	    RootPart::FindRootPartitions ();
	    UI::CloseDialog ();
	}

	if (RootPart::numberOfValidRootPartitions == 0)
	{
	    // a popup
	    Popup::Message(_("No Linux root partition found."));
	    return `cancel;
	}

	// We must only change RootPart::selectedRootPartition if booting
	// is inevitable.

	if (RootPart::numberOfValidRootPartitions == 1)
	{
	    RootPart::SetSelectedToValid ();
	}
	else
	{
	    if (WFM::CallFunction ("inst_rootpart", [true, true, `boot_popup]) != `next)
		return `cancel;
	}

	string root_part = RootPart::selectedRootPartition;

	UI::OpenDialog( `opt(`decorated),
			// Information popup: Inform user what partition
			// will be booted from after user selected
			// "Boot installed system"
			`Label( sformat(_("Booting from %1"), root_part ) ) );

	Update::Detach ();
	RootPart::UnmountPartitions (false);

	sleep (1000);

	if ( ! Mode::test () )
	{
	    Linuxrc::WriteYaSTInf ($["Root" : root_part]);
	    Storage::ActivateHld(true);
	}

	UI::CloseDialog ();

	return `finish;
    }

// help text for installation method
string help_text = _("<p><big><b>Installation Mode</b></big><br>
Select what to do:</p>");

// help text for installation method
help_text = help_text + _("<p>
Select <b>New Installation</b> if there is no existing Linux system on your
machine or if you want to replace an existing Linux system completely,
abandoning all its configuration data.
</p>");

// help text for installation method
help_text = help_text + _("<p>
Select <b>Update an Existing System</b> to update a Linux system already
installed on your machine. This option preserves configuration settings
from your existing system whenever possible.
</p>");

// help text for installation method
help_text = help_text + _("<p>
To install an add-on product from separate media together with &product;, select
<b>Include Add-On Products from Separate Media</b>.</p>
");

// help text for installation method
help_text = help_text + _("<p>Select <b>Other Options</b> then
select <b>Repair Installed System</b> if you have a damaged Linux system on
your hard disk. This option can try to fix problems automatically.
</p>");

// help text for installation method
help_text = help_text + _("<p>Select <b>Other Options</b> then
select <b>Boot Installed System</b> if you have a Linux system on your hard
disk that will not boot. With this option, try to fix problems manually.
</p>");

symbol current_expert_mode = `repair;

// see bugzilla #156529
term InstModeDialogContent (symbol pre_selected) {
    term other_options_layout_fix = `Empty();
    term other_options            = `Empty();

    if (pre_selected == `expert) {
	other_options_layout_fix = `VSpacing(2.1);
	other_options = `RadioButtonGroup (
	    `id (`expert_options),
	    `HBox (
		`HSpacing (6),
		`VBox (
		    `Left (`RadioButton (`id (`repair), `opt (`notify),
			// radio button
			_("Re&pair Installed System"), (current_expert_mode == `repair))),
		    `Left (`RadioButton (`id (`boot), `opt (`notify),
			// radio button
			_("Boot Installed &System"), (current_expert_mode == `boot)))
		)
	    )
	);
    }

    return `VBox (
	`VWeight (60, `HVCenter (
	    `MarginBox (
	    `leftMargin (1),
	    `rightMargin (1.5),
	    `topMargin (0.5),
	    `bottomMargin (0.5),
	    `VBox (
		other_options_layout_fix,
		`Frame (
		    // frame
		    _("Select Mode"),
		    `VBox (
			// Basis RadioButtonGroup
			`RadioButtonGroup (
			    `id (`inst_mode),
			    `VBox (
				// radio button
				`Left (`RadioButton (`id (`install), `opt(`notify), _("New &Installation"),
				    ! Mode::update ())),
				`VSpacing( 0.3 ),
				// radio button
				`Left (`RadioButton (`id (`update), `opt(`notify), _("&Update"),
				    Mode::update ())),
				`VSpacing( 1.3 ),
				`Left (`RadioButton (`id (`expert), `opt(`notify), _("&Other Options")))
			    )
			),
			// Other RadioButtonGroup
			other_options
		    )
		),
		`VSpacing (2),
		`Left (`CheckBox (`id (`add_on), `opt(`notify),
		    // check box
		    _("In&clude Add-On Products from Separate Media"))
		)
	    )
	)
	)),
	`VWeight (20, `Empty ())
    );
}

Wizard::SetContents (_("Analyzing the Computer"), `Empty (), "", false, false);
Wizard::SetTitleIcon ("yast-inst-mode");

// Do hardware probing
//
// This must happen before submodule descriptions are initialized; module
// constructors might depend on it.
// In autoinst mode, this has been called already.

y2milestone ("Probing done: %1", Installation::probing_done);
if (! Installation::probing_done)
{
    if (!Mode::autoinst ())
    {
	WFM::CallFunction("inst_startup", []);
	WFM::CallFunction("inst_features", []);
	Installation::probing_done = true;
    }
}

// FIXME copy-paste from inst_mode
    boolean offer_update = false;
    y2milestone ("Product flags: %1", Product::flags);
    if (contains (Product::flags, "update") || Kernel::GetSuSEUpdate ())
    {
	offer_update = true;
    }

// FIXME copy-paste from inst_mode
    boolean have_linux = false;
    if (Storage::HaveLinuxPartitions ())
    {
	have_linux = true;
    }

y2milestone ("Have Linux: %1, Offer Update: %2", have_linux, offer_update);

boolean other_options_disabled = false;
if (! (have_linux && offer_update))
{
    // to offer add-on products
    // Mode::SetMode ("installation");
    // return `auto;
    other_options_disabled = true;
}

// bugzilla #208222
// Release disk used as the installation source
ReleaseHDDUsedAsInstallationSource();

if (Mode::autoinst ()) {
    y2milestone ("Autoinst -> returning `auto");
    return `auto;
}

Wizard::SetContents (
    // dialog caption
    _("Installation Mode"), InstModeDialogContent(`install), help_text, true, true
);
Wizard::SetTitleIcon ("yast-software");

symbol ret = nil;
symbol new_mode = Mode::update () ? `update : `install;

string umount_result = Linuxrc::InstallInf ("umount_result");
string media = Linuxrc::InstallInf ("InstMode");
y2milestone ("Umont result: %1, inst mode: %2", umount_result, media);
if (umount_result != "0" && (media == "cd" || media == "dvd"))
    UI::ChangeWidget (`id (`add_on), `Enabled, false);

// only installation (and addon products) enabled
if (other_options_disabled) {
    UI::ChangeWidget (`id (`update), `Enabled, false);
    UI::ChangeWidget (`id (`expert), `Enabled, false);
}

// --> Handling User Input in Installation Mode

boolean add_on_selected = (boolean) UI::QueryWidget (`id (`add_on), `Value);
// Probably buggy UI, in case of two radio button groups, the second one
// doesn't work (RadioButtonGroup (`id (`expert_options)))
repeat {
    ret = (symbol) UI::UserInput();
    y2milestone("ret: %1", ret);

    // Use-Add-On-Product status changed
    if (ret == `add_on) {
	add_on_selected = (boolean) UI::QueryWidget (`id (`add_on), `Value);
	continue;
    }
    // Other Options - Boot
    else if (ret == `boot) {
	current_expert_mode = `boot;

	continue;
    // Other Options - Repair
    } else if (ret == `repair) {
	current_expert_mode = `repair;

	continue;
    }
    // Adjusting current UI - Other Options
    else if (ret == `expert) {
	// Remembering add-on state, switching off and disabling
	add_on_selected = (boolean) UI::QueryWidget (`id (`add_on), `Value);

	// Show other options
	Wizard::SetContents (
	    // dialog caption
	    _("Installation Mode"), InstModeDialogContent(`expert), help_text, true, true
	);
	
	UI::ChangeWidget (`id(`add_on), `Value, false);
	UI::ChangeWidget (`id(`add_on), `Enabled, false);
	UI::ChangeWidget (`id(`inst_mode), `CurrentButton, `expert);
	
	continue;
    }
    // Adjusting current UI - Hide Other Options
    // in case of `install or `update clicked
    else if (contains([`install, `update], ret)) {
	symbol selected_mode = (symbol)  UI::QueryWidget (`id (`inst_mode), `CurrentButton);

	// Hide other options
	Wizard::SetContents (
	    // dialog caption
	    _("Installation Mode"), InstModeDialogContent(`install), help_text, true, true
	);

	// Enabling add-on, adjusting previous state (selected)
	UI::ChangeWidget  (`id(`add_on), `Enabled, true);
	UI::ChangeWidget  (`id(`add_on), `Value, add_on_selected);
	// Can be either `install or `update
	UI::ChangeWidget  (`id(`inst_mode), `CurrentButton, selected_mode);
    }

    // Next button
    if (ret == `next)
    {
	new_mode = (symbol) UI::QueryWidget (`id (`inst_mode), `CurrentButton);
	if (new_mode == nil)
	{
	    // this is a label of a message box
	    Popup::Message(_("Choose one of the\noptions to continue."));
	    continue;
	}
	
	// Repair or Boot
	if (new_mode == `expert) {
	    if (! contains([`boot, `repair], current_expert_mode)) {
		y2error("Internal error: Widget `expert_mode selected item: %1", current_expert_mode);
		ret = nil;
		continue;
	    }
	    new_mode = current_expert_mode;
	    
	    // Boot was selected
	    if (new_mode == `boot) {
		Mode::SetMode ("");
		if (handle_boot() != `finish) {
		    y2milestone("Not booting any OS");
		    continue;
		}
	    }
	}
    }
    else if (ret == `abort)
    {
	if (Popup::ConfirmAbort (Stage::initial () ? `painless : `incomplete))
	    return `abort;
	continue;
    }
} until (ret == `back || ret == `next);

// <-- Handling User Input in Installation Mode

y2milestone("Selected mode: %1, Return: %2", new_mode, ret);
if (ret == `next)
{
    if (new_mode == `install)
    {
	Mode::SetMode ("installation");
    }

    if (new_mode == `update)
    {
	Mode::SetMode ("update");
    }

    if (new_mode == `repair)
    {
	Mode::SetMode ("repair");
    }

    if (new_mode == `boot)
    {
	Mode::SetMode ("");
	ret = `finish;
    }

    if (new_mode == `install || new_mode == `update)
    {
	boolean add_on = (boolean)UI::QueryWidget (`id (`add_on), `Value);
	ProductControl::DisabledModules = filter (string m, ProductControl::DisabledModules, {
	    return m != "add-on" && m != "inst_add-on";
	});
	if (! add_on)
	{
	    ProductControl::DisabledModules = add (ProductControl::DisabledModules, "add-on");
	    ProductControl::DisabledModules = add (ProductControl::DisabledModules, "inst_add-on");
	}
    }
}

if (ret == `back || ret == `finish) {
    y2milestone("Returning: %1", ret);
    return ret;
}

if (Mode::repair ())
{
    y2milestone("Calling inst_repair");
    WFM::CallFunction ("inst_repair");
    return `finish;
}

Packages::InitializeCatalogs ();
if (Packages::InitFailed ())
{
    // popup message
    Popup::Message (_("Failed to initialize catalogs.
Aborting the installation."));
    return `abort;
}
Packages::InitializeAddOnProducts ();

if (Mode::mode () != start_mode)
{
    y2milestone ("Switching Steps from %1 to %2 ", start_mode, Mode::mode ());
    UpdateWizardSteps ();
    y2milestone ("Resetting disk target to read values");
    Storage::ResetOndiskTarget ();
    y2debug ("Original target map (from disk): %1", Storage::GetTargetMap ());
    y2milestone ("Resetting package manager");
    Kernel::ProbeKernel();
    Pkg::TargetFinish ();
    Pkg::PkgReset ();
    Packages::Init( true );

    if (! Mode::repair ())
    {
	ret = ProductControl::RunFrom (
	    ProductControl::CurrentStep () + 1,
	    false);
	if (ret == `next)
	    ret = `finish;
    }
}
else if (! Mode::repair())
{
    UpdateWizardSteps ();
    ret = ProductControl::RunFrom (
	ProductControl::CurrentStep () + 1,
	false);
    if (ret == `next)
	ret = `finish;

}

return ret;

/* EOF */
}
