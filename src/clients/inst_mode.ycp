/**
 * File:	clients/inst_system_analysis.ycp
 * Package:	Installation
 * Summary:	Installation mode selection, system analysis
 * Authors:	Jiri Srain <jsrain@suse.cz>
 *		Lukas Ocilka <locilka@suse.cz>
 *
 * $Id$
 *
 */

{

textdomain "installation";

import "AddOnProduct";
import "GetInstArgs";
import "Installation";
import "InstData";
import "Kernel";
import "Linuxrc";
import "Mode";
import "PackageCallbacksInit";
import "Packages";
import "Popup";
import "ProductControl";
import "Report";
import "Stage";
import "Storage";
import "Wizard";
import "ProductFeatures";

include "packager/storage_include.ycp";
include "installation/misc.ycp";

InstData::start_mode = Mode::mode();

// always check whether user wants to continue
AddOnProduct::skip_add_ons = false;

map display_info = UI::GetDisplayInfo();
boolean in_textmode = display_info["TextMode"]:false;

string GenerateIconID (any icon_whatever) {
    return sformat ("icon_%1", tostring (icon_whatever));
}

/**
 * Function creates term containing radio button and icon
 * based on current display (graphical/textual)
 *
 * @param string radio button label
 * @param symbol radio button id
 * @param string path to an image
 * @boolean whether selected (more than one buttons selected don't make sense!)
 */
 term CreateRadioButtonTerm (string button_label, symbol button_id, string icon_file, boolean selected) {
    return `HBox (
	(in_textmode ?
	    `Empty()
	    :
	    `HWeight (
		1,
		(icon_file == "" ?
		    `Empty()
		    :
		    `Image (`id (GenerateIconID (button_id)), icon_file, "")
		)
	    )
	),
	`HWeight(
	    5,
	    `Left (`RadioButton (
		`id (button_id),
		`opt(`notify),
		button_label,
		selected
	    ))
	)
    );
}

Wizard::SetTitleIcon ("yast-inst-mode");

// In case of going back from Update/New Installation
if (GetInstArgs::going_back()) {
    Pkg::TargetFinish();
}

boolean other_options_disabled = false;

if (! (InstData::have_linux && InstData::offer_update))
{
    // to offer add-on products
    // Mode::SetMode ("installation");
    // return `auto;
    other_options_disabled = true;
}

// bugzilla #208222
// Release disk used as the installation source
ReleaseHDDUsedAsInstallationSource();

if (Mode::autoinst ()) {
    y2milestone ("Autoinst -> returning `auto");
    return `auto;
}

boolean show_online_repositories = ProductFeatures::GetBooleanFeature ("globals", "show_online_repositories");
// if not visible, internally disabled as well
if (show_online_repositories != true) {
    Installation::productsources_selected = false;
}

// see bugzilla #156529
term InstModeDialogContent (symbol pre_selected) {
    return `HBox (
	    `HStretch(),
	    `VBox (
		`Frame (
		    // frame
		    _("Select Mode"),
		    `VBox (
			// Basis RadioButtonGroup
			`RadioButtonGroup (
			    `id (`inst_mode),
			    `MarginBox (
				2, 1.3,
				`VBox (
				    // radio button
				    CreateRadioButtonTerm (
					_("New &Installation"),
					`install,
					"/usr/share/icons/hicolor/32x32/apps/yast-dirinstall.png",
					!Mode::update ()
				    ),
				    `VSpacing( 0.3 ),
				    // radio button
				    CreateRadioButtonTerm (
					_("&Update"),
					`update,
					"/usr/share/icons/hicolor/32x32/apps/yast-update.png",
					Mode::update ()
				    ),
				    `VSpacing( 1.8 ),
				    // radio button
				    CreateRadioButtonTerm (
					_("Re&pair Installed System"),
					`repair,
					"/usr/share/icons/hicolor/32x32/apps/yast.png",
					false
				    )
				)
			    )
			)
		    )
		),
		`VSpacing (2),
		(show_online_repositories == true ?
		    `Left (`CheckBox (
			`id (`productsources), `opt(`notify),
			// check box
			_("&Add Online Repositories Before Installation"),
			Installation::productsources_selected
		    ))
		    :
		    `Empty()
		),
		`Left (`CheckBox (
		    `id (`add_on), `opt(`notify),
		    // check box
		    _("In&clude Add-On Products from Separate Media"),
		    Installation::add_on_selected
		))
	    ),
	    `HStretch()
	);
}

string InstModeDialogHelp () {
    // help text for installation method
    return _("<p><big><b>Installation Mode</b></big><br>
Select what to do:</p>") +

    // help text for installation method
    _("<p>
Select <b>New Installation</b> if there is no existing Linux system on your
machine or if you want to replace an existing Linux system completely,
abandoning all its configuration data.
</p>") +

    // help text for installation method
    _("<p>
Select <b>Update an Existing System</b> to update a Linux system already
installed on your machine. This option preserves configuration settings
from your existing system whenever possible.
</p>") +

    // help text for installation option
    (show_online_repositories == true ? _("<p>
To use suggested remote repositories during installation or update, select
<b>Add Online Repositories Before Installation</b>.</p>
"):"") +

    // help text for installation method
    _("<p>
To install an add-on product from separate media together with &product;, select
<b>Include Add-On Products from Separate Media</b>.</p>
") +

    // help text for installation method
    _("<p>Select <b>Repair Installed System</b> if you have a damaged Linux system on
your hard disk. This option can try to fix problems automatically.
</p>") +

    // help text for installation method
    _("<p>Features <b>Update</b> and <b>Repair Installed System</b> are only
available if some Linux system has been detected.
</p>");
}

Wizard::SetContents (
    // dialog caption
    _("Installation Mode"), InstModeDialogContent(`install), InstModeDialogHelp(), true, true
);
Wizard::SetTitleIcon ("yast-software");

symbol ret = nil;
symbol new_mode = Mode::update () ? `update : `install;

string umount_result = Linuxrc::InstallInf ("umount_result");
string media = Linuxrc::InstallInf ("InstMode");
y2milestone ("Umont result: %1, inst mode: %2", umount_result, media);

// there are not only CD and DVD Add-On sources
//if (umount_result != "0" && (media == "cd" || media == "dvd"))
//    UI::ChangeWidget (`id (`add_on), `Enabled, false);

// only installation (and addon products) enabled
if (other_options_disabled) {
    UI::ChangeWidget (`id (`update), `Enabled, false);
    UI::ChangeWidget (`id (`repair), `Enabled, false);

    // disable also icons related to options if supported by UI
    if (! in_textmode) {
	foreach (symbol image_id, [`update, `repair], {
	    string icon_id = GenerateIconID (image_id);

	    if (UI::WidgetExists (`id(icon_id))) {
		UI::ChangeWidget (`id (icon_id), `Enabled, false);
	    }
	});
    }
}

// --> Handling User Input in Installation Mode

ProductControl::DisabledModules = add (ProductControl::DisabledModules, "add-on");
ProductControl::DisabledModules = add (ProductControl::DisabledModules, "inst_add-on");
ProductControl::DisabledModules = add (ProductControl::DisabledModules, "productsources");
ProductControl::DisabledModules = add (ProductControl::DisabledModules, "inst_productsources");
UpdateWizardSteps();

// Probably buggy UI, in case of two radio button groups, the second one
// doesn't work (RadioButtonGroup (`id (`expert_options)))
repeat {
    ret = (symbol) UI::UserInput();
    y2milestone("ret: %1", ret);

    // Use-Add-On-Product status changed
    if (ret == `add_on) {
	if (UI::WidgetExists (`id (`add_on)))
	    Installation::add_on_selected = (boolean) UI::QueryWidget (`id (`add_on), `Value);
	ret = nil;
	continue;
    }
    // Use Sources defined by product
    else if (ret == `productsources) {
	if (UI::WidgetExists (`id (`productsources))) {
	    Installation::productsources_selected = (boolean) UI::QueryWidget (`id (`productsources), `Value);
	}
	ret = nil;
	continue;
    }
    // Adjusting current UI - Other Options
    else if (ret == `repair) {
	// Remembering add-on state, switching off and disabling
	if (UI::WidgetExists (`id (`add_on))) {
	    Installation::add_on_selected = (boolean) UI::QueryWidget (`id (`add_on), `Value);

	    UI::ChangeWidget (`id(`add_on), `Value, false);
	    UI::ChangeWidget (`id(`add_on), `Enabled, false);
	}

	if (UI::WidgetExists (`id (`productsources))) {
	    UI::ChangeWidget (`id(`productsources), `Value, false);
	    UI::ChangeWidget (`id(`productsources), `Enabled, false);
	}

	ret = nil;
	continue;
    }
    // Adjusting current UI - Hide Other Options
    // in case of `install or `update clicked
    else if (contains([`install, `update], ret)) {
	symbol selected_mode = (symbol)  UI::QueryWidget (`id (`inst_mode), `CurrentButton);

	// Enabling add-on, adjusting previous state (selected)
	if (UI::WidgetExists (`id (`add_on))) {
	    UI::ChangeWidget  (`id(`add_on), `Enabled, true);
	    UI::ChangeWidget  (`id(`add_on), `Value, Installation::add_on_selected);
	}

	if (UI::WidgetExists (`id (`productsources))) {
	    UI::ChangeWidget  (`id(`productsources), `Enabled, true);
	    UI::ChangeWidget  (`id(`productsources), `Value, Installation::productsources_selected);
	}

	// Can be either `install or `update
	UI::ChangeWidget  (`id(`inst_mode), `CurrentButton, selected_mode);
    }

    // Next button
    if (ret == `next)
    {
	new_mode = (symbol) UI::QueryWidget (`id (`inst_mode), `CurrentButton);
	if (new_mode == nil)
	{
	    // this is a label of a message box
	    Popup::Message(_("Choose one of the\noptions to continue."));
	    ret = nil;
	    continue;
	}
    }
    else if (ret == `abort)
    {
	if (Popup::ConfirmAbort (Stage::initial () ? `painless : `incomplete))
	    return `abort;
	ret = nil;
	continue;
    }
} until (ret == `back || ret == `next);

// <-- Handling User Input in Installation Mode

y2milestone("Selected mode: %1, Return: %2", new_mode, ret);

if (ret == `next) {
    if (new_mode == `install)
    {
	Mode::SetMode ("installation");
    }

    if (new_mode == `update)
    {
	Mode::SetMode ("update");
    }

    if (new_mode == `repair)
    {
	Mode::SetMode ("repair");
    }

    if (new_mode == `install || new_mode == `update)
    {
	Installation::add_on_selected = (boolean) UI::QueryWidget (`id (`add_on), `Value);
	ProductControl::DisabledModules = filter (string m, ProductControl::DisabledModules, {
	    return m != "add-on" && m != "inst_add-on";
	});
	if (! Installation::add_on_selected)
	{
	    ProductControl::DisabledModules = add (ProductControl::DisabledModules, "add-on");
	    ProductControl::DisabledModules = add (ProductControl::DisabledModules, "inst_add-on");
	}

	if (UI::WidgetExists (`id (`productsources))) {
	    Installation::productsources_selected = (boolean) UI::QueryWidget (`id (`productsources), `Value);
	}
	ProductControl::DisabledModules = filter (string m, ProductControl::DisabledModules, {
	    return m != "productsources" && m != "inst_productsources";
	});
	if (! Installation::productsources_selected)
	{
	    ProductControl::DisabledModules = add (ProductControl::DisabledModules, "productsources");
	    ProductControl::DisabledModules = add (ProductControl::DisabledModules, "inst_productsources");
	}

	y2milestone ("Disabled: %1", ProductControl::DisabledModules);
    }

} else if (ret == `back || ret == `finish) {
    y2milestone("Returning: %1", ret);
    return ret;
}

if (Mode::repair ())
{
    y2milestone("Calling inst_repair");
    any ret = WFM::CallFunction ("inst_repair");

    if (ret == nil) {
	Report::Error (
	    // TRANSLATORS: an error message (the same is in base.pot)
	    // this should not happen, but life is cruel...
	    // %1 - (failed) module name
	    // %2 - logfile, possibly with errors
	    // %3 - link to our bugzilla
	    // %4 - directory where YaST logs are stored
	    sformat (_("Calling the YaST module %1 has failed.
More information can be found near the end of the '%2' file.

This is worth reporting a bug at %3.
Please, attach also all YaST logs stored in the '%4' directory."),
	    "inst_repair",
	    "/var/log/YaST2/y2log",
	    "http://bugzilla.novell.com/",
	    "/var/log/YaST2/")
	);
    }

    return `finish;
}

// bugzilla #293808
// Check (and setup) the network only when needed
if (Installation::add_on_selected || Installation::productsources_selected) {
    // Check and setup network
    symbol inc_ret = (symbol) WFM::CallFunction ("inst_network_check", []);
    y2milestone ("inst_network_check ret: %1", inc_ret);
    if (contains ([`back, `abort], inc_ret)) {
	return inc_ret;
    }
}

// bug #302384
Wizard::SetContents (
    _("Initializing"),
    // TRANSLATORS: progress message
    `Label (_("Initializing...")),
    "",
    false, false
);
Wizard::SetTitleIcon ("yast-software");

if (Mode::mode () != InstData::start_mode) {
    y2milestone ("Switching Steps from %1 to %2 ", InstData::start_mode, Mode::mode ());
    UpdateWizardSteps ();
    y2milestone ("Resetting disk target to read values");
    Storage::ResetOndiskTarget ();
    y2debug ("Original target map (from disk): %1", Storage::GetTargetMap ());
    y2milestone ("Resetting package manager");
    Kernel::ProbeKernel();
    Pkg::TargetFinish ();
    Pkg::PkgReset ();
    Packages::Init( true );

    ret = ProductControl::RunFrom (ProductControl::CurrentStep () + 1, false);

    if (ret == `next)
	ret = `finish;
} else {
    UpdateWizardSteps ();
    ret = ProductControl::RunFrom (ProductControl::CurrentStep () + 1, false);

    if (ret == `next)
	ret = `finish;
}

return ret;

/* EOF */
}
