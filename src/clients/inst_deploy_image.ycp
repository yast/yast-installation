{
import "Installation";
import "ImageInstallation";
import "Progress";
import "Wizard";
import "SourceManager";
import "String";
import "PackageCallbacks";

textdomain "installation";

// There is nothing to do
if (! Installation::image_installation) {
    y2milestone ("No images have been selected");
    // bnc #395030
    // Use less memory
    ImageInstallation::FreeInternalVariables();
    return `auto;
}

y2milestone ("Deploying images");

list<string> images = ImageInstallation::ImageOrder ();

integer last_image = nil;

integer _last_download_progress = -1;

integer _current_overall_progress = 0;
integer _last_overall_progress = -1;

integer _current_subprogress_start = 0;
integer _current_subprogress_steps = 0;
integer _current_subprogress_total = 0;

integer _current_step_in_subprogress = 0;

string _previous_id = nil;

void SetProgress () {
    integer percent = 100 * _current_step_in_subprogress / _current_subprogress_total;
    UI::ChangeWidget (`id ("one_image"), `Value, percent);
}

void OverallProgressHandler (string id, integer current_step) {
    // new set of steps
    if (_previous_id != id) {
	// reset steps in subprogress
	_current_step_in_subprogress = 0;

	// new settings for new step
	_current_subprogress_start = ImageInstallation::GetProgressLayoutDetails (id, "steps_start_at");
	_current_subprogress_steps = ImageInstallation::GetProgressLayoutDetails (id, "steps_reserved");
	_current_subprogress_total = ImageInstallation::GetProgressLayoutDetails (id, "steps_total");

	// div by zero!
	if (_current_subprogress_total == 0) {
	    y2error ("steps_total=0");
	    _current_subprogress_total = 100;
	}

	y2milestone (
	    "New overall progress ID: %1 (steps_start_at: %2, steps_reserved: %3, steps_total: %4)",
	    id, _current_subprogress_start, _current_subprogress_steps, _current_subprogress_total
	);

	// when deploying images, label is handled separately
	if (id != "deploying_images") {
	    string new_label = ImageInstallation::GetProgressLayoutLabel (id);
	    UI::ChangeWidget (`id ("one_image"), `Label, new_label);
	}

	_previous_id = id;
    }

    // incremental
    if (current_step == nil) {
	_current_step_in_subprogress = _current_step_in_subprogress + 1;
    // set to exact number
    } else {
	_current_step_in_subprogress = current_step;
    }

    if (id == "storing_user_prefs" || id == "restoring_user_prefs") {
	SetProgress();
    }

    _current_overall_progress = _current_subprogress_start +
	(_current_subprogress_steps * _current_step_in_subprogress / _current_subprogress_total);

    // update UI only if nr% has changed
    if (_current_overall_progress > _last_overall_progress) {
	_last_overall_progress = _current_overall_progress;
	UI::ChangeWidget (`id ("deploying_progress"), `Value, _current_overall_progress);
    }
}

integer _steps_for_one_image = 100;
boolean download_handler_hit = false;

boolean MyProgressDownloadHandler (integer percent, integer bps_avg, integer bps_current) {
    // changing settings on the fly
    // ... first when download handler is hit
    if (! download_handler_hit) {
	y2milestone ("DownloadHandler - first hit");
	// twice more steps
	ImageInstallation::AdjustProgressLayout ("deploying_images", (2 * _steps_for_one_image * size (images)), _("Deploying Images..."));
	download_handler_hit = true;
    }

    map <string, any> current_image = ImageInstallation::GetCurrentImageDetails();

    if (_last_download_progress < percent) {
	string current_image_name = current_image["name"]:"";
	if (current_image_name == "") {
	    UI::ChangeWidget (
		`id ("one_image"), `Label,
		sformat (_("Downloading image at speed %1/s"), String::FormatSize (bps_current))
	    );
	} else {
	    UI::ChangeWidget (
		`id ("one_image"), `Label,
		sformat (_("Downloading image %1 at speed %2/s"), current_image_name, String::FormatSize (bps_current))
	    );
	}

	UI::ChangeWidget (`id ("one_image"), `Value, percent);

	integer current_image_nr = current_image["image_nr"]:0;
	integer current_steps = 0;

	if (download_handler_hit) {
	    current_steps = (current_image_nr * 2 * _steps_for_one_image) + percent;
	} else {
	    current_steps = (current_image_nr * _steps_for_one_image) + percent;
	}

	OverallProgressHandler ("deploying_images", current_steps);
    }

    _last_download_progress = percent;

    return true;
}

integer _last_progress = -1;
string _last_image_id = nil;

void SetOneImageProgress (integer current_progress) {
    map <string, any> current_image = ImageInstallation::GetCurrentImageDetails();
    integer max_progress = current_image["max_progress"]:0;

    // another file than the previous one
    if (current_image["file"]:"" != _last_image_id) {
	_last_image_id = current_image["file"]:"";
	_last_download_progress = -1;
	_last_progress = -1;
    }

    if (max_progress == nil || max_progress == 0) {
	y2milestone ("Can't find max_progress: %1", current_image);
	return;
    }

    // current progress 0 - 100
    integer x_progress = (100 * current_progress / max_progress);
    if (x_progress > 100) x_progress = 100;

    // reset the label
    if (x_progress == 0) {
	string current_image_name = current_image["name"]:"";
	if (current_image_name == "") {
	    UI::ChangeWidget (`id ("one_image"), `Label, _("Deploying image..."));
	} else {
	    UI::ChangeWidget (`id ("one_image"), `Label, sformat (_("Deploying image %1..."), current_image_name));
	}
    // one image done
    } else if (x_progress == 100) {
	UI::ChangeWidget (`id ("one_image"), `Label, _("Image deployed"));
    }

    // set current step
    if (x_progress > _last_progress) {
	 UI::ChangeWidget (`id ("one_image"), `Value, x_progress);
	_last_progress = x_progress;
	integer current_image_nr = current_image["image_nr"]:0;
	integer current_steps = 0;

	if (download_handler_hit) {
	    current_steps = ((current_image_nr * 2 + 1) * _steps_for_one_image) + x_progress;
	} else {
	    current_steps = (current_image_nr * _steps_for_one_image) + x_progress;
	}

	OverallProgressHandler ("deploying_images", current_steps);
    }
}

ImageInstallation::SetDeployTarImageProgress (SetOneImageProgress);
ImageInstallation::SetDownloadTarImageProgress (MyProgressDownloadHandler);
ImageInstallation::SetOverallDeployingProgress (OverallProgressHandler);

ImageInstallation::AdjustProgressLayout ("deploying_images", (_steps_for_one_image * size (images)), _("Deploying Images..."));

Wizard::SetContents (
    _("Deploying Installation Images"),
    `VBox (
	`ProgressBar (
	    `id ("one_image"),
	    _("Initializing..."),
	    100,
	    0
	),
	`ProgressBar (
	    `id ("deploying_progress"),
	    _("Deploying Images..."),
	    100,
	    0
	)
    ),
    // TRANSLATORS: help idi#1
    _("<p>Please wait, while system images are just being deployed...</p>") +

    // TRANSLATORS: help idi#2
    _("<p>Installation images are part of the installation media.</p>") +

    // TRANSLATORS: help idi#3
    _("<p>Installation from images is faster than installation from RPM packages
because it does not need to handle with with RPM database, locks etc.
One of the images also contains the joint RPM database and other metadata.</p>") +

    // TRANSLATORS: help idi#4
    _("<p>If there is no direct access to installation images,
installation program has to download them first before they are deployed.</p>"),
    false, false
);

ImageInstallation::StoreAllChanges();

Pkg::TargetFinish ();

Wizard::SetTitleIcon ("yast-inst-mode");

SourceManager::InstInitSourceMoveDownloadArea();

boolean dep_ret = ImageInstallation::DeployImages (images, Installation::destdir, nil);
if (dep_ret == nil) {
    y2milestone ("Aborting...");
    return `abort;
}

y2milestone ("Target image for package selector prepared");

PackageCallbacks::RegisterEmptyProgressCallbacks();
Pkg::TargetInitialize (Installation::destdir);
Pkg::TargetLoad ();
PackageCallbacks::RestorePreviousProgressCallbacks();

ImageInstallation::RestoreAllChanges();

// bnc #395030
// Use less memory
ImageInstallation::FreeInternalVariables();

return `next;

}
