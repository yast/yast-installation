/**
 * File:	clients/inst_software_selection.ycp
 * Package:	Installation
 * Summary:	Replacement for Desktop Selection and Simple Pattern Selector
 * Authors:	Lukas Ocilka <locilka@suse.cz>
 *
 * $Id:$
 *
 */

{

textdomain "installation";

import "ProductFeatures";
import "InstData";
import "GetInstArgs";
import "DefaultDesktop";
import "Wizard";
import "Packages";
import "Popup";
import "Stage";
import "Directory";
import "Icon";

// do not offer the dialog if base selection is fixed
if (ProductFeatures::GetFeature ("software", "selection_type") == `fixed)
    return `auto;

boolean text_mode = UI::GetDisplayInfo()["TextMode"]:false;

if (DefaultDesktop::Desktop() == nil || DefaultDesktop::Desktop() == "") {
    DefaultDesktop::Init();
}

// TRANSLATORS: help text, part 1
string help = _("<p>At Linux <b>choice</b> is a top priority. <i>openSUSE</i> offers a number
of different desktop environments. Below you see a list of the 2 major ones
<b>GNOME</b> and <b>KDE</b>. Both provide an easy to use desktop with a large number
of desktop applications such as email, file browser, games and many others.</p>") +

// TRANSLATORS: help text, part 2
_("<p>As desktop selection is a matter of taste a clear <i>recommendation can't be
given</i>.</p>") +

// TRANSLATORS: help text, part 3
_("Additionally, not only desktop but you can also chose a minimalistic
installation that could fit your needs better.");

map <string, map> all_desktops = DefaultDesktop::GetAllDesktopsMap();

void SelectSoftwareNow () {
    y2milestone ("Selected desktop: %1", DefaultDesktop::Desktop());
    DefaultDesktop::SetDesktop (DefaultDesktop::Desktop());

    Packages::ForceFullRepropose();
    Packages::Reset ([`product]);

    foreach (string one_pattern, (list <string>) all_desktops[DefaultDesktop::Desktop(), "patterns"]:[], {
	y2milestone ("Marking desktop pattern to be installed: %1", one_pattern);
	Pkg::ResolvableInstall (one_pattern, `pattern);
    });
}

string GetDesktopRadioButtonId (string desktop_name) {
    if (desktop_name == nil || desktop_name == "") {
	y2warning ("Wrong desktop name: %1", desktop_name);
	return "";
    }

    return sformat ("selected_desktop_%1", desktop_name);
}

term GetDesktops () {
    list <string> sort_order = maplist (string desktop_name, map one_desktop, all_desktops, {
	return desktop_name;
    });

    sort_order = sort (string x, string y, sort_order, ``(all_desktops[x,"order"]:99 < all_desktops[y,"order"]:99));

    term ret = `VBox ();

    integer counter = -1;
    integer last_desktop_order = -1;

    foreach (string desktop_name, sort_order, {
	counter = counter + 1;
	integer desktop_order = all_desktops[desktop_name,"order"]:99;

	y2milestone ("L: %1, C: %2", last_desktop_order, desktop_order);
	// bnc #379157
	// some space between 'Base' and 'Other' desktops
	if (last_desktop_order == 1 && desktop_order > 1) {
	    ret[counter] = `VSpacing (1);
	    counter = counter + 1;
	}

	ret[counter] =
	    `Left (`HBox (
		`Image (Icon::IconPath(all_desktops[desktop_name,"icon"]:"yast"), ""),
		`HSpacing (2),
		`RadioButton (
		    `id (GetDesktopRadioButtonId (desktop_name)),
		    `opt (`notify),
		    all_desktops[desktop_name,"label"]:""
		)
	    ));

	last_desktop_order = desktop_order;
    });

    return ret;
}

void RedrawSelDesktopInfo (string currently_selected) {
    string description = "";

    if (currently_selected == nil || currently_selected == "") {
	y2milestone ("No desktop is currently selected");

	// TRANSLATORS: dialog hint
	description = _("Select a system to get its description.");
    } else {
	y2milestone ("Selected desktop: %1", currently_selected);

	list <string> desktop_patterns = all_desktops[currently_selected,"patterns"]:[];
	list <map <string, any> > res_properties = Pkg::ResolvableProperties (currently_selected, `pattern, "");

	// TRANSLATORS: rich-text content
	description = res_properties[0,"description"]:_("No description available...");
    }

    UI::ChangeWidget (`id ("desktop_description"), `Value, description);
}

term contents = `HBox (
    `HStretch(),
    `HSquash (
	`VBox (
	    `HSpacing (50),
	    `VWeight (5, `VStretch()),
	    // TRANSLATORS: Label (of a Radio button group)
	    `Left (`Label (`opt(`boldFont), _("Select a System Type"))),
	    `RadioButtonGroup (
		`id ("selected_desktop"),
		`opt (`hstretch),
		// TRANSLATORS: Combo box
		GetDesktops()
	    ),
	    `VSpacing (1),
	    `VSquash (`Frame (
		_("Description"),
		`MinHeight (7, `RichText (
		    `id ("desktop_description"),
		    ""
		))
	    )),
	    `VWeight (5, `VStretch())
	)
    ),
    `HStretch()
);

// TRANSLATORS: dialog caption
string caption = _("System Type");

// Set UI
Wizard::SetContents (caption, contents, help,
    Stage::initial() ? GetInstArgs::enable_back():true,
    Stage::initial() ? GetInstArgs::enable_next():true
);
Wizard::SetTitleIcon ("yast-desktop-select");

// Adjust default values
if (! UI::WidgetExists (`id ("selected_desktop"))) {
    y2error (-1, "Widget selected_desktop does not exist");
} else if (DefaultDesktop::Desktop() != nil && DefaultDesktop::Desktop() != "") {
    y2milestone ("Already selected desktop: %1", DefaultDesktop::Desktop());
    UI::ChangeWidget (`id ("selected_desktop"), `Value, GetDesktopRadioButtonId (DefaultDesktop::Desktop()));
}

RedrawSelDesktopInfo (DefaultDesktop::Desktop());

// UI wait loop
any ret = nil;
while (true) {
    ret = UI::UserInput();

    if (is (ret, string) && regexpmatch (tostring (ret), "^selected_desktop_.*")) {
	string currently_selected = regexpsub (tostring (ret), "^selected_desktop_(.*)", "\\1");

	if (currently_selected != nil && currently_selected != "")
	    RedrawSelDesktopInfo (currently_selected);
    } else if (ret == `next) {
	string currently_selected = (string) UI::QueryWidget (`id ("selected_desktop"), `Value);
	DefaultDesktop::SetDesktop (regexpsub (tostring (currently_selected), "^selected_desktop_(.*)", "\\1"));

	if (DefaultDesktop::Desktop() != nil && haskey (all_desktops, DefaultDesktop::Desktop())) {
	    SelectSoftwareNow ();
	    break;
	}
	Popup::Message (_("No system type was selected.
Select the default type."));
	continue;
    } else if (ret == `abort || ret == `cancel) {
	if (Popup::ConfirmAbort (Stage::initial () ? `painless : `incomplete)) {
	    ret = `abort;
	    break;
	}
	continue;
    } else if (ret == `back) {
	break;
    } else {
	y2error ("Input %1 not handled", ret);
    }
}

return (symbol) ret;

/* EOF */
}
