/**
 * File:
 *	ImageInstallation.ycp
 *
 * Module:
 *	ImageInstallation
 *
 * Summary:
 *	Support functions for installation via images
 *
 * Authors:
 *	Jiri Srain <jsrain@suse.cz>
 *	Lukas Ocilka <locilka@suse.cz>
 *
 */
{

module "ImageInstallation";

import "Installation";
import "XML";
import "Progress";
import "Report";
import "String";
import "Arch";

textdomain "installation";

/**
 * Repository holding all images
 */
integer _repo = nil;

/**
 * Description of all available images
 */
map<string,map<string,any> > _images = $[];

/**
 * Order of images
 */
list<string> _image_order = [];

/**
 * Image with software management metadata
 */
string _metadata_image = "";

/**
 * Template for the path for an image on the media
 */
string _image_path = "/images/%1";

/**
 * List of already mounted images
 */
list<string> _mounted_images = [];

/**
 * Set the repository to get images from
 * @param repo integer the repository identification
 */
global void SetRepo (integer repo) {
    _repo = repo;
}

/**
 * Name of image containing software management metadata (if exists)
 * @return string image with sw mgmt metadata
 */
global string SwMgmtImage () {
    return _metadata_image;
}

/**
 * Order of images to be deployed
 * @return a list of images definint the order
 */
global list<string> ImageOrder () {
    return _image_order;
}

/**
 * Returns list of currently selected images.
 *
 * @return map <string,map <string,any> > images
 * @see AddImage
 *
 * @struct $[
 *   "image_id":$[
 *     "file":filename,
 *     "type":type
 *   ], ...
 * ]
 */
map <string,map <string,any> > GetCurrentImages () {
    return _images;
}

/**
 * Add information about new image
 * @param name string the name/id of the image
 * @param file string the file name of the image
 * @param type string the type of the image, one of "tar" and "fs"
 */
void AddImage (string name, string file, string type) {
    _images[file] = $[
	"file" : file,
	"type" : type,
	"name" : name,
    ];
}

/**
 * Deploy an image of the filesystem type
 * @param id string the id of the image
 * @param target string the directory to deploy the image to
 * @return boolean true on success
 */
boolean DeployTarImage (string id, string target) {
    string file = _images[id, "file"]:"";
    y2milestone ("Untarring image %1 (%2) to %3", id, file, target);
    file = sformat (_image_path, file);
    string image = Pkg::SourceProvideFile (_repo, 1, file);
    if (image == nil)
    {
	y2error ("File %1 not found on media", file);
	return false;
    }

    y2milestone ("Creating target directory");
    string cmd = sformat ("test -d %1 || mkdir -p %1", target);
    map out = (map)SCR::Execute (.target.bash_output, cmd);
    y2milestone ("Executing %1 returned %2", cmd, out);

    y2milestone ("Untarring the image");

    // TODO: Progress `tar --checkpoint`

    // lzma
    if (regexpmatch (image, "\.lzma$")) {
	cmd = sformat ("lzmadec < '%1' | tar --totals -C '%2' -xf -", String::Quote (image), String::Quote (target));
    // bzip2, gzip
    } else {
	cmd = sformat ("tar --totals -C '%2' -xf '%1'", String::Quote (image), String::Quote (target));
    }
    y2milestone ("Calling: %1", cmd);

    out = (map)SCR::Execute (.target.bash_output, cmd);
    y2milestone ("Returned %1", out);

    return out["exit"]:-1 == 0;
}

/**
 * Deploy an image of the filesystem type
 * @param id string the id of the image
 * @param target string the directory to deploy the image to
 * @return boolean true on success
 */
boolean DeployFsImage (string id, string target) {
    string file = _images[id, "file"]:"";
    y2milestone ("Deploying FS image %1 (%2) on %3", id, file, target);
    file = sformat (_image_path, file);
    string image = Pkg::SourceProvideFile (_repo, 1, file);
    if (image == nil)
    {
	y2error ("File %1 not found on media", file);
	return false;
    }

    y2milestone ("Creating temporary directory");
    string tmpdir = (string)SCR::Read (.target.tmpdir) + sformat ("/images/%1", id);
    string cmd = sformat ("test -d %1 || mkdir -p %1", tmpdir);
    map out = (map)SCR::Execute (.target.bash_output, cmd);
    y2milestone ("Executing %1 returned %2", cmd, out);

    y2milestone ("Mounting the image");
    cmd = sformat ("mount -o loop %1 %2", image, tmpdir);
    out = (map)SCR::Execute (.target.bash_output, cmd);
    y2milestone ("Executing %1 returned %2", cmd, out);

    y2milestone ("Creating target directory");
    cmd = sformat ("test -d %1 || mkdir -p %1", target);
    out = (map)SCR::Execute (.target.bash_output, cmd);
    y2milestone ("Executing %1 returned %2", cmd, out);

    y2milestone ("Copying contents of the image");
    cmd = sformat ("cp -a %1/* %2", tmpdir, target);
    out = (map)SCR::Execute (.target.bash_output, cmd);
    y2milestone ("Executing %1 returned %2", cmd, out);

    y2milestone ("Unmounting image from temporary directory");
    cmd = sformat ("umount -d -f -l %1", tmpdir);
    out = (map)SCR::Execute (.target.bash_output, cmd);
    y2milestone ("Executing %1 returned %2", cmd, out);
    return out["exit"]:-1 == 0;
    // FIXME error checking
}

/**
 * Mount an image of the filesystem type
 * Does not integrate to the system, mounts on target
 * @param id string the id of the image
 * @param target string the directory to deploy the image to
 * @return boolean true on success
 */
boolean MountFsImage (string id, string target) {
    string file = _images[id, "file"]:"";
    y2milestone ("Mounting image %1 (%2) on %3", id, file, target);
    file = sformat (_image_path, file);
    string image = Pkg::SourceProvideFile (_repo, 1, file);
    if (image == nil)
    {
	y2error ("File %1 not found on media", file);
	return false;
    }
    string cmd = sformat ("test -d %1 || mkdir -p %1", target);
    map out = (map)SCR::Execute (.target.bash_output, cmd);
    y2milestone ("Executing %1 returned %2", cmd, out);
    cmd = sformat ("mount -o loop %1 %2", image, target);
    out = (map)SCR::Execute (.target.bash_output, cmd);
    y2milestone ("Executing %1 returned %2", cmd, out);
    return out["exit"]:-1 == 0;
    // FIXME error checking
    // FIXME unmounting
}

/**
 * Deploy an image (internal implementation)
 * @param id string the id of the image
 * @param target string the directory to deploy the image to
 * @param temporary boolean true to only mount if possible (no copy)
 * @return boolean true on success
 */
boolean _DeployImage (string id, string target, boolean temporary) {
    map<string,any> img = _images[id]:$[];
    if (img == $[])
    {
	y2error ("Image %1 does not exist", id);
    }

    string type = img["type"]:"";

    if (type == "fs")
	return temporary
	    ? MountFsImage (id, target)
	    : DeployFsImage (id, target);
    else if (type == "tar")
	return DeployTarImage (id, target);

    y2error ("Unknown type of image: %1", type);
    return false;
}

/**
 * Deploy an image
 * @param id string the id of the image
 * @param target string the directory to deploy the image to
 * @return boolean true on success
 */
global boolean DeployImage (string id, string target) {
    y2milestone ("Deploying image %1 to %2", id, target);
    return _DeployImage (id, target, false);
}

/**
 * Deploy an image temporarily (just mount if possible)
 * @param id string the id of the image
 * @param target string the directory to deploy the image to,
 * @return boolean true on success
 */
global boolean DeployImageTemporarily (string id, string target) {
    y2milestone ("Temporarily delploying image %1 to %2", id, target);
    return _DeployImage (id, target, true);
}

/**
 * UnDeploy an image temporarily (if possible, only for the FS images)
 * @param id string the id of the image
 * @param target string the directory to deploy the image to,
 * @return boolean true on success
 */
global boolean CleanTemporaryImage (string id, string target) {
    y2milestone ("UnDelploying temporary image %1 from %2", id, target);
    if (_images[id, "type"]:"" == "fs")
    {
	string cmd = sformat ("umount %1", target);
	map out = (map)SCR::Execute (.target.bash_output, cmd);
	y2milestone ("Executing %1 returned %2", cmd, out);
	return out["exit"]:-1 == 0;
    }
    y2milestone ("Cannot undeploy image of type %1", _images[id, "type"]:"");
    return true;
}

/**
 * Deploy all images
 * @param images a list of images to deploy
 * @param target string directory where to deploy the images
 * @param progress a function to report overal progress
 */
global boolean DeployImages (list<string> images, string target, void(integer,integer) progress) {
    integer num = -1;

    foreach (string img, images, {
	num = num + 1;
	progress (num, 0);
	DeployImage (img, target);
    });
    progress (num, 100);

    return true;
// TODO error checking
}

/**
 * Returns the intersection of both patterns supported by the imageset
 * and patterns going to be installed.
 */
integer CountMatchingPatterns (list <string> imageset_patterns, list <string> installed_patterns) {
    integer ret = 0;

    foreach (string one_installed_pattern, installed_patterns, {
	if (contains (imageset_patterns, one_installed_pattern))
	    ret = ret + 1;
    });

    return ret;
}

boolean EnoughPatternsMatching (integer matching_patterns, integer patterns_in_imagesets) {
    if (matching_patterns == nil || matching_patterns < 0)
	return false;

    if (patterns_in_imagesets == nil || patterns_in_imagesets < 0)
	return false;

    // it's actually matching_patterns = patterns_in_imagesets
    return (matching_patterns >= patterns_in_imagesets);
}

/**
 * Find a set of images which suites selected patterns
 * @param patterns a list of patterns which are selected
 * @return boolean true on success or when media does not contain any images
 */
global boolean FindImageSet (list<string> patterns) {
    // reset all data
    _images = $[];
    _image_order = [];
    _metadata_image = "";

    // checking whether images are supported
    string filename = Pkg::SourceProvideOptionalFile (_repo, 1, "/images/images.xml");
    if (filename == nil)
    {
	Installation::image_installation = false;
	Installation::image_only= false;
	y2milestone ("Image list for installation not found");
	return true;
    }

    map<string,any> image_descr = XML::XMLToYCPFile (filename);
    if (image_descr == nil)
    {
	Installation::image_installation = false;
	Installation::image_only= false;
	Report::Error (_("Failed to read information about installation images"));
	return false;
    }

    // images are supported
    list<map<string,any> > image_sets = image_descr["image_sets"]:[];
    y2debug ("Image set descriptions: %1", image_sets);
    map<string,any> result = $[];

    // more patterns could match at once
    // as we can't merge the meta image, only one can be selected
    map <string, map <string, any> > possible_patterns = $[];
    map <string, integer> matching_patterns = $[];
    map <string, integer> patterns_in_imagesets = $[];

    // ppc (covers also ppc64), i386, x86_64 ...
    string arch_short = Arch::arch_short();
    y2milestone ("Current architecture is: %1", arch_short);

    // filter out imagesets for another architecture
    image_sets = filter (map<string,any> image, image_sets, {
	list <string> imageset_archs = splitstring (image["archs"]:"", " ,");

	// no architecture defined == noarch
	if (size (imageset_archs) == 0) {
	    return true;
	// does architecture match?
	} else {
	    return (contains (imageset_archs, arch_short));
	}
    });

    // trying to find all matching patterns
    foreach (map<string,any> image, image_sets, {
	string pattern = image["patterns"]:"";

	list <string> imageset_patterns = splitstring (pattern, ", ");
	patterns_in_imagesets[pattern] = size (imageset_patterns);

	// no image-pattern defined, matches all patterns
	if (size (imageset_patterns) == 0) {
	    possible_patterns[pattern] = image;
	// image-patterns matches to patterns got as parameter
	} else {
	    matching_patterns[pattern] = CountMatchingPatterns (imageset_patterns, patterns);

	    if (matching_patterns[pattern]:0 > 0) {
		possible_patterns[pattern] = image;
	    }
	}
    });

    y2debug ("Matching patterns: %1, sizes: %2", possible_patterns, matching_patterns);

    // selecting the best imageset
    string last_pattern = "";

    if (size (possible_patterns) > 0) {
	integer last_number_of_matching_patterns = -1;
	last_pattern = "";

	foreach (string pattern, map <string, any> image, possible_patterns, {
	    if (
		// imageset matches more patterns than the currently best-one
		matching_patterns[pattern]:0 > last_number_of_matching_patterns
		&&
		// enough patterns matches the selected imageset
		EnoughPatternsMatching (matching_patterns[pattern]:0, patterns_in_imagesets[pattern]:0)
	    ) {
		last_number_of_matching_patterns = matching_patterns[pattern]:0;
		result = image;
		last_pattern = pattern;
	    }
	});
    }

    y2milestone ("Result: %1/%2", last_pattern, result);

    // No matching pattern
    if (result == $[]) {
	Installation::image_installation = false;
	Installation::image_only= false;
	y2milestone ("No image for installation found");
	return true;
    }

    // We've selected one
    Installation::image_installation = true;

    if (haskey (result, "pkg_image")) {
	_metadata_image = result["pkg_image"]:"";
    } else {
	Installation::image_only= true;
    }

    // Adding images one by one into the pool
    foreach (map<string,string> img, result["images"]:[], {
	// image must have unique <file>...</file> defined
	if (img["file"]:"" == "") {
	    y2error ("No file defined for %1", img);
	    return;
	}

	_image_order = add (_image_order, img["file"]:"");
	AddImage (img["name"]:"", img["file"]:"", img["type"]:"");
    });

    y2milestone ("Image-only installation: %1", Installation::image_only);
    y2milestone ("Images: %1", _images);
    y2milestone ("Image installation order: %1", _image_order);

    if (! Installation::image_only)
	y2milestone ("Image with software management metadata: %1", _metadata_image);

    return true;
}

/**
 * Copy a subtree, limit to a single filesystem
 * @param from string source directory
 * @param to string target directory
 * @return boolean true on success
 */
global boolean FileSystemCopy (string from, string to,
    integer progress_start,
    integer progress_finish)
{
    string cmd = sformat ("du -x -B 1048576 -s %1", from);
    y2milestone ("Executing %1", cmd);
    map out = (map)SCR::Execute (.target.bash_output, cmd);
    y2milestone ("Output: %1", out);
    string total_str = out["stdout"]:"";
    integer total_mb = tointeger (total_str);
    if (total_mb == 0)
	total_mb = 1024*1024*1024; // should be big enough

    string tmp_pipe1 = (string)SCR::Read (.target.tmpdir) + "/system_clone_fifo_1";
    string tmp_pipe2 = (string)SCR::Read (.target.tmpdir) + "/system_clone_fifo_2";
    // FIXME this does not copy pipes in filesystem (usually not an issue)
    cmd = sformat (
	"mkfifo %3 ;
	 mkfifo %4 ;
	 tar -C %1 -cSf %3 --one-file-system . &
	 dd bs=1048576 if=%3 of=%4 >&2 &
	 jobs -l >&2;
	 tar -C %2 -xSf %4",
	from, to, tmp_pipe1, tmp_pipe2);
    y2milestone ("Executing %1", cmd);
    SCR::Execute(.background.run_output_err, cmd);
    string pid = "";

    while((boolean)SCR::Read(.background.output_open_err) || (boolean)(SCR::Read(.background.newlines_err) > 0))
    {
	string done = nil;
	if ((integer)SCR::Read (.background.newlines_err) > 0)
	{
	    list<string> lines = (list<string>)SCR::Read (.background.newerr);
	    while (pid == "" && size (lines) > 0)
	    {
		pid = lines[0]:"";
		lines[0] = nil;
		lines = filter (string l, lines, { return l != nil; });
		if (! regexpmatch (pid, sformat ("dd bs=1048576 if=%1 of=%2", tmp_pipe1, tmp_pipe2)))
		    pid = "";
		else
		{
		    pid = regexpsub (pid, "([0-9]+) [^ 0-9]+ +dd", "\\1");
		    y2milestone ("DD's pid: %1", pid);
		    // sleep in order not to kill -USR1 to dd too early, otherwise it finishes
		    sleep (5000);
		}
	    }
	    foreach (string l, lines, {
		if (regexpmatch (l, "^[0-9]+ "))
		    done = regexpsub (l, "^([0-9]+) ", "\\1");
	    });
	    y2debug ("Done: %1", done);
	}
	if (pid != "")
	{
	    cmd = sformat ("/bin/kill -USR1 %1", pid);
	    y2debug ("Executing %1", cmd);
	    SCR::Execute (.target.bash, cmd);
	}
	sleep (300);
	if (done != nil)
	{
	    integer progress = progress_start + (progress_finish - progress_start) * tointeger (done) / total_mb / 1024 / 1024;
	    Progress::Step (progress);
	    y2debug ("Setting progress to %1", progress);
	}
    }

    y2milestone ("Result: %1", SCR::Read (.background.status));
    SCR::Execute (.target.remove, tmp_pipe1);
    SCR::Execute (.target.remove, tmp_pipe2);
    cmd = sformat ("chown --reference=%1 %2; chmod --reference=%1 %2",
	from, to);
    y2milestone ("Executing %1", cmd);
    out = (map)SCR::Execute (.target.bash_output, cmd);
    y2milestone ("Result: %1", out);
    return out["exit"]:-1 == 0;
}

    // --> Storing and restoring states

    /**
     * List of all handled types.
     */
    // list <symbol> all_supported_types = [`product, `pattern, `selection, `language, `package, `patch];
    // Zypp currently counts [ `product, `pattern, `selection, `language ]
    list <symbol> all_supported_types = [`package, `patch];

    /**
     * Map that stores all the requested states of all handled/supported types.
     */
    map <symbol, map <string, list <map> > > objects_state = $[];

    /**
     * Function stores all new/requested states of all handled/supported types.
     *
     * @see all_supported_types
     * @see objects_state
     */
    global void StoreAllChanges () {
        Progress::Simple (
            _("Installation Magic"),
            _("Storing magic values..."),
            4 * size (all_supported_types),
            _("<p>MOOOooo...</p>")
        );

        // Query for changed state of all knwon types
        // 'changed' means that they were 'installed' and 'not locked' before
        foreach (symbol one_type, all_supported_types, {
            // list of $[ "name":string, "version":string, "arch":string, "source":integer, "status":symbol, "locked":boolean ]
            // status is `installed, `removed, `selected or `available, source is source ID or -1 if the resolvable is installed in the target
            // if status is `available and locked is true then the object is set to taboo
            // if status is `installed and locked is true then the object locked
            list <map <string, any> > resolvable_properties = Pkg::ResolvableProperties ("", one_type, "");

            objects_state[one_type] = $[];

            list <map <string, any> > remove_resolvables = filter (map <string, any> one_object, resolvable_properties, {
                return (one_object["status"]:`unknown == `removed);
            });
            objects_state[one_type, "remove"] = remove_resolvables;
            Progress::NextStep();

            list <map <string, any> > install_resolvables = filter (map <string, any> one_object, resolvable_properties, {
                return (one_object["status"]:`unknown == `selected);
            });
            objects_state[one_type, "install"] = install_resolvables;
            Progress::NextStep();

            list <map <string, any> > taboo_resolvables = filter (map <string, any> one_object, resolvable_properties, {
                return (one_object["status"]:`unknown == `available && one_object["locked"]:false == true);
            });
            objects_state[one_type, "taboo"] = taboo_resolvables;
            Progress::NextStep();

            list <map <string, any> > lock_resolvables = filter (map <string, any> one_object, resolvable_properties, {
                return (one_object["status"]:`unknown == `installed && one_object["locked"]:false == true);
            });
            objects_state[one_type, "lock"] = lock_resolvables;
            Progress::NextStep();
        });

        Progress::Finish();
    }

    /**
     * @return boolean whether the package should be additionally installed
     */
    boolean ProceedWithSelected (map <string, any> & one_object, symbol & one_type) {
	// This package has been selected to be installed

	string arch = one_object["arch"]:"";
	// Query for all packages of the same version
	list <map <string, any> > resolvable_properties = Pkg::ResolvableProperties (
	    one_object["name"]:"-x-", one_type, one_object["version"]:"-x-"
	);

	// Leave only already installed (and matching the same architecture)
	resolvable_properties = filter (map <string, any> one_resolvable, resolvable_properties, {
	    return (one_resolvable["status"]:`unknown == `installed && one_resolvable["arch"]:"" == arch);
	});

	boolean ret = nil;

	// There are some installed
	if (size (resolvable_properties) > 0) {
	    y2milestone ("Resolvable type: %1, name: %2 already installed", one_type, one_object["name"]:"-x-");
	    // Let's keep the installed version
	    Pkg::ResolvableNeutral (one_object["name"]:"-x-", one_type, true);
	    // is already installed
	    ret = false;
	// They are not installed
	} else {
	    y2milestone ("Installing type: %1, details: %2,%3,%4",
		one_type, one_object["name"]:"", one_object["arch"]:"", one_object["version"]:"");
	    // Confirm we want to install them (they might have been added as dependencies)
	    Pkg::ResolvableInstallArchVersion (one_object["name"]:"", one_type, one_object["arch"]:"", one_object["version"]:"");
	    // should be installed
	    ret = true;
	}

	return ret;
    }

    global void RestoreAllChanges () {
        Progress::Simple (
            _("Installation Magic"),
            _("Restoring magic values..."),
            4 * size (all_supported_types),
            _("<p>MOOOooo...</p>")
        );

        foreach (symbol one_type, all_supported_types, {
            list <map <string, any> > resolvable_properties = Pkg::ResolvableProperties ("", one_type, "");

	    // All packages selected for installation
	    // both `to-install and `to-upgrade (already) installed
            list <map <string, any> > to_install = filter (map <string, any> one_resolvable, resolvable_properties, {
                return (one_resolvable["status"]:`unknown == `selected);
            });

            Progress::NextStep();

	    // All packages selected to be installed
	    // [ $[ "arch" : ... , "name" : ... , "version" : ... ], ... ]
	    list <map <string, string> > selected_for_installation = maplist (map one_resolvable, objects_state[one_type, "install"]:[], {
		return $[ "arch":one_resolvable["arch"]:"", "name":one_resolvable["name"]:"", "version":one_resolvable["version"]:"" ];
	    });

	    Progress::NextStep();

	    // Delete all packages that are installed but should not be
	    map <string, string> one_already_installed_resolvable = $[];
            foreach (map <string, any> one_resolvable, resolvable_properties, {
        	// We are interested in the already installed resolvables only
                if (one_resolvable["status"]:`unknown != `installed && one_resolvable["status"]:`unknown != `selected) {
		    return;
		}

                one_already_installed_resolvable =  $[
		    "arch":one_resolvable["arch"]:"", "name":one_resolvable["name"]:"", "version":one_resolvable["version"]:""
            	];

		// Already installed resolvable but not in list of resolvables to be installed
		if (! contains (selected_for_installation, one_already_installed_resolvable)) {
		    y2milestone ("Removing type: %1, name: %2 version: %3",
			one_type, one_resolvable["name"]:"-x-", one_resolvable["version"]:"-x-");
		    Pkg::ResolvableRemove (one_resolvable["name"]:"-x-", one_type);
		}
            });

            Progress::NextStep();

	    // Install all packages that aren't yet
	    foreach (map <string, any> one_to_install, to_install, {
		ProceedWithSelected (one_to_install, one_type);
	    });

	    Progress::NextStep();
        });

        Progress::Finish();
    }

    // <-- Storing and restoring states

}