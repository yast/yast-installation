/**
 * File:	modules/Register.ycp
 * Package:	Installation
 * Summary:	Registration related stuff
 * Authors:	J. Daniel Schmidt <jdsn@suse.de>
 *
 * $Id: Register.ycp 1 2005-03-13 08:45:05Z jdsn $
 */

{

module "Register";
textdomain "installation";

import "FileUtils";
import "URL";
import "Mode";
import "String";
import "Misc";
import "Stage";
import "Label";
import "ProductFeatures";



// --------------------------------------------------------------
// START: Locally defined data
// --------------------------------------------------------------

string services_file = sformat ("%1/update_services", SCR::Read (.target.tmpdir));

// ------------------------------------------------------------------
// END:   Locally defined data
// ------------------------------------------------------------------

// --------------------------------------------------------------
// START: Globally defined data, access via Register::<variable>
// --------------------------------------------------------------

global boolean autoYaSTModified = false;
global boolean do_registration = false;
global boolean iamroot = false;

global boolean submit_optional = false;
global boolean submit_hwdata   = false;
global boolean force_registration = false;
global boolean display_forcereg = false;
global boolean disable_w3m = false;
global boolean use_proxy   = false;
global string  http_proxy  = "";
global string  https_proxy = "";

global map<string, string> registration_data = $[];

// ------------------------------------------------------------------
// END: Globally defined data, access via Register::<variable>
// ------------------------------------------------------------------


// ------------------------------------------------------------------
// START: Locally defined functions
// ------------------------------------------------------------------

/*
 * get_home_dir()
 *
 * get the home directory of the user running this module
 * because not only root is allowed to run inst_suse_register
 *
 * @return home directory as string
 *
 */
string get_home_dir()
{
    map<string, any> gethome = (map<string, any>) SCR::Execute(.target.bash_output, " cd; pwd ");
    return ((integer) gethome["exit"]:1 == 0) ?  String::FirstChunk(gethome["stdout"]:"/tmp", "\n") : "/tmp";
}



/*
 * amIroot()
 *
 * checks if running as root
 * returns true if running as root - else returns false
 *
 */
boolean amIroot()
{
    // check if we are root
    map<string, any> userid = (map<string, any>) SCR::Execute(.target.bash_output, "id -u");
    y2milestone("running with user id %1", userid);
    return  String::FirstChunk(userid["stdout"]:"1", "\n") == "0" ? true:false;
}


/*
 * read_config()
 *
 * reads the configuration of the registration module from sysconfig and/or user's home
 *
 */
void read_config()
{
    // first read from control file
    submit_optional = ProductFeatures::GetBooleanFeature("globals", "enable_register_optional");
    submit_hwdata   = ProductFeatures::GetBooleanFeature("globals", "enable_register_hwdata");
    // this boolean comes only from the control file - nowhere to be saved
    display_forcereg = ProductFeatures::GetBooleanFeature("globals", "display_register_forcereg");
    disable_w3m = ProductFeatures::GetBooleanFeature("globals", "disable_register_w3m");

    // read proxy settings
    use_proxy   = (string) SCR::Read(.sysconfig.proxy.PROXY_ENABLED) == "yes" ? true:false;
    http_proxy  = (string) SCR::Read(.sysconfig.proxy.HTTP_PROXY);
    https_proxy = (string) SCR::Read(.sysconfig.proxy.HTTPS_PROXY);

    // then read from sysconfig
    if (FileUtils::Exists("/etc/sysconfig/suse_register"))
    {
        submit_optional = (string) SCR::Read( .sysconfig.suse_register.SUBMIT_OPTIONAL ) == "true" ? true:false;
        submit_hwdata   = (string) SCR::Read( .sysconfig.suse_register.SUBMIT_HWDATA )   == "true" ? true:false;
    }

    // and in case of nonroot read from user's home
    if (!iamroot)
    {
        string home_config = sformat("%1/.suse_register", get_home_dir() );
        if (FileUtils::Exists(home_config))
        {
            foreach (string line,
              splitstring ((string)SCR::Read(.target.string, home_config ),"\n"), {
                if       ( regexpmatch(line, "^SUBMIT_OPTIONAL=\"[^\"]*\".*$") )
                    submit_optional = regexpsub(line, "^SUBMIT_OPTIONAL=\"([^\"]*)\".*$", "\\1") == "true" ? true:false;
                else if  ( regexpmatch(line, "^SUBMIT_HWDATA=\"[^\"]*\".*$") )
                    submit_hwdata  =  regexpsub(line, "^SUBMIT_HWDATA=\"([^\"]*)\".*$", "\\1") == "true" ? true:false;
            });
        }
    }
}



/*
 * write_config()
 *
 * writes the configuration to the system
 * either to sysconfig if runnig as root or to user's home if running as non-root
 *
 */
void write_config()
{
    if (iamroot)
    {
        SCR::Write(.sysconfig.suse_register.SUBMIT_OPTIONAL, sformat("%1", submit_optional ? true:false ));
        SCR::Write(.sysconfig.suse_register.SUBMIT_HWDATA,   sformat("%1", submit_hwdata   ? true:false ));
    }
    else
    {
       string home_config = sformat("%1/.suse_register", get_home_dir() );
       string confdata    = sformat("#\n# .suse_register is created and read by YaST\n# it stores the configuration status of the registration module\n#\n\nSUBMIT_OPTIONAL=\"%1\"\nSUBMIT_HWDATA=\"%2\"", submit_optional ? true:false, submit_hwdata ? true:false );
       SCR::Write(.target.string, home_config,  confdata);
    }

}

/**
 * Parse a URL query (already unescaped) to a map.
 * If no equal sign, the value will be nil.
 * @param query foo=bar&baz=qux
 * @return $["foo": "bar", "baz": "qux"]
 */
map<string, string> ParseUrlQuery (string query) {
    list<string> q_items = splitstring (query, "&");
    map<string, string> q_map = listmap (string q_item, q_items, {
	integer eqpos = search (q_item, "=");
	if (eqpos == nil)
	{
	    return $[ q_item: nil ];
	}
	else
	{
	    string key = substring (q_item, 0, eqpos);
	    string val = substring (q_item, eqpos + 1);
	    return $[ key: val ];
	}
    });
    return q_map;
}

/**
 * @return For existing sources, get a mapping from the alias to the id
 */
map<string,integer> get_alias_to_id () {
    list<integer> src_ids = Pkg::SourceGetCurrent (false /*enabled only?*/);
    map<string,integer> a2i = listmap (integer src_id, src_ids, {
	map gendata = Pkg::SourceGeneralData (src_id);
	string alias = gendata["alias"]:"";
	return $[ alias: src_id ];
    });
    return a2i;
}

// ------------------------------------------------------------------
// END: Locally defined functions
// ------------------------------------------------------------------


// ---------------------------------------------------------------------------------------
// START: Globally defined functions
// ---------------------------------------------------------------------------------------



/*
 * initialize
 *
 * Initialize booleans: submit_optional, submit_hwdata and iamroot
 *
 */
global void initialize()
{
    read_config();
    iamroot = amIroot();
}



/*
 * finish
 *
 * Finishing the modules stuff: calling write_config()
 *
 */
global void finish()
{
    iamroot = amIroot();
    write_config();
}

/*
 * suseRegister()
 * the returned map is transformed to map<string, string>
*/
global map<string, string> suseRegister(symbol parameter)
{
    // handle parameters
    //  -y beautifies the output for usage in yast
    //  -L log file
    //  -p list parameters (no dumpfile with -p)

    // always log and beautify!
    string params = " -y -L ~/.suse_register.log ";
    if (parameter == `p) params = params + " -p ";
    else params = params + sformat(" --dumpfile=%1 ", services_file);

    string pre_sr = " umask 0077; ";
    if (Register::use_proxy)
    {   // (#165891)
        pre_sr = pre_sr + " http_proxy='"  + Register::http_proxy  + "' ";
        pre_sr = pre_sr + " https_proxy='" + Register::https_proxy + "' ";
    }

    if (parameter == `autoyast)
    {
        // append values from map to the suse_register call
        foreach (string key, string val, registration_data,  {
            key = String::CutRegexMatch(key, "[^A-Za-z0-9_-]+", true );
            params = params + sformat("  -a %1='%2'  ", key, String::Quote(val) );
        });
        y2milestone ("called from autoyast - added registration data to suse_register call");
    }

    if ( force_registration ) params = params + " --force-registration ";
    if ( !submit_hwdata   )   params = params + " --no-hw-data ";
    if ( !submit_optional )   params = params + " --no-optional ";

    // run suse_register
    string sr_bash_cmd = sformat(" %1 /usr/bin/suse_register %2", pre_sr, params);
    y2milestone ("Calling suse_register with command: %1", sr_bash_cmd);

    map<string, string> response = $[];

    if (parameter == `autoyast)
    {
        map<string, any> info = (map<string, any>) SCR::Execute(.target.bash_output, sr_bash_cmd );
        string exitcode = sformat("%1", info["exit"]:99);
        y2milestone ("/usr/bin/suse_register returned %1", exitcode);

        // transform to map<string, string>
        response = $[  "exit"  :exitcode ,
                       "stdout":info["stdout"]:"",
                       "stderr":info["stderr"]:""  ];
    }
    else
    {   // (#164794)
        boolean started = (boolean) SCR::Execute(.background.run_output_err, sr_bash_cmd );
	// translators: busy popup while registering the system
        UI::OpenDialog(`VBox( `Label( _("Contacting server...")),
                              `PushButton(`id(`abort), Label::AbortButton() )
        ) );

	// Bug #171061 - Busy cursor during "Contacting server..."
	UI::BusyCursor();

        symbol poll_ret = nil;
        repeat
        {
            poll_ret = (symbol) UI::TimeoutUserInput(200);

            // check if  process still running ... and check status
            if (! (boolean) SCR::Read(.background.isrunning))
                poll_ret = `finish;

        } until (poll_ret == `abort || poll_ret == `finish);

	// Bug #171061 - Changing back to normal cursor
	UI::NormalCursor();

        if (poll_ret == `finish)
        {
            // create return hash
            response = $[ "exit":   sformat("%1", SCR::Read(.background.status)) ,
                          "stdout": mergestring( (list<string>) SCR::Read(.background.newout), "\n") ,
                          "stderr": mergestring( (list<string>) SCR::Read(.background.newerr), "\n")  ];
        }
        else
        {
            // kill background process
            if (! (boolean)SCR::Execute(.background.kill))
            {
                sleep(300);
                SCR::Execute(.background.kill);
            }
            response = $["exit":"199", "stdout":"aborted", "stderr":"aborted"];
        }
        UI::CloseDialog();
    }

    y2milestone ("Server response: %1", response);
    return response;
}




global boolean add_update_sources ()
{

    // make it possible to be run as non-root (system will be inconsistent then)
    // TODO: to be removed when rug lets authorized users add installation sources
    if ( !iamroot ) return false;

    if (!FileUtils::Exists (services_file))
    return false;

    // prepare for lookup of known aliases
    map<string,integer> aliases = get_alias_to_id ();
    y2milestone ("alias mapping: %1", aliases);

    // filters out empty items (#165860#c12)
    list<string> urls = String::NewlineItems (
	(string)SCR::Read(.target.string, services_file));
    // add the sources.
    // but do not make duplicates (#168740)
    // we detect them based on alias that suse_register gives us (#158850#c17)
    /// (but only for SLE... :-/ )
    /// Need to test what happens when we get two different update
    /// servers for SL
    /// Anyway that means only that #168740 remains unfixed for SL
    foreach (string url, urls, {
	y2milestone ("Should add an update source: %1", url);
	// inst_addon_update_sources also calls Pkg::SourceCreate
	// but it already skips duplicates

	// plan: (log each step!)
	// parse the URL
	map parsed_url = URL::Parse (url);
	y2milestone ("parsed: %1", parsed_url);
	// (reassemble and warn if it differs)
	string reassembled = URL::Build (parsed_url);
	if (url != reassembled)
	{
	    y2warning ("reassembled differs: %1", reassembled);
	}
	// get the alias
	map<string, string> q_map = ParseUrlQuery (parsed_url["query"]:"");
	y2milestone ("query: %1", q_map);
	string alias = q_map["alias"]:"";
	// check if alias already there (empty: box safeguard)
	// if yes, delete the old one
	if (alias != "" && haskey (aliases, alias))
	{
	    integer todel = aliases[alias]:-1;
	    y2milestone ("deleting the old copy, source %1", todel); 
	    Pkg::SourceDelete (todel);
	}
	// then add the new one
	y2milestone ("adding source");
        Pkg::SourceCreate (url, "/");
    });
    return true;
}





// ------------------------------------------------------------------
// END: Globally defined functions
// ------------------------------------------------------------------



/*
 * Read()
 */
global void Read()
{
    initialize();
}


/*
 * Import()
 */
global boolean Import(map settings)
{
    iamroot = amIroot();

    submit_optional = false;
    submit_hwdata   = false;
    do_registration = false;
    registration_data = $[];

    submit_optional     = (boolean) settings["submit_optional"]:submit_optional;
    submit_hwdata       = (boolean) settings["submit_hwdata"]:submit_hwdata;
    do_registration     = (boolean) settings["do_registration"]:do_registration;
    registration_data   = (map<string, string>) settings["registration_data"]:$[];

    return true;
}



/*
 * Write()
 */
global boolean Write()
{
    iamroot = amIroot();
    if (do_registration) suseRegister(`autoyast);
    finish();
    return true;
}



/**
 * AutoYaST interface function: Export()
 * @return map with the settings
 */
global map Export()
{
    return $[
               "submit_optional":submit_optional,
               "submit_hwdata":submit_hwdata,
               "do_registration":do_registration,
               "registration_data":registration_data
    ];
}

} // -EOF-
