/**
 * File:	modules/Register.ycp
 * Package:	Installation
 * Summary:	Registration related stuff
 * Authors:	J. Daniel Schmidt <jdsn@suse.de>
 *
 * $Id: Register.ycp 1 2005-03-13 08:45:05Z jdsn $
 */

{

module "Register";
textdomain "installation";

import "FileUtils";
import "Mode";
import "String";
import "Misc";
import "Stage";
import "Label";
import "ProductFeatures";
import "SourceManager";



// --------------------------------------------------------------
// START: Locally defined data
// --------------------------------------------------------------

string services_file = sformat ("%1/update_services", SCR::Read (.target.tmpdir));

// ------------------------------------------------------------------
// END:   Locally defined data
// ------------------------------------------------------------------

// --------------------------------------------------------------
// START: Globally defined data, access via Register::<variable>
// --------------------------------------------------------------

global boolean autoYaSTModified = false;
global boolean do_registration = false;
global boolean iamroot = false;

global boolean submit_optional = false;
global boolean submit_hwdata   = false;
global boolean force_registration = false;
global boolean display_forcereg = false;
global boolean disable_w3m = false;
global boolean use_proxy   = false;
global string  http_proxy  = "";
global string  https_proxy = "";

global map<string, string> registration_data = $[];

// ------------------------------------------------------------------
// END: Globally defined data, access via Register::<variable>
// ------------------------------------------------------------------


// ------------------------------------------------------------------
// START: Locally defined functions
// ------------------------------------------------------------------

/*
 * get_home_dir()
 *
 * get the home directory of the user running this module
 * because not only root is allowed to run inst_suse_register
 *
 * @return home directory as string
 *
 */
string get_home_dir()
{
    map<string, any> gethome = (map<string, any>) SCR::Execute(.target.bash_output, " cd; pwd ");
    return ((integer) gethome["exit"]:1 == 0) ?  String::FirstChunk(gethome["stdout"]:"/tmp", "\n") : "/tmp";
}



/*
 * amIroot()
 *
 * checks if running as root
 * returns true if running as root - else returns false
 *
 */
boolean amIroot()
{
    // check if we are root
    map<string, any> userid = (map<string, any>) SCR::Execute(.target.bash_output, "id -u");
    y2milestone("running with user id %1", userid);
    return  String::FirstChunk(userid["stdout"]:"1", "\n") == "0" ? true:false;
}


/*
 * read_config()
 *
 * reads the configuration of the registration module from sysconfig and/or user's home
 *
 */
void read_config()
{
    // first read from control file
    submit_optional = ProductFeatures::GetBooleanFeature("globals", "enable_register_optional");
    submit_hwdata   = ProductFeatures::GetBooleanFeature("globals", "enable_register_hwdata");
    // this boolean comes only from the control file - nowhere to be saved
    display_forcereg = ProductFeatures::GetBooleanFeature("globals", "display_register_forcereg");
    disable_w3m = ProductFeatures::GetBooleanFeature("globals", "disable_register_w3m");

    // read proxy settings
    use_proxy   = (string) SCR::Read(.sysconfig.proxy.PROXY_ENABLED) == "yes" ? true:false;
    http_proxy  = (string) SCR::Read(.sysconfig.proxy.HTTP_PROXY);
    https_proxy = (string) SCR::Read(.sysconfig.proxy.HTTPS_PROXY);

    // then read from sysconfig
    if (FileUtils::Exists("/etc/sysconfig/suse_register"))
    {
        submit_optional = (string) SCR::Read( .sysconfig.suse_register.SUBMIT_OPTIONAL ) == "true" ? true:false;
        submit_hwdata   = (string) SCR::Read( .sysconfig.suse_register.SUBMIT_HWDATA )   == "true" ? true:false;
    }

    // and in case of nonroot read from user's home
    if (!iamroot)
    {
        string home_config = sformat("%1/.suse_register", get_home_dir() );
        if (FileUtils::Exists(home_config))
        {
            foreach (string line,
              splitstring ((string)SCR::Read(.target.string, home_config ),"\n"), {
                if       ( regexpmatch(line, "^SUBMIT_OPTIONAL=\"[^\"]*\".*$") )
                    submit_optional = regexpsub(line, "^SUBMIT_OPTIONAL=\"([^\"]*)\".*$", "\\1") == "true" ? true:false;
                else if  ( regexpmatch(line, "^SUBMIT_HWDATA=\"[^\"]*\".*$") )
                    submit_hwdata  =  regexpsub(line, "^SUBMIT_HWDATA=\"([^\"]*)\".*$", "\\1") == "true" ? true:false;
            });
        }
    }
}



/*
 * write_config()
 *
 * writes the configuration to the system
 * either to sysconfig if runnig as root or to user's home if running as non-root
 *
 */
void write_config()
{
    if (iamroot)
    {
        SCR::Write(.sysconfig.suse_register.SUBMIT_OPTIONAL, sformat("%1", submit_optional ? true:false ));
        SCR::Write(.sysconfig.suse_register.SUBMIT_HWDATA,   sformat("%1", submit_hwdata   ? true:false ));
    }
    else
    {
       string home_config = sformat("%1/.suse_register", get_home_dir() );
       string confdata    = sformat("#\n# .suse_register is created and read by YaST\n# it stores the configuration status of the registration module\n#\n\nSUBMIT_OPTIONAL=\"%1\"\nSUBMIT_HWDATA=\"%2\"", submit_optional ? true:false, submit_hwdata ? true:false );
       SCR::Write(.target.string, home_config,  confdata);
    }

}

// ------------------------------------------------------------------
// END: Locally defined functions
// ------------------------------------------------------------------


// ---------------------------------------------------------------------------------------
// START: Globally defined functions
// ---------------------------------------------------------------------------------------



/*
 * initialize
 *
 * Initialize booleans: submit_optional, submit_hwdata and iamroot
 *
 */
global void initialize()
{
    read_config();
    iamroot = amIroot();
}



/*
 * finish
 *
 * Finishing the modules stuff: calling write_config()
 *
 */
global void finish()
{
    iamroot = amIroot();
    write_config();
}



/*
 * add_update_sources
 *
 * read update sources from services file and add them to yast and zmd
 * @return a list of added URLs
 */
global list<string> add_update_sources ()
{

    // make it possible to be run as non-root (system will be inconsistent then)
    // TODO: to be removed when rug lets authorized users add installation sources
    if ( !iamroot )
	return [];

    if (!FileUtils::Exists (services_file))
	return [];

    // filters out empty items (#165860#c12)
    list<string> urls = String::NewlineItems (
	(string)SCR::Read(.target.string, services_file));

    return SourceManager::AddUpdateSources (urls);
}


/*
 * suseRegister()
 * the returned map is transformed to map<string, string>
*/
global map<string, string> suseRegister(symbol parameter)
{
    // handle parameters
    //  -y beautifies the output for usage in yast
    //  -L log file
    //  --nozypp do not add zypp and yum sources to zmd, #180820
    //  -p list parameters (no dumpfile with -p)

    // always log and beautify!
    string params = " -y -L ~/.suse_register.log --nozypp ";
    if (parameter == `p) params = params + " -p ";
    else params = params + sformat(" --dumpfile=%1 ", services_file);

    string pre_sr = " umask 0077; ";
    if (Register::use_proxy)
    {   // (#165891)
        pre_sr = pre_sr + " http_proxy='"  + Register::http_proxy  + "' ";
        pre_sr = pre_sr + " https_proxy='" + Register::https_proxy + "' ";
    }

    if (parameter == `autoyast)
    {
        // append values from map to the suse_register call
        foreach (string key, string val, registration_data,  {
            key = String::CutRegexMatch(key, "[^A-Za-z0-9_-]+", true );
            params = params + sformat("  -a %1='%2'  ", key, String::Quote(val) );
        });
        y2milestone ("called from autoyast - added registration data to suse_register call");
    }

    if ( force_registration ) params = params + " --force-registration ";
    if ( !submit_hwdata   )   params = params + " --no-hw-data ";
    if ( !submit_optional )   params = params + " --no-optional ";

    // run suse_register
    string sr_bash_cmd = sformat(" %1 /usr/bin/suse_register %2", pre_sr, params);
    y2milestone ("Calling suse_register with command: %1", sr_bash_cmd);

    map<string, string> response = $[];

    if (parameter == `autoyast)
    {
        map<string, any> info = (map<string, any>) SCR::Execute(.target.bash_output, sr_bash_cmd );
        string exitcode = sformat("%1", info["exit"]:99);
        y2milestone ("/usr/bin/suse_register returned %1", exitcode);

        // add update sources in autoyast mode as well, no matter what exit code suse_register returned (#181183)
        Register::add_update_sources();

        // transform to map<string, string>
        response = $[  "exit"  :exitcode ,
                       "stdout":info["stdout"]:"",
                       "stderr":info["stderr"]:""  ];
    }
    else
    {   // (#164794)
        boolean started = (boolean) SCR::Execute(.background.run_output_err, sr_bash_cmd );

	// translators: busy popup while registering the system
	string fixme_get_this_out_of_here_ASAP = _("This may take a while");
	
        UI::OpenDialog(`VBox( `Left( `Label( _("Contacting server...")) ),
                              `Left( `Label( fixme_get_this_out_of_here_ASAP )),  // (hmuelle, shorn)
                              `PushButton(`id(`abort), Label::AbortButton() )
        ) );

	// Bug #171061 - Busy cursor during "Contacting server..."
	UI::BusyCursor();

        symbol poll_ret = nil;
        repeat
        {
            poll_ret = (symbol) UI::TimeoutUserInput(200);

            // check if  process still running ... and check status
            if (! (boolean) SCR::Read(.background.isrunning))
                poll_ret = `finish;

        } until (poll_ret == `abort || poll_ret == `finish);

	// Bug #171061 - Changing back to normal cursor
	UI::NormalCursor();

        if (poll_ret == `finish)
        {
            // create return hash
            response = $[ "exit":   sformat("%1", SCR::Read(.background.status)) ,
                          "stdout": mergestring( (list<string>) SCR::Read(.background.newout), "\n") ,
                          "stderr": mergestring( (list<string>) SCR::Read(.background.newerr), "\n")  ];
        }
        else
        {
            // kill background process
            if (! (boolean)SCR::Execute(.background.kill))
            {
                sleep(300);
                SCR::Execute(.background.kill);
            }
            response = $["exit":"199", "stdout":"aborted", "stderr":"aborted"];
        }
        UI::CloseDialog();
    }

    y2milestone ("Server response: %1", response);
    return response;
}
// ------------------------------------------------------------------
// END: Globally defined functions
// ------------------------------------------------------------------



/*
 * Read()
 */
global void Read()
{
    initialize();
}


/*
 * Import()
 */
global boolean Import(map settings)
{
    iamroot = amIroot();

    submit_optional = false;
    submit_hwdata   = false;
    do_registration = false;
    registration_data = $[];

    submit_optional     = (boolean) settings["submit_optional"]:submit_optional;
    submit_hwdata       = (boolean) settings["submit_hwdata"]:submit_hwdata;
    do_registration     = (boolean) settings["do_registration"]:do_registration;
    registration_data   = (map<string, string>) settings["registration_data"]:$[];

    return true;
}



/*
 * Write()
 */
global boolean Write()
{
    iamroot = amIroot();
    if (do_registration) suseRegister(`autoyast);
    finish();
    return true;
}



/**
 * AutoYaST interface function: Export()
 * @return map with the settings
 */
global map Export()
{
    return $[
               "submit_optional":submit_optional,
               "submit_hwdata":submit_hwdata,
               "do_registration":do_registration,
               "registration_data":registration_data
    ];
}

} // -EOF-
